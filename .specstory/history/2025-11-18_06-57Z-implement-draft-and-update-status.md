<!-- Generated by SpecStory, Markdown v2.0.0 -->

<!-- cursor Session 81f3cfc5-866d-4847-ba68-eb9ee9644b09 (2025-11-18 06:57Z) -->

# Implement draft and update status (2025-11-18 06:57Z)

_**User (2025-11-17 22:51Z)**_

@agent-stream-5-state-draft.md Implement this and then update the status in the document

---

_**Agent (model default, mode Agent)**_

<think><details><summary>Thought Process</summary>
**Preparing to read instructions**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/sahilmehta/supplier-onboarding-simple/docs/agent-stream-5-state-draft.md</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Planning implementation and inspecting repo**</details></think>

---

<tool-use data-tool-type="generic" data-tool-name="list_dir">
<details>
            <summary>Tool use: **list_directory** • Listed directory undefined • **0** results</summary>
        
No results found
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Planning exploration and analysis**</details></think>

---

<tool-use data-tool-type="generic" data-tool-name="list_dir">
<details>
            <summary>Tool use: **list_directory** • Listed directory undefined • **0** results</summary>
        
No results found
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Exploring dynamic form component**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/sahilmehta/supplier-onboarding-simple/components/forms/dynamic-form-wizard.tsx</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Integrating new hook and creating navigation file**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/sahilmehta/supplier-onboarding-simple/components/forms/form-navigation.tsx</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Inspecting app form routes**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/sahilmehta/supplier-onboarding-simple/app/forms/[entityCode]/[geographyCode]/page.tsx</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Loading drafts and formConfigId page**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/sahilmehta/supplier-onboarding-simple/app/forms/[formConfigId]/page.tsx</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Starting server actions implementation**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/sahilmehta/supplier-onboarding-simple/components/forms/form-wizard-client.tsx</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Planning integration of server actions**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/sahilmehta/supplier-onboarding-simple/prisma/schema.prisma</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Outlining implementation tasks**

I'm planning the main tasks like using Prisma, managing form state, autosave, and server actions, while thinking about how to organize the work and referencing existing state management code.</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/sahilmehta/supplier-onboarding-simple/lib/application-state.ts</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Checking existing hooks**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/sahilmehta/supplier-onboarding-simple/hooks/use-field-validation.ts</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Planning form state and autosave implementation**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/sahilmehta/supplier-onboarding-simple/components/forms/index.ts</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Checking export requirements**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/sahilmehta/supplier-onboarding-simple/lib/forms/types.ts</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Planning feature implementation**</details></think>

---

<tool-use data-tool-type="generic" data-tool-name="todo_write">
<details><summary>Tool use: **todo_write** • Todo List</summary>

- [-] Review Stream 5 requirements and inspect current form wizard/state logic
- [ ] Implement shared form state + draft persistence libs/hooks
- [ ] Integrate autosave and draft UI into form components/routes
- [ ] Add server actions + route draft loading, update docs status

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Designing form state management system**

I'm outlining a detailed plan to implement a comprehensive form state system with a `FormState` interface, helper functions, and a `useFormState` hook using React’s `useReducer`. This will manage touched fields, errors, steps, and syncing with server actions through a draft manager and autosave hooks, all needing careful coordination across client and server boundaries.</details></think>

---

<tool-use data-tool-type="grep" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "Application" in "/Users/sahilmehta/supplier-onboarding-simple" • 19 matches</summary>

Output mode: files_with_matches


| File |
|------|
| `./docs/agent-stream-5-state-draft.md` |
| `./docs/implementation-stream-1-routes-auth.md` |
| `./docs/dynamic-form-rendering-prd.md` |
| `./README.md` |
| `./components/navigation/app-sidebar.tsx` |
| `./prisma/migrations/20251117125500_sync_schema_core_tables/migration.sql` |
| `./components/procurement/action-panel.tsx` |
| `./app/dashboard/procurement/[id]/page.tsx` |
| `./prisma/schema.prisma` |
| `./app/dashboard/procurement/[id]/actions.ts` |
| `./docs/phase-2-supplier-experience.md` |
| `./components/supplier/submission-bar.tsx` |
| `./app/supplier/onboarding/actions.ts` |
| `./app/supplier/page.tsx` |
| `./app/api/documents/route.ts` |
| `./app/api/documents/sign/route.ts` |
| `./docs/data-model.md` |
| `./docs/prd.txt` |
| `./app/dashboard/page.tsx` |


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Checking database interactions in onboarding actions**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/sahilmehta/supplier-onboarding-simple/app/supplier/onboarding/actions.ts</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Searching for FormWizard usage and hooking lib/prisma**</details></think>

---

<tool-use data-tool-type="grep" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "FormWizardClient" in "/Users/sahilmehta/supplier-onboarding-simple" • 11 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `./docs/agent-orchestrator.md` | `- ✅ FormWizardClient wrapper for server/client boundary` | L238 |
| `./docs/agent-orchestrator.md` | `5. ✅ Created `FormWizardClient` wrapper component to handle server/client component boundary` | L268 |
| `./docs/streams-1-4-verification-report.md` | `- ✅ Routes pass form config to `FormWizardClient`` | L34 |
| `./docs/streams-1-4-verification-report.md` | `- ✅ FormWizardClient wrapper handles server/client boundary` | L100 |
| `./docs/streams-1-4-verification-report.md` | `- Routes fetch form config and pass to FormWizardClient` | L145 |
| `./app/forms/[formConfigId]/page.tsx` | `import \{ FormWizardClient \} from "@/components/forms/form-wizard-client";` | L5 |
| `./app/forms/[formConfigId]/page.tsx` | `<FormWizardClient formConfig=\{formConfig\} />` | L49 |
| `./components/forms/form-wizard-client.tsx` | `interface FormWizardClientProps \{` | L6 |
| `./components/forms/form-wizard-client.tsx` | `export function FormWizardClient(\{ formConfig \}: FormWizardClientProps) \{` | L14 |
| `./app/forms/[entityCode]/[geographyCode]/page.tsx` | `import \{ FormWizardClient \} from "@/components/forms/form-wizard-client";` | L5 |
| `./app/forms/[entityCode]/[geographyCode]/page.tsx` | `<FormWizardClient formConfig=\{formConfig\} />` | L48 |


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Planning data fetching and relationships**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/sahilmehta/supplier-onboarding-simple/lib/auth.ts</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Investigating organization context and draft data**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/sahilmehta/supplier-onboarding-simple/lib/organizations.ts</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Searching for usage of ensureUserMembership**</details></think>

---

<tool-use data-tool-type="grep" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "ensureUserMembership" in "/Users/sahilmehta/supplier-onboarding-simple" • 12 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `./app/dashboard/users/page.tsx` | `import \{ ensureUserMembership \} from "@/lib/organizations";` | L5 |
| `./app/dashboard/users/page.tsx` | `await ensureUserMembership(\{` | L38 |
| `./README.md` | `- First-time sign-ins that lack memberships are assigned a personal organization via `ensureUserMembership`` | L104 |
| `./docs/auth-rbac.md` | `- **Auto-Provisioning:** `ensureUserMembership` assigns first-login users as `ADMIN` for their workspace.` | L35 |
| `./tests/organizations.test.ts` | `import \{ ensureUserMembership \} from "@/lib/organizations";` | L2 |
| `./tests/organizations.test.ts` | `describe("ensureUserMembership", () => \{` | L31 |
| `./tests/organizations.test.ts` | `const result = await ensureUserMembership(\{` | L40 |
| `./tests/organizations.test.ts` | `const result = await ensureUserMembership(\{` | L58 |
| `./docs/phase-2-supplier-experience.md` | `- Auto-provision supplier organization on first login (reuse ensureUserMembership).` | L12 |
| `./app/dashboard/layout.tsx` | `import \{ ensureUserMembership \} from "@/lib/organizations";` | L9 |
| `./app/dashboard/layout.tsx` | `await ensureUserMembership(\{` | L33 |
| `./lib/organizations.ts` | `export async function ensureUserMembership(options: \{` | L31 |


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Investigating organization and entity ID retrieval**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/sahilmehta/supplier-onboarding-simple/lib/forms/form-config-fetcher.ts</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Assessing type requirements and data sources**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/sahilmehta/supplier-onboarding-simple/app/supplier/page.tsx</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Inspecting save patterns in submission-bar.tsx**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/sahilmehta/supplier-onboarding-simple/components/supplier/submission-bar.tsx</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Planning form draft autosave features**

I’m outlining a detailed plan for implementing form state management with autosave, debounced saving, server-action draft persistence, and UI components for saving and resuming drafts. I’m also considering how to integrate this with the existing form wizard and user organization context to associate drafts properly. There’s a lot to unpack, so breaking it down step-by-step feels necessary.</details></think>

---

<tool-use data-tool-type="grep" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "organizationId: firstOrganizationId" in "/Users/sahilmehta/supplier-onboarding-simple" • 0 matches</summary>

Output mode: content


_No matches found_

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Searching for membership retrieval pattern**</details></think>

---

<tool-use data-tool-type="grep" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "memberships" in "/Users/sahilmehta/supplier-onboarding-simple" • 30 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `./app/dashboard/users/page.tsx` | `memberships: \{` | L26 |
| `./app/dashboard/users/page.tsx` | `if (user.memberships.length === 0) \{` | L37 |
| `./app/dashboard/users/page.tsx` | `memberships: \{` | L47 |
| `./app/dashboard/users/page.tsx` | `if (!user \|\| user.memberships.length === 0) \{` | L55 |
| `./app/dashboard/users/page.tsx` | `const activeMembership = user.memberships[0];` | L59 |
| `./app/dashboard/users/page.tsx` | `const memberships = await prisma.membership.findMany(\{` | L64 |
| `./app/dashboard/users/page.tsx` | `const users = memberships.map((membership) => (\{` | L84 |
| `./README.md` | `- First-time sign-ins that lack memberships are assigned a personal organization via `ensureUserMembership`` | L104 |
| `./docs/foundation-architecture.md` | `- Current schema: users, accounts, sessions, organizations, memberships, documents (future), etc.` | L28 |
| `./docs/auth-rbac.md` | `- **API Routes:** All `/api/users/*` routes call `auth()` + `requireAdmin` before mutating memberships.` | L34 |
| `./tests/permissions.test.ts` | `memberships: [` | L29 |
| `./tests/permissions.test.ts` | `memberships: [` | L50 |
| `./prisma/schema.prisma` | `memberships    Membership[]` | L27 |
| `./lib/auth.ts` | `const memberships = await prisma.membership.findMany(\{` | L51 |
| `./lib/auth.ts` | `token.organizationRoles = memberships.map((membership) => (\{` | L59 |
| `./lib/auth.ts` | `const memberships = await prisma.membership.findMany(\{` | L102 |
| `./lib/auth.ts` | `session.user.organizationRoles = memberships.map((membership) => (\{` | L110 |
| `./lib/permissions.ts` | `memberships: \{` | L13 |
| `./lib/permissions.ts` | `return user.memberships.find((m) => m.organizationId === organizationId);` | L30 |
| `./lib/permissions.ts` | `return user.memberships[0] ?? null;` | L33 |
| `./app/dashboard/layout.tsx` | `memberships: \{` | L25 |
| `./app/dashboard/layout.tsx` | `if (user && user.memberships.length === 0) \{` | L32 |
| `./app/dashboard/layout.tsx` | `memberships: \{` | L42 |
| `./app/dashboard/layout.tsx` | `const activeOrganization = user?.memberships[0]?.organization;` | L50 |
| `./docs/phase-1-core-data-auth.md` | `- Relationships: memberships map users to organizations + roles, applications reference org/entity/geo.` | L11 |
| `./app/api/users/invite/route.ts` | `memberships: \{` | L54 |
| `./app/api/users/invite/route.ts` | `if (existingUser.memberships.length > 0) \{` | L62 |
| `./app/api/users/invite/route.ts` | `memberships: \{` | L90 |
| `./app/api/users/route.ts` | `const memberships = await prisma.membership.findMany(\{` | L21 |
| `./app/api/users/route.ts` | `const users = memberships.map((m) => (\{` | L41 |


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Inspecting membership helpers in permissions.ts**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/sahilmehta/supplier-onboarding-simple/lib/permissions.ts</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Exploring draft-related logic and FormWizardClient props**</details></think>

---

<tool-use data-tool-type="grep" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "draft" in "/Users/sahilmehta/supplier-onboarding-simple/docs/dynamic-form-rendering-prd.md" • 10 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `docs/dynamic-form-rendering-prd.md` | `- Maintain form state and draft data across sessions` | L40 |
| `docs/dynamic-form-rendering-prd.md` | `- Show "Resume" vs "Start New" option if multiple drafts exist` | L353 |
| `docs/dynamic-form-rendering-prd.md` | `draft-save-indicator.tsx         # "Draft saved" feedback` | L648 |
| `docs/dynamic-form-rendering-prd.md` | `draft-manager.ts                # Draft save/load logic` | L657 |
| `docs/dynamic-form-rendering-prd.md` | `- LocalStorage: Temporary draft backup (optional)` | L711 |
| `docs/dynamic-form-rendering-prd.md` | `- Database: Primary draft storage in `Application.data`` | L712 |
| `docs/dynamic-form-rendering-prd.md` | `2. Build draft save server action` | L832 |
| `docs/dynamic-form-rendering-prd.md` | `3. Implement draft load on form mount` | L833 |
| `docs/dynamic-form-rendering-prd.md` | `5. Handle resume flow (existing drafts)` | L835 |
| `docs/dynamic-form-rendering-prd.md` | `- Multiple drafts per user supported` | L926 |


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Reviewing code around line 350**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/sahilmehta/supplier-onboarding-simple/docs/dynamic-form-rendering-prd.md</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Planning implementation and testing strategy**

I’m considering how to implement a general solution while keeping each refactor step testable as the user prefers. I’ll focus on adding tests for key new functionality and important libraries like form-state and draft-manager, and confirm the existing test setup—likely using vitest—to ensure smooth validation for each stage.</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/sahilmehta/supplier-onboarding-simple/package.json</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Confirming test file location**</details></think>

---

<tool-use data-tool-type="generic" data-tool-name="list_dir">
<details>
            <summary>Tool use: **list_directory** • Listed directory undefined • **0** results</summary>
        
No results found
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Checking test imports**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/sahilmehta/supplier-onboarding-simple/supplier_capabilities/tests/auth-session.test.ts</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Outlining form state and hook implementation**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/sahilmehta/supplier-onboarding-simple/components/forms/form-step.tsx</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Designing form state and autosave integration**

This detailed plan covers converting the touched set to a record for form state, implementing a debounced autosave hook with step-aware saves and beforeunload warnings, and designing server-side draft management that encodes current step metadata inside the saved form data. I’m outlining how client and server hooks cooperate to track dirty state, handle saving drafts via Prisma, and support resuming drafts with necessary user and organization validation. There is a lot here about balancing server actions, state updates, and managing draft lifecycle consistently!
**Outlining client components and server action coordination**

I’m mapping out how `FormWizardClient` manages draft state, integrates with autosave and server actions, and handles draft selection via dialogs. The focus is on syncing `applicationId` across components, updating draft lists after saves, and clean rerendering of `DynamicFormWizard` upon draft changes. I’m also considering how to implement server actions for loading and saving drafts with membership checks, plus designing `useAutosave` to handle debounced saves, statuses, and beforeunload warnings. This plan connects UI, hooks, and server logic for a smooth draft resume and autosave experience!</details></think>

---

<tool-use data-tool-type="generic" data-tool-name="list_dir">
<details>
            <summary>Tool use: **list_directory** • Listed directory undefined • **0** results</summary>
        
No results found
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Planning draft resume and form wizard integration**

There's a lot going on here to build out the `DraftResumeDialog` with draft listing, selection, deletion via a new server action, and state handling in `FormWizardClient`. I’m sketching out prop types, UI behavior, server interactions, and how to coordinate draft loading and saving between components. Also considering how to update `DynamicFormWizard` with a new `useFormState` hook to manage form data, validation, and autosave cleanly while preserving existing functionality. Let’s explore how to piece these parts together smoothly!</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/sahilmehta/supplier-onboarding-simple/lib/forms/form-validator.ts</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Checking inconsistent type import paths**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/sahilmehta/supplier-onboarding-simple/lib/form-schema.ts</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Unifying and extending form config types**</details></think>

---

<tool-use data-tool-type="generic" data-tool-name="todo_write">
<details><summary>Tool use: **todo_write** • Todo List</summary>

- [x] Review Stream 5 requirements and inspect current form wizard/state logic
- [-] Implement shared form state + draft persistence libs/hooks
- [ ] Integrate autosave and draft UI into form components/routes
- [ ] Add server actions + route draft loading, update docs status

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Preparing to update form types**</details></think>

---

<tool-use data-tool-type="grep" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "FormConfigWithFields" in "/Users/sahilmehta/supplier-onboarding-simple" • 10 matches</summary>

Output mode: files_with_matches


| File |
|------|
| `./docs/agent-orchestrator.md` |
| `./components/forms/dynamic-form-wizard.tsx` |
| `./components/forms/form-wizard-client.tsx` |
| `./tests/form-validation.test.ts` |
| `./lib/forms/form-validator.ts` |
| `./lib/form-schema.ts` |
| `./lib/forms/form-config-fetcher.ts` |
| `./lib/forms/types.ts` |
| `./docs/implementation-stream-1-routes-auth.md` |
| `./docs/dynamic-form-rendering-prd.md` |


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Preparing type updates in form-schema and types files**</details></think>

---

<tool-use data-tool-type="grep" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "FormWizardState" in "/Users/sahilmehta/supplier-onboarding-simple" • 2 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `./lib/forms/types.ts` | `export interface FormWizardState \{` | L51 |
| `./docs/dynamic-form-rendering-prd.md` | `interface FormWizardState \{` | L256 |


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Extending FormConfigWithFields type**</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  &quot;relativeWorkspacePath&quot;: &quot;/Users/sahilmehta/supplier-onboarding-simple/lib/forms/types.ts&quot;
}
```
Additional data:

```json
{
  &quot;codeblockId&quot;: &quot;811884b1-5ad9-46c9-bae2-bc600c9fc2a7&quot;,
  &quot;reviewData&quot;: {
    &quot;status&quot;: &quot;None&quot;,
    &quot;selectedOption&quot;: &quot;accept&quot;,
    &quot;isShowingInput&quot;: false,
    &quot;firstTimeReviewMode&quot;: false
  }
}
```
Result:

```json
{
  &quot;diff&quot;: {
    &quot;chunks&quot;: [
      {
        &quot;diffString&quot;: &quot;   */\n  \n- import type { FormConfig, FormField, FormSection } from \&quot;@prisma/client\&quot;;\n+ import type {\n+   DocumentType,\n+   FormConfig,\n+   FormDocumentRequirement,\n+   FormField,\n+   FormSection,\n+   Entity,\n+   Geography,\n+ } from \&quot;@prisma/client\&quot;;\n  \n  /**&quot;,
        &quot;oldStart&quot;: 4,
        &quot;newStart&quot;: 4,
        &quot;oldLines&quot;: 5,
        &quot;newLines&quot;: 13,
        &quot;linesRemoved&quot;: 1,
        &quot;linesAdded&quot;: 9
      },
      {
        &quot;diffString&quot;: &quot;  export type FormConfigWithFields = FormConfig &amp; {\n    sections: (FormSection &amp; { fields: FormField[] })[];\n+   documentRules: (FormDocumentRequirement &amp; { documentType: DocumentType })[];\n+   entity: Entity;\n+   geography: Geography;\n  };\n  &quot;,
        &quot;oldStart&quot;: 11,
        &quot;newStart&quot;: 19,
        &quot;oldLines&quot;: 4,
        &quot;newLines&quot;: 7,
        &quot;linesAdded&quot;: 3
      }
    ],
    &quot;editor&quot;: &quot;EDITOR_AI&quot;
  },
  &quot;shouldAutoFixLints&quot;: true,
  &quot;resultForModel&quot;: &quot;Success. Updated the following files:\nM /Users/sahilmehta/supplier-onboarding-simple/lib/forms/types.ts&quot;,
  &quot;contentsAfterEdit&quot;: &quot;/**\n * Shared type definitions for dynamic form rendering system\n * Used across all implementation streams\n */\n\nimport type {\n  DocumentType,\n  FormConfig,\n  FormDocumentRequirement,\n  FormField,\n  FormSection,\n  Entity,\n  Geography,\n} from \&quot;@prisma/client\&quot;;\n\n/**\n * Form configuration with nested sections and fields\n */\nexport type FormConfigWithFields = FormConfig &amp; {\n  sections: (FormSection &amp; { fields: FormField[] })[];\n  documentRules: (FormDocumentRequirement &amp; { documentType: DocumentType })[];\n  entity: Entity;\n  geography: Geography;\n};\n\n/**\n * Field rendering configuration\n */\nexport interface FieldRenderConfig {\n  key: string;\n  label: string;\n  type: string;\n  placeholder?: string;\n  helpText?: string;\n  required: boolean;\n  options?: { values: string[] };\n  validation?: {\n    min?: number;\n    max?: number;\n    pattern?: string;\n    minLength?: number;\n    maxLength?: number;\n  };\n  visibility?: {\n    dependsOn: string;\n    condition:\n      | \&quot;equals\&quot;\n      | \&quot;notEquals\&quot;\n      | \&quot;contains\&quot;\n      | \&quot;greaterThan\&quot;\n      | \&quot;lessThan\&quot;\n      | \&quot;isEmpty\&quot;\n      | \&quot;isNotEmpty\&quot;;\n    value: unknown;\n  };\n  isSensitive: boolean;\n}\n\n/**\n * Form wizard state\n */\nexport interface FormWizardState {\n  currentStep: number;\n  formData: Record&lt;string, unknown&gt;;\n  errors: Record&lt;string, string&gt;;\n  touched: Record&lt;string, boolean&gt;;\n  completedSteps: Set&lt;number&gt;;\n  isDirty: boolean;\n  isSubmitting: boolean;\n}\n\n/**\n * Visibility rule for conditional fields\n */\nexport interface VisibilityRule {\n  dependsOn: string; // Field key\n  condition:\n    | \&quot;equals\&quot;\n    | \&quot;notEquals\&quot;\n    | \&quot;contains\&quot;\n    | \&quot;greaterThan\&quot;\n    | \&quot;lessThan\&quot;\n    | \&quot;isEmpty\&quot;\n    | \&quot;isNotEmpty\&quot;;\n  value: unknown;\n}\n\n&quot;
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Updating type imports in form-schema.ts**</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  &quot;relativeWorkspacePath&quot;: &quot;/Users/sahilmehta/supplier-onboarding-simple/lib/form-schema.ts&quot;
}
```
Additional data:

```json
{
  &quot;codeblockId&quot;: &quot;23656f07-cf87-4548-b3a5-1249faf55a83&quot;,
  &quot;reviewData&quot;: {
    &quot;status&quot;: &quot;None&quot;,
    &quot;selectedOption&quot;: &quot;accept&quot;,
    &quot;isShowingInput&quot;: false,
    &quot;firstTimeReviewMode&quot;: false
  }
}
```
Result:

```json
{
  &quot;diff&quot;: {
    &quot;chunks&quot;: [
      {
        &quot;diffString&quot;: &quot;  import { z } from \&quot;zod\&quot;;\n- import type { FormConfig, FormField, FormSection } from \&quot;@prisma/client\&quot;;\n- \n- export type FormConfigWithFields = FormConfig &amp; {\n-   sections: (FormSection &amp; { fields: FormField[] })[];\n- };\n+ import type { FormField } from \&quot;@prisma/client\&quot;;\n+ import type { FormConfigWithFields } from \&quot;@/lib/forms/types\&quot;;\n  \n  /**&quot;,
        &quot;oldStart&quot;: 1,
        &quot;newStart&quot;: 1,
        &quot;oldLines&quot;: 8,
        &quot;newLines&quot;: 5,
        &quot;linesRemoved&quot;: 5,
        &quot;linesAdded&quot;: 2
      }
    ],
    &quot;editor&quot;: &quot;EDITOR_AI&quot;
  },
  &quot;shouldAutoFixLints&quot;: true,
  &quot;resultForModel&quot;: &quot;Success. Updated the following files:\nM /Users/sahilmehta/supplier-onboarding-simple/lib/form-schema.ts&quot;,
  &quot;contentsAfterEdit&quot;: &quot;import { z } from \&quot;zod\&quot;;\nimport type { FormField } from \&quot;@prisma/client\&quot;;\nimport type { FormConfigWithFields } from \&quot;@/lib/forms/types\&quot;;\n\n/**\n * Validation rules structure from FormField.validation JSON\n */\ninterface ValidationRules {\n  min?: number;\n  max?: number;\n  pattern?: string;\n  minLength?: number;\n  maxLength?: number;\n  customMessage?: string;\n}\n\nconst selectValues = (options?: unknown) =&gt; {\n  if (!options || typeof options !== \&quot;object\&quot;) return [];\n  if (\&quot;values\&quot; in (options as Record&lt;string, unknown&gt;)) {\n    const values = (options as Record&lt;string, unknown&gt;).values;\n    if (Array.isArray(values)) {\n      return values.filter(\n        (value): value is string =&gt; typeof value === \&quot;string\&quot;\n      );\n    }\n  }\n  return [];\n};\n\n/**\n * Parse validation rules from FormField.validation JSON\n */\nfunction parseValidationRules(field: FormField): ValidationRules | null {\n  if (!field.validation || typeof field.validation !== \&quot;object\&quot;) {\n    return null;\n  }\n  const validation = field.validation as Record&lt;string, unknown&gt;;\n  return {\n    min: typeof validation.min === \&quot;number\&quot; ? validation.min : undefined,\n    max: typeof validation.max === \&quot;number\&quot; ? validation.max : undefined,\n    pattern: typeof validation.pattern === \&quot;string\&quot; ? validation.pattern : undefined,\n    minLength: typeof validation.minLength === \&quot;number\&quot; ? validation.minLength : undefined,\n    maxLength: typeof validation.maxLength === \&quot;number\&quot; ? validation.maxLength : undefined,\n    customMessage: typeof validation.customMessage === \&quot;string\&quot; ? validation.customMessage : undefined,\n  };\n}\n\n/**\n * Apply validation rules to a Zod schema based on field type\n */\nfunction applyValidationRules(\n  schema: z.ZodTypeAny,\n  field: FormField,\n  rules: ValidationRules\n): z.ZodTypeAny {\n  let validatedSchema = schema;\n\n  // Apply type-specific validations\n  if (field.type === \&quot;number\&quot;) {\n    if (rules.min !== undefined) {\n      validatedSchema = (validatedSchema as z.ZodNumber).min(\n        rules.min,\n        rules.customMessage || &#96;${field.label} must be at least ${rules.min}&#96;\n      );\n    }\n    if (rules.max !== undefined) {\n      validatedSchema = (validatedSchema as z.ZodNumber).max(\n        rules.max,\n        rules.customMessage || &#96;${field.label} must be at most ${rules.max}&#96;\n      );\n    }\n  } else if (field.type === \&quot;text\&quot; || field.type === \&quot;email\&quot; || field.type === \&quot;tel\&quot; || field.type === \&quot;textarea\&quot;) {\n    // String validations\n    if (rules.minLength !== undefined) {\n      validatedSchema = (validatedSchema as z.ZodString).min(\n        rules.minLength,\n        rules.customMessage || &#96;${field.label} must be at least ${rules.minLength} characters&#96;\n      );\n    }\n    if (rules.maxLength !== undefined) {\n      validatedSchema = (validatedSchema as z.ZodString).max(\n        rules.maxLength,\n        rules.customMessage || &#96;${field.label} must be at most ${rules.maxLength} characters&#96;\n      );\n    }\n    if (rules.pattern) {\n      try {\n        const regex = new RegExp(rules.pattern);\n        validatedSchema = (validatedSchema as z.ZodString).regex(\n          regex,\n          rules.customMessage || &#96;${field.label} format is invalid&#96;\n        );\n      } catch (error) {\n        // Invalid regex pattern, skip pattern validation\n        console.warn(&#96;Invalid regex pattern for field ${field.key}: ${rules.pattern}&#96;);\n      }\n    }\n  }\n\n  return validatedSchema;\n}\n\nfunction fieldToSchema(field: FormField) {\n  let schema: z.ZodTypeAny;\n\n  switch (field.type) {\n    case \&quot;number\&quot;:\n      schema = z.number();\n      break;\n    case \&quot;select\&quot;:\n      const values = selectValues(field.options ?? undefined);\n      schema = values.length &gt; 0 ? z.enum(values as [string, ...string[]]) : z.string();\n      break;\n    case \&quot;boolean\&quot;:\n      schema = z.boolean();\n      break;\n    case \&quot;date\&quot;:\n      schema = z.string().refine((value) =&gt; !isNaN(Date.parse(value)), {\n        message: \&quot;Invalid date\&quot;,\n      });\n      break;\n    case \&quot;email\&quot;:\n      schema = z.string().email(&#96;${field.label} must be a valid email address&#96;);\n      break;\n    default:\n      schema = z.string();\n  }\n\n  // Apply custom validation rules\n  const validationRules = parseValidationRules(field);\n  if (validationRules) {\n    schema = applyValidationRules(schema, field, validationRules);\n  }\n\n  // Handle required/optional\n  if (field.required) {\n    return schema;\n  }\n  return schema.optional();\n}\n\nexport function buildFormSchema(config: FormConfigWithFields) {\n  const fields: Record&lt;string, z.ZodTypeAny&gt; = {};\n\n  config.sections.forEach((section) =&gt; {\n    section.fields.forEach((field) =&gt; {\n      fields[field.key] = fieldToSchema(field).describe(field.label);\n    });\n  });\n\n  return z.object(fields);\n}\n\nexport function describeFormSchema(config: FormConfigWithFields) {\n  return config.sections.flatMap((section) =&gt;\n    section.fields.map((field) =&gt; ({\n      section: section.label,\n      key: field.key,\n      label: field.label,\n      type: field.type,\n      required: field.required,\n    }))\n  );\n}\n\n&quot;
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Checking for FormSection usage**</details></think>

---

<tool-use data-tool-type="grep" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "FormSection" in "/Users/sahilmehta/supplier-onboarding-simple/lib/form-schema.ts" • 0 matches</summary>

Output mode: content


_No matches found_

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Ensuring type re-export for FormConfigWithFields**</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  &quot;relativeWorkspacePath&quot;: &quot;/Users/sahilmehta/supplier-onboarding-simple/lib/form-schema.ts&quot;
}
```
Additional data:

```json
{
  &quot;codeblockId&quot;: &quot;732b2119-b0b5-4eab-baac-0c7b44084c2c&quot;,
  &quot;reviewData&quot;: {
    &quot;status&quot;: &quot;None&quot;,
    &quot;selectedOption&quot;: &quot;accept&quot;,
    &quot;isShowingInput&quot;: false,
    &quot;firstTimeReviewMode&quot;: false
  }
}
```
Result:

```json
{
  &quot;diff&quot;: {
    &quot;chunks&quot;: [
      {
        &quot;diffString&quot;: &quot;  import type { FormField } from \&quot;@prisma/client\&quot;;\n  import type { FormConfigWithFields } from \&quot;@/lib/forms/types\&quot;;\n+ export type { FormConfigWithFields } from \&quot;@/lib/forms/types\&quot;;\n  \n  /**&quot;,
        &quot;oldStart&quot;: 2,
        &quot;newStart&quot;: 2,
        &quot;oldLines&quot;: 4,
        &quot;newLines&quot;: 5,
        &quot;linesAdded&quot;: 1
      }
    ],
    &quot;editor&quot;: &quot;EDITOR_AI&quot;
  },
  &quot;shouldAutoFixLints&quot;: true,
  &quot;resultForModel&quot;: &quot;Success. Updated the following files:\nM /Users/sahilmehta/supplier-onboarding-simple/lib/form-schema.ts&quot;,
  &quot;contentsAfterEdit&quot;: &quot;import { z } from \&quot;zod\&quot;;\nimport type { FormField } from \&quot;@prisma/client\&quot;;\nimport type { FormConfigWithFields } from \&quot;@/lib/forms/types\&quot;;\nexport type { FormConfigWithFields } from \&quot;@/lib/forms/types\&quot;;\n\n/**\n * Validation rules structure from FormField.validation JSON\n */\ninterface ValidationRules {\n  min?: number;\n  max?: number;\n  pattern?: string;\n  minLength?: number;\n  maxLength?: number;\n  customMessage?: string;\n}\n\nconst selectValues = (options?: unknown) =&gt; {\n  if (!options || typeof options !== \&quot;object\&quot;) return [];\n  if (\&quot;values\&quot; in (options as Record&lt;string, unknown&gt;)) {\n    const values = (options as Record&lt;string, unknown&gt;).values;\n    if (Array.isArray(values)) {\n      return values.filter(\n        (value): value is string =&gt; typeof value === \&quot;string\&quot;\n      );\n    }\n  }\n  return [];\n};\n\n/**\n * Parse validation rules from FormField.validation JSON\n */\nfunction parseValidationRules(field: FormField): ValidationRules | null {\n  if (!field.validation || typeof field.validation !== \&quot;object\&quot;) {\n    return null;\n  }\n  const validation = field.validation as Record&lt;string, unknown&gt;;\n  return {\n    min: typeof validation.min === \&quot;number\&quot; ? validation.min : undefined,\n    max: typeof validation.max === \&quot;number\&quot; ? validation.max : undefined,\n    pattern: typeof validation.pattern === \&quot;string\&quot; ? validation.pattern : undefined,\n    minLength: typeof validation.minLength === \&quot;number\&quot; ? validation.minLength : undefined,\n    maxLength: typeof validation.maxLength === \&quot;number\&quot; ? validation.maxLength : undefined,\n    customMessage: typeof validation.customMessage === \&quot;string\&quot; ? validation.customMessage : undefined,\n  };\n}\n\n/**\n * Apply validation rules to a Zod schema based on field type\n */\nfunction applyValidationRules(\n  schema: z.ZodTypeAny,\n  field: FormField,\n  rules: ValidationRules\n): z.ZodTypeAny {\n  let validatedSchema = schema;\n\n  // Apply type-specific validations\n  if (field.type === \&quot;number\&quot;) {\n    if (rules.min !== undefined) {\n      validatedSchema = (validatedSchema as z.ZodNumber).min(\n        rules.min,\n        rules.customMessage || &#96;${field.label} must be at least ${rules.min}&#96;\n      );\n    }\n    if (rules.max !== undefined) {\n      validatedSchema = (validatedSchema as z.ZodNumber).max(\n        rules.max,\n        rules.customMessage || &#96;${field.label} must be at most ${rules.max}&#96;\n      );\n    }\n  } else if (field.type === \&quot;text\&quot; || field.type === \&quot;email\&quot; || field.type === \&quot;tel\&quot; || field.type === \&quot;textarea\&quot;) {\n    // String validations\n    if (rules.minLength !== undefined) {\n      validatedSchema = (validatedSchema as z.ZodString).min(\n        rules.minLength,\n        rules.customMessage || &#96;${field.label} must be at least ${rules.minLength} characters&#96;\n      );\n    }\n    if (rules.maxLength !== undefined) {\n      validatedSchema = (validatedSchema as z.ZodString).max(\n        rules.maxLength,\n        rules.customMessage || &#96;${field.label} must be at most ${rules.maxLength} characters&#96;\n      );\n    }\n    if (rules.pattern) {\n      try {\n        const regex = new RegExp(rules.pattern);\n        validatedSchema = (validatedSchema as z.ZodString).regex(\n          regex,\n          rules.customMessage || &#96;${field.label} format is invalid&#96;\n        );\n      } catch (error) {\n        // Invalid regex pattern, skip pattern validation\n        console.warn(&#96;Invalid regex pattern for field ${field.key}: ${rules.pattern}&#96;);\n      }\n    }\n  }\n\n  return validatedSchema;\n}\n\nfunction fieldToSchema(field: FormField) {\n  let schema: z.ZodTypeAny;\n\n  switch (field.type) {\n    case \&quot;number\&quot;:\n      schema = z.number();\n      break;\n    case \&quot;select\&quot;:\n      const values = selectValues(field.options ?? undefined);\n      schema = values.length &gt; 0 ? z.enum(values as [string, ...string[]]) : z.string();\n      break;\n    case \&quot;boolean\&quot;:\n      schema = z.boolean();\n      break;\n    case \&quot;date\&quot;:\n      schema = z.string().refine((value) =&gt; !isNaN(Date.parse(value)), {\n        message: \&quot;Invalid date\&quot;,\n      });\n      break;\n    case \&quot;email\&quot;:\n      schema = z.string().email(&#96;${field.label} must be a valid email address&#96;);\n      break;\n    default:\n      schema = z.string();\n  }\n\n  // Apply custom validation rules\n  const validationRules = parseValidationRules(field);\n  if (validationRules) {\n    schema = applyValidationRules(schema, field, validationRules);\n  }\n\n  // Handle required/optional\n  if (field.required) {\n    return schema;\n  }\n  return schema.optional();\n}\n\nexport function buildFormSchema(config: FormConfigWithFields) {\n  const fields: Record&lt;string, z.ZodTypeAny&gt; = {};\n\n  config.sections.forEach((section) =&gt; {\n    section.fields.forEach((field) =&gt; {\n      fields[field.key] = fieldToSchema(field).describe(field.label);\n    });\n  });\n\n  return z.object(fields);\n}\n\nexport function describeFormSchema(config: FormConfigWithFields) {\n  return config.sections.flatMap((section) =&gt;\n    section.fields.map((field) =&gt; ({\n      section: section.label,\n      key: field.key,\n      label: field.label,\n      type: field.type,\n      required: field.required,\n    }))\n  );\n}\n\n&quot;
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Designing form state module**</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  &quot;relativeWorkspacePath&quot;: &quot;/Users/sahilmehta/supplier-onboarding-simple/lib/forms/form-state.ts&quot;
}
```
Additional data:

```json
{
  &quot;codeblockId&quot;: &quot;e5dd6652-4729-4a4a-bea0-be66fe1ff085&quot;,
  &quot;reviewData&quot;: {
    &quot;status&quot;: &quot;None&quot;,
    &quot;selectedOption&quot;: &quot;accept&quot;,
    &quot;isShowingInput&quot;: false,
    &quot;firstTimeReviewMode&quot;: false
  }
}
```
Result:

```json
{
  &quot;diff&quot;: {
    &quot;chunks&quot;: [
      {
        &quot;diffString&quot;: &quot;- \n+ export interface FormState {\n+   formData: Record&lt;string, unknown&gt;;\n+   touched: Set&lt;string&gt;;\n+   errors: Record&lt;string, string&gt;;\n+   currentStep: number;\n+   completedSteps: Set&lt;number&gt;;\n+   isDirty: boolean;\n+   isSubmitting: boolean;\n+ }\n+ \n+ export interface SerializedFormState {\n+   formData: Record&lt;string, unknown&gt;;\n+   touched: string[];\n+   errors: Record&lt;string, string&gt;;\n+   currentStep: number;\n+   completedSteps: number[];\n+   isDirty: boolean;\n+   isSubmitting: boolean;\n+ }\n+ \n+ export function createInitialFormState(\n+   initialData: Record&lt;string, unknown&gt; = {},\n+   initialStep = 0\n+ ): FormState {\n+   return {\n+     formData: initialData,\n+     touched: new Set(),\n+     errors: {},\n+     currentStep: initialStep,\n+     completedSteps:\n+       initialStep &gt; 0\n+         ? new Set(Array.from({ length: initialStep }, (_, index) =&gt; index))\n+         : new Set(),\n+     isDirty: Object.keys(initialData).length &gt; 0,\n+     isSubmitting: false,\n+   };\n+ }\n+ \n+ export function serializeFormState(state: FormState): SerializedFormState {\n+   return {\n+     formData: state.formData,\n+     errors: state.errors,\n+     currentStep: state.currentStep,\n+     isDirty: state.isDirty,\n+     isSubmitting: state.isSubmitting,\n+     touched: Array.from(state.touched),\n+     completedSteps: Array.from(state.completedSteps),\n+   };\n+ }\n+ \n+ export function hydrateFormState(\n+   snapshot: Partial&lt;SerializedFormState&gt;\n+ ): FormState {\n+   return {\n+     formData: snapshot.formData ?? {},\n+     errors: snapshot.errors ?? {},\n+     currentStep: snapshot.currentStep ?? 0,\n+     isDirty: snapshot.isDirty ?? false,\n+     isSubmitting: snapshot.isSubmitting ?? false,\n+     touched: new Set(snapshot.touched ?? []),\n+     completedSteps: new Set(snapshot.completedSteps ?? []),\n+   };\n+ }\n+ &quot;,
        &quot;oldStart&quot;: 1,
        &quot;newStart&quot;: 1,
        &quot;oldLines&quot;: 1,
        &quot;newLines&quot;: 64,
        &quot;linesRemoved&quot;: 1,
        &quot;linesAdded&quot;: 64
      }
    ],
    &quot;editor&quot;: &quot;EDITOR_AI&quot;
  },
  &quot;shouldAutoFixLints&quot;: true,
  &quot;resultForModel&quot;: &quot;Success. Updated the following files:\nM /Users/sahilmehta/supplier-onboarding-simple/lib/forms/form-state.ts&quot;,
  &quot;contentsAfterEdit&quot;: &quot;export interface FormState {\n  formData: Record&lt;string, unknown&gt;;\n  touched: Set&lt;string&gt;;\n  errors: Record&lt;string, string&gt;;\n  currentStep: number;\n  completedSteps: Set&lt;number&gt;;\n  isDirty: boolean;\n  isSubmitting: boolean;\n}\n\nexport interface SerializedFormState {\n  formData: Record&lt;string, unknown&gt;;\n  touched: string[];\n  errors: Record&lt;string, string&gt;;\n  currentStep: number;\n  completedSteps: number[];\n  isDirty: boolean;\n  isSubmitting: boolean;\n}\n\nexport function createInitialFormState(\n  initialData: Record&lt;string, unknown&gt; = {},\n  initialStep = 0\n): FormState {\n  return {\n    formData: initialData,\n    touched: new Set(),\n    errors: {},\n    currentStep: initialStep,\n    completedSteps:\n      initialStep &gt; 0\n        ? new Set(Array.from({ length: initialStep }, (_, index) =&gt; index))\n        : new Set(),\n    isDirty: Object.keys(initialData).length &gt; 0,\n    isSubmitting: false,\n  };\n}\n\nexport function serializeFormState(state: FormState): SerializedFormState {\n  return {\n    formData: state.formData,\n    errors: state.errors,\n    currentStep: state.currentStep,\n    isDirty: state.isDirty,\n    isSubmitting: state.isSubmitting,\n    touched: Array.from(state.touched),\n    completedSteps: Array.from(state.completedSteps),\n  };\n}\n\nexport function hydrateFormState(\n  snapshot: Partial&lt;SerializedFormState&gt;\n): FormState {\n  return {\n    formData: snapshot.formData ?? {},\n    errors: snapshot.errors ?? {},\n    currentStep: snapshot.currentStep ?? 0,\n    isDirty: snapshot.isDirty ?? false,\n    isSubmitting: snapshot.isSubmitting ?? false,\n    touched: new Set(snapshot.touched ?? []),\n    completedSteps: new Set(snapshot.completedSteps ?? []),\n  };\n}\n\n&quot;
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Implementing draft-manager.ts with CRUD functions**

I’m outlining the creation of `lib/forms/draft-manager.ts` to handle draft persistence using Prisma. This involves encoding/decoding draft payloads, validating user membership, and implementing save, load, list, and delete operations on draft records while ensuring ownership and proper metadata handling. There’s careful attention to optional fields, error handling, and working around schema limits by storing currentStep inside JSON meta. I’ll define needed interfaces and types as well.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  &quot;relativeWorkspacePath&quot;: &quot;/Users/sahilmehta/supplier-onboarding-simple/lib/forms/draft-manager.ts&quot;
}
```
Additional data:

```json
{
  &quot;codeblockId&quot;: &quot;492e2bcb-e4c8-4fc0-af42-f3eb8632eb0e&quot;,
  &quot;reviewData&quot;: {
    &quot;status&quot;: &quot;None&quot;,
    &quot;selectedOption&quot;: &quot;accept&quot;,
    &quot;isShowingInput&quot;: false,
    &quot;firstTimeReviewMode&quot;: false
  }
}
```
Result:

```json
{
  &quot;diff&quot;: {
    &quot;chunks&quot;: [
      {
        &quot;diffString&quot;: &quot;- \n+ import { prisma } from \&quot;@/lib/prisma\&quot;;\n+ \n+ export const DRAFT_META_KEY = \&quot;__draftMeta\&quot;;\n+ \n+ interface DraftMeta {\n+   currentStep: number;\n+   updatedAt: string;\n+ }\n+ \n+ interface PersistedDraftPayload {\n+   [key: string]: unknown;\n+   [DRAFT_META_KEY]?: DraftMeta;\n+ }\n+ \n+ export interface DraftSummary {\n+   applicationId: string;\n+   updatedAt: string;\n+   currentStep: number;\n+ }\n+ \n+ export interface DraftRecord extends DraftSummary {\n+   formData: Record&lt;string, unknown&gt;;\n+ }\n+ \n+ export interface SaveDraftOptions {\n+   applicationId?: string | null;\n+   formConfigId: string;\n+   organizationId: string;\n+   entityId: string;\n+   geographyId: string;\n+   userId: string;\n+   formData: Record&lt;string, unknown&gt;;\n+   currentStep: number;\n+ }\n+ \n+ export interface LoadDraftOptions {\n+   applicationId: string;\n+   organizationId: string;\n+   userId: string;\n+ }\n+ \n+ export interface DraftQueryOptions {\n+   formConfigId: string;\n+   organizationId: string;\n+   entityId: string;\n+   geographyId: string;\n+   userId: string;\n+ }\n+ \n+ export interface DeleteDraftOptions {\n+   applicationId: string;\n+   organizationId: string;\n+   userId: string;\n+ }\n+ \n+ function encodeDraftPayload(\n+   formData: Record&lt;string, unknown&gt;,\n+   currentStep: number\n+ ): PersistedDraftPayload {\n+   return {\n+     ...formData,\n+     [DRAFT_META_KEY]: {\n+       currentStep,\n+       updatedAt: new Date().toISOString(),\n+     },\n+   };\n+ }\n+ \n+ function decodeDraftPayload(\n+   payload?: PersistedDraftPayload | null\n+ ): DraftRecord {\n+   const clonedPayload = { ...(payload ?? {}) };\n+   const metaRaw = clonedPayload[DRAFT_META_KEY];\n+   delete clonedPayload[DRAFT_META_KEY];\n+ \n+   const meta = (metaRaw as DraftMeta | undefined) ?? {\n+     currentStep: 0,\n+     updatedAt: new Date(0).toISOString(),\n+   };\n+ \n+   return {\n+     formData: clonedPayload,\n+     currentStep: Number.isFinite(meta.currentStep) ? meta.currentStep : 0,\n+     updatedAt: meta.updatedAt ?? new Date().toISOString(),\n+     applicationId: \&quot;\&quot;,\n+   } as DraftRecord;\n+ }\n+ \n+ function attachApplicationId(\n+   record: DraftRecord,\n+   applicationId: string\n+ ): DraftRecord {\n+   return {\n+     ...record,\n+     applicationId,\n+   };\n+ }\n+ \n+ export async function saveDraftRecord(\n+   options: SaveDraftOptions\n+ ): Promise&lt;DraftRecord&gt; {\n+   const payload = encodeDraftPayload(options.formData, options.currentStep);\n+ \n+   if (options.applicationId) {\n+     const existing = await prisma.application.findFirst({\n+       where: {\n+         id: options.applicationId,\n+         organizationId: options.organizationId,\n+         createdById: options.userId,\n+       },\n+       select: { id: true },\n+     });\n+ \n+     if (!existing) {\n+       throw new Error(\&quot;Draft not found or access denied\&quot;);\n+     }\n+ \n+     const updated = await prisma.application.update({\n+       where: { id: options.applicationId },\n+       data: {\n+         data: payload,\n+         formConfigId: options.formConfigId,\n+         entityId: options.entityId,\n+         geographyId: options.geographyId,\n+         updatedById: options.userId,\n+         status: \&quot;DRAFT\&quot;,\n+       },\n+       select: {\n+         id: true,\n+         data: true,\n+         updatedAt: true,\n+       },\n+     });\n+ \n+     const record = decodeDraftPayload(updated.data as PersistedDraftPayload);\n+     record.updatedAt = updated.updatedAt.toISOString();\n+     return attachApplicationId(record, updated.id);\n+   }\n+ \n+   const created = await prisma.application.create({\n+     data: {\n+       organizationId: options.organizationId,\n+       entityId: options.entityId,\n+       geographyId: options.geographyId,\n+       formConfigId: options.formConfigId,\n+       status: \&quot;DRAFT\&quot;,\n+       data: payload,\n+       createdById: options.userId,\n+       updatedById: options.userId,\n+     },\n+     select: {\n+       id: true,\n+       data: true,\n+       updatedAt: true,\n+     },\n+   });\n+ \n+   const record = decodeDraftPayload(created.data as PersistedDraftPayload);\n+   record.updatedAt = created.updatedAt.toISOString();\n+   return attachApplicationId(record, created.id);\n+ }\n+ \n+ export async function loadDraftRecord(\n+   options: LoadDraftOptions\n+ ): Promise&lt;DraftRecord | null&gt; {\n+   const draft = await prisma.application.findFirst({\n+     where: {\n+       id: options.applicationId,\n+       organizationId: options.organizationId,\n+       createdById: options.userId,\n+       status: \&quot;DRAFT\&quot;,\n+     },\n+     select: {\n+       id: true,\n+       data: true,\n+       updatedAt: true,\n+     },\n+   });\n+ \n+   if (!draft) {\n+     return null;\n+   }\n+ \n+   const record = decodeDraftPayload(draft.data as PersistedDraftPayload);\n+   record.updatedAt = draft.updatedAt.toISOString();\n+   return attachApplicationId(record, draft.id);\n+ }\n+ \n+ export async function listDraftSummaries(\n+   options: DraftQueryOptions\n+ ): Promise&lt;DraftSummary[]&gt; {\n+   const drafts = await prisma.application.findMany({\n+     where: {\n+       status: \&quot;DRAFT\&quot;,\n+       organizationId: options.organizationId,\n+       entityId: options.entityId,\n+       geographyId: options.geographyId,\n+       formConfigId: options.formConfigId,\n+       createdById: options.userId,\n+     },\n+     orderBy: {\n+       updatedAt: \&quot;desc\&quot;,\n+     },\n+     select: {\n+       id: true,\n+       data: true,\n+       updatedAt: true,\n+     },\n+   });\n+ \n+   return drafts.map((draft) =&gt; {\n+     const record = decodeDraftPayload(draft.data as PersistedDraftPayload);\n+     return {\n+       applicationId: draft.id,\n+       currentStep: record.currentStep,\n+       updatedAt: draft.updatedAt.toISOString(),\n+     };\n+   });\n+ }\n+ \n+ export async function deleteDraftRecord(\n+   options: DeleteDraftOptions\n+ ): Promise&lt;void&gt; {\n+   await prisma.application.deleteMany({\n+     where: {\n+       id: options.applicationId,\n+       organizationId: options.organizationId,\n+       createdById: options.userId,\n+       status: \&quot;DRAFT\&quot;,\n+     },\n+   });\n+ }\n+ &quot;,
        &quot;oldStart&quot;: 1,
        &quot;newStart&quot;: 1,
        &quot;oldLines&quot;: 1,
        &quot;newLines&quot;: 233,
        &quot;linesRemoved&quot;: 1,
        &quot;linesAdded&quot;: 233
      }
    ],
    &quot;editor&quot;: &quot;EDITOR_AI&quot;
  },
  &quot;shouldAutoFixLints&quot;: true,
  &quot;resultForModel&quot;: &quot;Success. Updated the following files:\nM /Users/sahilmehta/supplier-onboarding-simple/lib/forms/draft-manager.ts&quot;,
  &quot;contentsAfterEdit&quot;: &quot;import { prisma } from \&quot;@/lib/prisma\&quot;;\n\nexport const DRAFT_META_KEY = \&quot;__draftMeta\&quot;;\n\ninterface DraftMeta {\n  currentStep: number;\n  updatedAt: string;\n}\n\ninterface PersistedDraftPayload {\n  [key: string]: unknown;\n  [DRAFT_META_KEY]?: DraftMeta;\n}\n\nexport interface DraftSummary {\n  applicationId: string;\n  updatedAt: string;\n  currentStep: number;\n}\n\nexport interface DraftRecord extends DraftSummary {\n  formData: Record&lt;string, unknown&gt;;\n}\n\nexport interface SaveDraftOptions {\n  applicationId?: string | null;\n  formConfigId: string;\n  organizationId: string;\n  entityId: string;\n  geographyId: string;\n  userId: string;\n  formData: Record&lt;string, unknown&gt;;\n  currentStep: number;\n}\n\nexport interface LoadDraftOptions {\n  applicationId: string;\n  organizationId: string;\n  userId: string;\n}\n\nexport interface DraftQueryOptions {\n  formConfigId: string;\n  organizationId: string;\n  entityId: string;\n  geographyId: string;\n  userId: string;\n}\n\nexport interface DeleteDraftOptions {\n  applicationId: string;\n  organizationId: string;\n  userId: string;\n}\n\nfunction encodeDraftPayload(\n  formData: Record&lt;string, unknown&gt;,\n  currentStep: number\n): PersistedDraftPayload {\n  return {\n    ...formData,\n    [DRAFT_META_KEY]: {\n      currentStep,\n      updatedAt: new Date().toISOString(),\n    },\n  };\n}\n\nfunction decodeDraftPayload(\n  payload?: PersistedDraftPayload | null\n): DraftRecord {\n  const clonedPayload = { ...(payload ?? {}) };\n  const metaRaw = clonedPayload[DRAFT_META_KEY];\n  delete clonedPayload[DRAFT_META_KEY];\n\n  const meta = (metaRaw as DraftMeta | undefined) ?? {\n    currentStep: 0,\n    updatedAt: new Date(0).toISOString(),\n  };\n\n  return {\n    formData: clonedPayload,\n    currentStep: Number.isFinite(meta.currentStep) ? meta.currentStep : 0,\n    updatedAt: meta.updatedAt ?? new Date().toISOString(),\n    applicationId: \&quot;\&quot;,\n  } as DraftRecord;\n}\n\nfunction attachApplicationId(\n  record: DraftRecord,\n  applicationId: string\n): DraftRecord {\n  return {\n    ...record,\n    applicationId,\n  };\n}\n\nexport async function saveDraftRecord(\n  options: SaveDraftOptions\n): Promise&lt;DraftRecord&gt; {\n  const payload = encodeDraftPayload(options.formData, options.currentStep);\n\n  if (options.applicationId) {\n    const existing = await prisma.application.findFirst({\n      where: {\n        id: options.applicationId,\n        organizationId: options.organizationId,\n        createdById: options.userId,\n      },\n      select: { id: true },\n    });\n\n    if (!existing) {\n      throw new Error(\&quot;Draft not found or access denied\&quot;);\n    }\n\n    const updated = await prisma.application.update({\n      where: { id: options.applicationId },\n      data: {\n        data: payload,\n        formConfigId: options.formConfigId,\n        entityId: options.entityId,\n        geographyId: options.geographyId,\n        updatedById: options.userId,\n        status: \&quot;DRAFT\&quot;,\n      },\n      select: {\n        id: true,\n        data: true,\n        updatedAt: true,\n      },\n    });\n\n    const record = decodeDraftPayload(updated.data as PersistedDraftPayload);\n    record.updatedAt = updated.updatedAt.toISOString();\n    return attachApplicationId(record, updated.id);\n  }\n\n  const created = await prisma.application.create({\n    data: {\n      organizationId: options.organizationId,\n      entityId: options.entityId,\n      geographyId: options.geographyId,\n      formConfigId: options.formConfigId,\n      status: \&quot;DRAFT\&quot;,\n      data: payload,\n      createdById: options.userId,\n      updatedById: options.userId,\n    },\n    select: {\n      id: true,\n      data: true,\n      updatedAt: true,\n    },\n  });\n\n  const record = decodeDraftPayload(created.data as PersistedDraftPayload);\n  record.updatedAt = created.updatedAt.toISOString();\n  return attachApplicationId(record, created.id);\n}\n\nexport async function loadDraftRecord(\n  options: LoadDraftOptions\n): Promise&lt;DraftRecord | null&gt; {\n  const draft = await prisma.application.findFirst({\n    where: {\n      id: options.applicationId,\n      organizationId: options.organizationId,\n      createdById: options.userId,\n      status: \&quot;DRAFT\&quot;,\n    },\n    select: {\n      id: true,\n      data: true,\n      updatedAt: true,\n    },\n  });\n\n  if (!draft) {\n    return null;\n  }\n\n  const record = decodeDraftPayload(draft.data as PersistedDraftPayload);\n  record.updatedAt = draft.updatedAt.toISOString();\n  return attachApplicationId(record, draft.id);\n}\n\nexport async function listDraftSummaries(\n  options: DraftQueryOptions\n): Promise&lt;DraftSummary[]&gt; {\n  const drafts = await prisma.application.findMany({\n    where: {\n      status: \&quot;DRAFT\&quot;,\n      organizationId: options.organizationId,\n      entityId: options.entityId,\n      geographyId: options.geographyId,\n      formConfigId: options.formConfigId,\n      createdById: options.userId,\n    },\n    orderBy: {\n      updatedAt: \&quot;desc\&quot;,\n    },\n    select: {\n      id: true,\n      data: true,\n      updatedAt: true,\n    },\n  });\n\n  return drafts.map((draft) =&gt; {\n    const record = decodeDraftPayload(draft.data as PersistedDraftPayload);\n    return {\n      applicationId: draft.id,\n      currentStep: record.currentStep,\n      updatedAt: draft.updatedAt.toISOString(),\n    };\n  });\n}\n\nexport async function deleteDraftRecord(\n  options: DeleteDraftOptions\n): Promise&lt;void&gt; {\n  await prisma.application.deleteMany({\n    where: {\n      id: options.applicationId,\n      organizationId: options.organizationId,\n      createdById: options.userId,\n      status: \&quot;DRAFT\&quot;,\n    },\n  });\n}\n\n&quot;
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Designing form state hook with reducer**

I'm planning a `useFormState` hook to manage multi-step form state with a reducer, handling field values, touched fields, errors, step navigation, and validation. I'll carefully implement actions for setting field values, marking touched, setting errors (with partial updates), step completion, and dirty/submitting flags. The hook will expose functions like `setFieldValue`, `markFieldTouched`, `validateStep`, and navigation helpers while keeping UI concerns like focusing outside the hook. This approach should keep form logic organized and flexible for components using it.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  &quot;relativeWorkspacePath&quot;: &quot;/Users/sahilmehta/supplier-onboarding-simple/hooks/use-form-state.ts&quot;
}
```
Additional data:

```json
{
  &quot;codeblockId&quot;: &quot;3a3bc940-4af4-450d-b12b-55922dd564fb&quot;,
  &quot;reviewData&quot;: {
    &quot;status&quot;: &quot;None&quot;,
    &quot;selectedOption&quot;: &quot;accept&quot;,
    &quot;isShowingInput&quot;: false,
    &quot;firstTimeReviewMode&quot;: false
  }
}
```
Result:

```json
{
  &quot;diff&quot;: {
    &quot;chunks&quot;: [
      {
        &quot;diffString&quot;: &quot;- \n+ \&quot;use client\&quot;;\n+ \n+ import { useCallback, useMemo, useReducer } from \&quot;react\&quot;;\n+ import type { FormConfigWithFields } from \&quot;@/lib/forms/types\&quot;;\n+ import {\n+   createInitialFormState,\n+   type FormState,\n+ } from \&quot;@/lib/forms/form-state\&quot;;\n+ import {\n+   getStepFieldKeys,\n+   validateStep,\n+   type StepValidationResult,\n+ } from \&quot;@/lib/forms/form-validator\&quot;;\n+ \n+ type FormStateAction =\n+   | { type: \&quot;SET_FIELD_VALUE\&quot;; fieldKey: string; value: unknown }\n+   | { type: \&quot;MARK_TOUCHED\&quot;; fieldKey: string }\n+   | { type: \&quot;MARK_TOUCHED_FIELDS\&quot;; fieldKeys: string[] }\n+   | { type: \&quot;SET_STEP_ERRORS\&quot;; fieldKeys: string[]; errors: Record&lt;string, string&gt; }\n+   | { type: \&quot;SET_ERRORS\&quot;; errors: Record&lt;string, string&gt; }\n+   | { type: \&quot;SET_CURRENT_STEP\&quot;; step: number }\n+   | { type: \&quot;MARK_STEP_COMPLETE\&quot;; step: number }\n+   | { type: \&quot;SET_SUBMITTING\&quot;; value: boolean }\n+   | { type: \&quot;SET_DIRTY\&quot;; value: boolean };\n+ \n+ function reducer(state: FormState, action: FormStateAction): FormState {\n+   switch (action.type) {\n+     case \&quot;SET_FIELD_VALUE\&quot;: {\n+       const nextValue = action.value;\n+       const hasChanged = state.formData[action.fieldKey] !== nextValue;\n+       if (!hasChanged) {\n+         return state;\n+       }\n+ \n+       return {\n+         ...state,\n+         formData: {\n+           ...state.formData,\n+           [action.fieldKey]: nextValue,\n+         },\n+         isDirty: true,\n+       };\n+     }\n+     case \&quot;MARK_TOUCHED\&quot;: {\n+       if (state.touched.has(action.fieldKey)) {\n+         return state;\n+       }\n+       const touched = new Set(state.touched);\n+       touched.add(action.fieldKey);\n+       return {\n+         ...state,\n+         touched,\n+       };\n+     }\n+     case \&quot;MARK_TOUCHED_FIELDS\&quot;: {\n+       if (action.fieldKeys.length === 0) {\n+         return state;\n+       }\n+       const touched = new Set(state.touched);\n+       let modified = false;\n+       action.fieldKeys.forEach((key) =&gt; {\n+         if (!touched.has(key)) {\n+           touched.add(key);\n+           modified = true;\n+         }\n+       });\n+       if (!modified) {\n+         return state;\n+       }\n+       return {\n+         ...state,\n+         touched,\n+       };\n+     }\n+     case \&quot;SET_STEP_ERRORS\&quot;: {\n+       const nextErrors = { ...state.errors };\n+       const fieldSet = new Set(action.fieldKeys);\n+ \n+       // Remove stale errors for this step\n+       fieldSet.forEach((fieldKey) =&gt; {\n+         if (!(fieldKey in action.errors)) {\n+           delete nextErrors[fieldKey];\n+         }\n+       });\n+ \n+       // Apply new errors\n+       Object.entries(action.errors).forEach(([fieldKey, message]) =&gt; {\n+         nextErrors[fieldKey] = message;\n+       });\n+ \n+       return {\n+         ...state,\n+         errors: nextErrors,\n+       };\n+     }\n+     case \&quot;SET_ERRORS\&quot;: {\n+       return {\n+         ...state,\n+         errors: action.errors,\n+       };\n+     }\n+     case \&quot;SET_CURRENT_STEP\&quot;: {\n+       if (state.currentStep === action.step) {\n+         return state;\n+       }\n+       return {\n+         ...state,\n+         currentStep: action.step,\n+       };\n+     }\n+     case \&quot;MARK_STEP_COMPLETE\&quot;: {\n+       if (state.completedSteps.has(action.step)) {\n+         return state;\n+       }\n+       const completedSteps = new Set(state.completedSteps);\n+       completedSteps.add(action.step);\n+       return {\n+         ...state,\n+         completedSteps,\n+       };\n+     }\n+     case \&quot;SET_SUBMITTING\&quot;: {\n+       if (state.isSubmitting === action.value) {\n+         return state;\n+       }\n+       return {\n+         ...state,\n+         isSubmitting: action.value,\n+       };\n+     }\n+     case \&quot;SET_DIRTY\&quot;: {\n+       if (state.isDirty === action.value) {\n+         return state;\n+       }\n+       return {\n+         ...state,\n+         isDirty: action.value,\n+       };\n+     }\n+     default:\n+       return state;\n+   }\n+ }\n+ \n+ export interface UseFormStateOptions {\n+   formConfig: FormConfigWithFields;\n+   initialData?: Record&lt;string, unknown&gt;;\n+   initialStep?: number;\n+ }\n+ \n+ export interface UseFormStateReturn {\n+   state: FormState;\n+   touchedMap: Record&lt;string, boolean&gt;;\n+   setFieldValue: (fieldKey: string, value: unknown) =&gt; void;\n+   markFieldTouched: (fieldKey: string) =&gt; void;\n+   markFieldsTouched: (fieldKeys: string[]) =&gt; void;\n+   setStepErrors: (fieldKeys: string[], errors: Record&lt;string, string&gt;) =&gt; void;\n+   setErrors: (errors: Record&lt;string, string&gt;) =&gt; void;\n+   goToStep: (step: number) =&gt; void;\n+   markStepComplete: (step: number) =&gt; void;\n+   setIsSubmitting: (value: boolean) =&gt; void;\n+   markClean: () =&gt; void;\n+   validateStepAt: (\n+     stepIndex: number\n+   ) =&gt; StepValidationResult &amp; { fieldKeys: string[] };\n+ }\n+ \n+ export function useFormState({\n+   formConfig,\n+   initialData,\n+   initialStep = 0,\n+ }: UseFormStateOptions): UseFormStateReturn {\n+   const [state, dispatch] = useReducer(\n+     reducer,\n+     undefined,\n+     () =&gt; createInitialFormState(initialData ?? {}, initialStep)\n+   );\n+ \n+   const touchedMap = useMemo(() =&gt; {\n+     const result: Record&lt;string, boolean&gt; = {};\n+     state.touched.forEach((key) =&gt; {\n+       result[key] = true;\n+     });\n+     return result;\n+   }, [state.touched]);\n+ \n+   const setFieldValue = useCallback((fieldKey: string, value: unknown) =&gt; {\n+     dispatch({ type: \&quot;SET_FIELD_VALUE\&quot;, fieldKey, value });\n+   }, []);\n+ \n+   const markFieldTouched = useCallback((fieldKey: string) =&gt; {\n+     dispatch({ type: \&quot;MARK_TOUCHED\&quot;, fieldKey });\n+   }, []);\n+ \n+   const markFieldsTouched = useCallback((fieldKeys: string[]) =&gt; {\n+     dispatch({ type: \&quot;MARK_TOUCHED_FIELDS\&quot;, fieldKeys });\n+   }, []);\n+ \n+   const setStepErrors = useCallback(\n+     (fieldKeys: string[], errors: Record&lt;string, string&gt;) =&gt; {\n+       dispatch({\n+         type: \&quot;SET_STEP_ERRORS\&quot;,\n+         fieldKeys,\n+         errors,\n+       });\n+     },\n+     []\n+   );\n+ \n+   const setErrors = useCallback((errors: Record&lt;string, string&gt;) =&gt; {\n+     dispatch({ type: \&quot;SET_ERRORS\&quot;, errors });\n+   }, []);\n+ \n+   const goToStep = useCallback((step: number) =&gt; {\n+     dispatch({ type: \&quot;SET_CURRENT_STEP\&quot;, step });\n+   }, []);\n+ \n+   const markStepComplete = useCallback((step: number) =&gt; {\n+     dispatch({ type: \&quot;MARK_STEP_COMPLETE\&quot;, step });\n+   }, []);\n+ \n+   const setIsSubmitting = useCallback((value: boolean) =&gt; {\n+     dispatch({ type: \&quot;SET_SUBMITTING\&quot;, value });\n+   }, []);\n+ \n+   const markClean = useCallback(() =&gt; {\n+     dispatch({ type: \&quot;SET_DIRTY\&quot;, value: false });\n+   }, []);\n+ \n+   const validateStepAt = useCallback(\n+     (stepIndex: number) =&gt; {\n+       const result = validateStep(stepIndex, state.formData, formConfig);\n+       const fieldKeys = getStepFieldKeys(stepIndex, formConfig);\n+       return {\n+         ...result,\n+         fieldKeys,\n+       };\n+     },\n+     [formConfig, state.formData]\n+   );\n+ \n+   return {\n+     state,\n+     touchedMap,\n+     setFieldValue,\n+     markFieldTouched,\n+     markFieldsTouched,\n+     setStepErrors,\n+     setErrors,\n+     goToStep,\n+     markStepComplete,\n+     setIsSubmitting,\n+     markClean,\n+     validateStepAt,\n+   };\n+ }\n+ &quot;,
        &quot;oldStart&quot;: 1,
        &quot;newStart&quot;: 1,
        &quot;oldLines&quot;: 1,
        &quot;newLines&quot;: 257,
        &quot;linesRemoved&quot;: 1,
        &quot;linesAdded&quot;: 257
      }
    ],
    &quot;editor&quot;: &quot;EDITOR_AI&quot;
  },
  &quot;shouldAutoFixLints&quot;: true,
  &quot;resultForModel&quot;: &quot;Success. Updated the following files:\nM /Users/sahilmehta/supplier-onboarding-simple/hooks/use-form-state.ts&quot;,
  &quot;contentsAfterEdit&quot;: &quot;\&quot;use client\&quot;;\n\nimport { useCallback, useMemo, useReducer } from \&quot;react\&quot;;\nimport type { FormConfigWithFields } from \&quot;@/lib/forms/types\&quot;;\nimport {\n  createInitialFormState,\n  type FormState,\n} from \&quot;@/lib/forms/form-state\&quot;;\nimport {\n  getStepFieldKeys,\n  validateStep,\n  type StepValidationResult,\n} from \&quot;@/lib/forms/form-validator\&quot;;\n\ntype FormStateAction =\n  | { type: \&quot;SET_FIELD_VALUE\&quot;; fieldKey: string; value: unknown }\n  | { type: \&quot;MARK_TOUCHED\&quot;; fieldKey: string }\n  | { type: \&quot;MARK_TOUCHED_FIELDS\&quot;; fieldKeys: string[] }\n  | { type: \&quot;SET_STEP_ERRORS\&quot;; fieldKeys: string[]; errors: Record&lt;string, string&gt; }\n  | { type: \&quot;SET_ERRORS\&quot;; errors: Record&lt;string, string&gt; }\n  | { type: \&quot;SET_CURRENT_STEP\&quot;; step: number }\n  | { type: \&quot;MARK_STEP_COMPLETE\&quot;; step: number }\n  | { type: \&quot;SET_SUBMITTING\&quot;; value: boolean }\n  | { type: \&quot;SET_DIRTY\&quot;; value: boolean };\n\nfunction reducer(state: FormState, action: FormStateAction): FormState {\n  switch (action.type) {\n    case \&quot;SET_FIELD_VALUE\&quot;: {\n      const nextValue = action.value;\n      const hasChanged = state.formData[action.fieldKey] !== nextValue;\n      if (!hasChanged) {\n        return state;\n      }\n\n      return {\n        ...state,\n        formData: {\n          ...state.formData,\n          [action.fieldKey]: nextValue,\n        },\n        isDirty: true,\n      };\n    }\n    case \&quot;MARK_TOUCHED\&quot;: {\n      if (state.touched.has(action.fieldKey)) {\n        return state;\n      }\n      const touched = new Set(state.touched);\n      touched.add(action.fieldKey);\n      return {\n        ...state,\n        touched,\n      };\n    }\n    case \&quot;MARK_TOUCHED_FIELDS\&quot;: {\n      if (action.fieldKeys.length === 0) {\n        return state;\n      }\n      const touched = new Set(state.touched);\n      let modified = false;\n      action.fieldKeys.forEach((key) =&gt; {\n        if (!touched.has(key)) {\n          touched.add(key);\n          modified = true;\n        }\n      });\n      if (!modified) {\n        return state;\n      }\n      return {\n        ...state,\n        touched,\n      };\n    }\n    case \&quot;SET_STEP_ERRORS\&quot;: {\n      const nextErrors = { ...state.errors };\n      const fieldSet = new Set(action.fieldKeys);\n\n      // Remove stale errors for this step\n      fieldSet.forEach((fieldKey) =&gt; {\n        if (!(fieldKey in action.errors)) {\n          delete nextErrors[fieldKey];\n        }\n      });\n\n      // Apply new errors\n      Object.entries(action.errors).forEach(([fieldKey, message]) =&gt; {\n        nextErrors[fieldKey] = message;\n      });\n\n      return {\n        ...state,\n        errors: nextErrors,\n      };\n    }\n    case \&quot;SET_ERRORS\&quot;: {\n      return {\n        ...state,\n        errors: action.errors,\n      };\n    }\n    case \&quot;SET_CURRENT_STEP\&quot;: {\n      if (state.currentStep === action.step) {\n        return state;\n      }\n      return {\n        ...state,\n        currentStep: action.step,\n      };\n    }\n    case \&quot;MARK_STEP_COMPLETE\&quot;: {\n      if (state.completedSteps.has(action.step)) {\n        return state;\n      }\n      const completedSteps = new Set(state.completedSteps);\n      completedSteps.add(action.step);\n      return {\n        ...state,\n        completedSteps,\n      };\n    }\n    case \&quot;SET_SUBMITTING\&quot;: {\n      if (state.isSubmitting === action.value) {\n        return state;\n      }\n      return {\n        ...state,\n        isSubmitting: action.value,\n      };\n    }\n    case \&quot;SET_DIRTY\&quot;: {\n      if (state.isDirty === action.value) {\n        return state;\n      }\n      return {\n        ...state,\n        isDirty: action.value,\n      };\n    }\n    default:\n      return state;\n  }\n}\n\nexport interface UseFormStateOptions {\n  formConfig: FormConfigWithFields;\n  initialData?: Record&lt;string, unknown&gt;;\n  initialStep?: number;\n}\n\nexport interface UseFormStateReturn {\n  state: FormState;\n  touchedMap: Record&lt;string, boolean&gt;;\n  setFieldValue: (fieldKey: string, value: unknown) =&gt; void;\n  markFieldTouched: (fieldKey: string) =&gt; void;\n  markFieldsTouched: (fieldKeys: string[]) =&gt; void;\n  setStepErrors: (fieldKeys: string[], errors: Record&lt;string, string&gt;) =&gt; void;\n  setErrors: (errors: Record&lt;string, string&gt;) =&gt; void;\n  goToStep: (step: number) =&gt; void;\n  markStepComplete: (step: number) =&gt; void;\n  setIsSubmitting: (value: boolean) =&gt; void;\n  markClean: () =&gt; void;\n  validateStepAt: (\n    stepIndex: number\n  ) =&gt; StepValidationResult &amp; { fieldKeys: string[] };\n}\n\nexport function useFormState({\n  formConfig,\n  initialData,\n  initialStep = 0,\n}: UseFormStateOptions): UseFormStateReturn {\n  const [state, dispatch] = useReducer(\n    reducer,\n    undefined,\n    () =&gt; createInitialFormState(initialData ?? {}, initialStep)\n  );\n\n  const touchedMap = useMemo(() =&gt; {\n    const result: Record&lt;string, boolean&gt; = {};\n    state.touched.forEach((key) =&gt; {\n      result[key] = true;\n    });\n    return result;\n  }, [state.touched]);\n\n  const setFieldValue = useCallback((fieldKey: string, value: unknown) =&gt; {\n    dispatch({ type: \&quot;SET_FIELD_VALUE\&quot;, fieldKey, value });\n  }, []);\n\n  const markFieldTouched = useCallback((fieldKey: string) =&gt; {\n    dispatch({ type: \&quot;MARK_TOUCHED\&quot;, fieldKey });\n  }, []);\n\n  const markFieldsTouched = useCallback((fieldKeys: string[]) =&gt; {\n    dispatch({ type: \&quot;MARK_TOUCHED_FIELDS\&quot;, fieldKeys });\n  }, []);\n\n  const setStepErrors = useCallback(\n    (fieldKeys: string[], errors: Record&lt;string, string&gt;) =&gt; {\n      dispatch({\n        type: \&quot;SET_STEP_ERRORS\&quot;,\n        fieldKeys,\n        errors,\n      });\n    },\n    []\n  );\n\n  const setErrors = useCallback((errors: Record&lt;string, string&gt;) =&gt; {\n    dispatch({ type: \&quot;SET_ERRORS\&quot;, errors });\n  }, []);\n\n  const goToStep = useCallback((step: number) =&gt; {\n    dispatch({ type: \&quot;SET_CURRENT_STEP\&quot;, step });\n  }, []);\n\n  const markStepComplete = useCallback((step: number) =&gt; {\n    dispatch({ type: \&quot;MARK_STEP_COMPLETE\&quot;, step });\n  }, []);\n\n  const setIsSubmitting = useCallback((value: boolean) =&gt; {\n    dispatch({ type: \&quot;SET_SUBMITTING\&quot;, value });\n  }, []);\n\n  const markClean = useCallback(() =&gt; {\n    dispatch({ type: \&quot;SET_DIRTY\&quot;, value: false });\n  }, []);\n\n  const validateStepAt = useCallback(\n    (stepIndex: number) =&gt; {\n      const result = validateStep(stepIndex, state.formData, formConfig);\n      const fieldKeys = getStepFieldKeys(stepIndex, formConfig);\n      return {\n        ...result,\n        fieldKeys,\n      };\n    },\n    [formConfig, state.formData]\n  );\n\n  return {\n    state,\n    touchedMap,\n    setFieldValue,\n    markFieldTouched,\n    markFieldsTouched,\n    setStepErrors,\n    setErrors,\n    goToStep,\n    markStepComplete,\n    setIsSubmitting,\n    markClean,\n    validateStepAt,\n  };\n}\n\n&quot;
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Adding combined validation and update function**

I’m planning to create a new function that wraps `validateStepAt` and also marks fields as touched and sets step errors, to streamline validation and state updates. I need to manage dependencies carefully to avoid circular hooks and will add this new combined function to the returned hook API for cleaner usage.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  &quot;relativeWorkspacePath&quot;: &quot;/Users/sahilmehta/supplier-onboarding-simple/hooks/use-form-state.ts&quot;
}
```
Additional data:

```json
{
  &quot;codeblockId&quot;: &quot;08ebeb16-4049-4494-b115-00ca7c97929d&quot;,
  &quot;reviewData&quot;: {
    &quot;status&quot;: &quot;None&quot;,
    &quot;selectedOption&quot;: &quot;accept&quot;,
    &quot;isShowingInput&quot;: false,
    &quot;firstTimeReviewMode&quot;: false
  }
}
```
Result:

```json
{
  &quot;diff&quot;: {
    &quot;chunks&quot;: [
      {
        &quot;diffString&quot;: &quot;      stepIndex: number\n    ) =&gt; StepValidationResult &amp; { fieldKeys: string[] };\n+   validateAndCommitStep: (\n+     stepIndex: number\n+   ) =&gt; StepValidationResult &amp; { fieldKeys: string[] };\n  }\n  &quot;,
        &quot;oldStart&quot;: 164,
        &quot;newStart&quot;: 164,
        &quot;oldLines&quot;: 4,
        &quot;newLines&quot;: 7,
        &quot;linesAdded&quot;: 3
      },
      {
        &quot;diffString&quot;: &quot;      [formConfig, state.formData]\n    );\n+ \n+   const validateAndCommitStep = useCallback(\n+     (stepIndex: number) =&gt; {\n+       const validation = validateStepAt(stepIndex);\n+       markFieldsTouched(validation.fieldKeys);\n+       setStepErrors(validation.fieldKeys, validation.errors);\n+       return validation;\n+     },\n+     [markFieldsTouched, setStepErrors, validateStepAt]\n+   );\n  \n    return {&quot;,
        &quot;oldStart&quot;: 239,
        &quot;newStart&quot;: 242,
        &quot;oldLines&quot;: 4,
        &quot;newLines&quot;: 14,
        &quot;linesAdded&quot;: 10
      },
      {
        &quot;diffString&quot;: &quot;      markClean,\n      validateStepAt,\n+     validateAndCommitStep,\n    };\n  }&quot;,
        &quot;oldStart&quot;: 253,
        &quot;newStart&quot;: 266,
        &quot;oldLines&quot;: 4,
        &quot;newLines&quot;: 5,
        &quot;linesAdded&quot;: 1
      }
    ],
    &quot;editor&quot;: &quot;EDITOR_AI&quot;
  },
  &quot;shouldAutoFixLints&quot;: true,
  &quot;resultForModel&quot;: &quot;Success. Updated the following files:\nM /Users/sahilmehta/supplier-onboarding-simple/hooks/use-form-state.ts&quot;,
  &quot;contentsAfterEdit&quot;: &quot;\&quot;use client\&quot;;\n\nimport { useCallback, useMemo, useReducer } from \&quot;react\&quot;;\nimport type { FormConfigWithFields } from \&quot;@/lib/forms/types\&quot;;\nimport {\n  createInitialFormState,\n  type FormState,\n} from \&quot;@/lib/forms/form-state\&quot;;\nimport {\n  getStepFieldKeys,\n  validateStep,\n  type StepValidationResult,\n} from \&quot;@/lib/forms/form-validator\&quot;;\n\ntype FormStateAction =\n  | { type: \&quot;SET_FIELD_VALUE\&quot;; fieldKey: string; value: unknown }\n  | { type: \&quot;MARK_TOUCHED\&quot;; fieldKey: string }\n  | { type: \&quot;MARK_TOUCHED_FIELDS\&quot;; fieldKeys: string[] }\n  | { type: \&quot;SET_STEP_ERRORS\&quot;; fieldKeys: string[]; errors: Record&lt;string, string&gt; }\n  | { type: \&quot;SET_ERRORS\&quot;; errors: Record&lt;string, string&gt; }\n  | { type: \&quot;SET_CURRENT_STEP\&quot;; step: number }\n  | { type: \&quot;MARK_STEP_COMPLETE\&quot;; step: number }\n  | { type: \&quot;SET_SUBMITTING\&quot;; value: boolean }\n  | { type: \&quot;SET_DIRTY\&quot;; value: boolean };\n\nfunction reducer(state: FormState, action: FormStateAction): FormState {\n  switch (action.type) {\n    case \&quot;SET_FIELD_VALUE\&quot;: {\n      const nextValue = action.value;\n      const hasChanged = state.formData[action.fieldKey] !== nextValue;\n      if (!hasChanged) {\n        return state;\n      }\n\n      return {\n        ...state,\n        formData: {\n          ...state.formData,\n          [action.fieldKey]: nextValue,\n        },\n        isDirty: true,\n      };\n    }\n    case \&quot;MARK_TOUCHED\&quot;: {\n      if (state.touched.has(action.fieldKey)) {\n        return state;\n      }\n      const touched = new Set(state.touched);\n      touched.add(action.fieldKey);\n      return {\n        ...state,\n        touched,\n      };\n    }\n    case \&quot;MARK_TOUCHED_FIELDS\&quot;: {\n      if (action.fieldKeys.length === 0) {\n        return state;\n      }\n      const touched = new Set(state.touched);\n      let modified = false;\n      action.fieldKeys.forEach((key) =&gt; {\n        if (!touched.has(key)) {\n          touched.add(key);\n          modified = true;\n        }\n      });\n      if (!modified) {\n        return state;\n      }\n      return {\n        ...state,\n        touched,\n      };\n    }\n    case \&quot;SET_STEP_ERRORS\&quot;: {\n      const nextErrors = { ...state.errors };\n      const fieldSet = new Set(action.fieldKeys);\n\n      // Remove stale errors for this step\n      fieldSet.forEach((fieldKey) =&gt; {\n        if (!(fieldKey in action.errors)) {\n          delete nextErrors[fieldKey];\n        }\n      });\n\n      // Apply new errors\n      Object.entries(action.errors).forEach(([fieldKey, message]) =&gt; {\n        nextErrors[fieldKey] = message;\n      });\n\n      return {\n        ...state,\n        errors: nextErrors,\n      };\n    }\n    case \&quot;SET_ERRORS\&quot;: {\n      return {\n        ...state,\n        errors: action.errors,\n      };\n    }\n    case \&quot;SET_CURRENT_STEP\&quot;: {\n      if (state.currentStep === action.step) {\n        return state;\n      }\n      return {\n        ...state,\n        currentStep: action.step,\n      };\n    }\n    case \&quot;MARK_STEP_COMPLETE\&quot;: {\n      if (state.completedSteps.has(action.step)) {\n        return state;\n      }\n      const completedSteps = new Set(state.completedSteps);\n      completedSteps.add(action.step);\n      return {\n        ...state,\n        completedSteps,\n      };\n    }\n    case \&quot;SET_SUBMITTING\&quot;: {\n      if (state.isSubmitting === action.value) {\n        return state;\n      }\n      return {\n        ...state,\n        isSubmitting: action.value,\n      };\n    }\n    case \&quot;SET_DIRTY\&quot;: {\n      if (state.isDirty === action.value) {\n        return state;\n      }\n      return {\n        ...state,\n        isDirty: action.value,\n      };\n    }\n    default:\n      return state;\n  }\n}\n\nexport interface UseFormStateOptions {\n  formConfig: FormConfigWithFields;\n  initialData?: Record&lt;string, unknown&gt;;\n  initialStep?: number;\n}\n\nexport interface UseFormStateReturn {\n  state: FormState;\n  touchedMap: Record&lt;string, boolean&gt;;\n  setFieldValue: (fieldKey: string, value: unknown) =&gt; void;\n  markFieldTouched: (fieldKey: string) =&gt; void;\n  markFieldsTouched: (fieldKeys: string[]) =&gt; void;\n  setStepErrors: (fieldKeys: string[], errors: Record&lt;string, string&gt;) =&gt; void;\n  setErrors: (errors: Record&lt;string, string&gt;) =&gt; void;\n  goToStep: (step: number) =&gt; void;\n  markStepComplete: (step: number) =&gt; void;\n  setIsSubmitting: (value: boolean) =&gt; void;\n  markClean: () =&gt; void;\n  validateStepAt: (\n    stepIndex: number\n  ) =&gt; StepValidationResult &amp; { fieldKeys: string[] };\n  validateAndCommitStep: (\n    stepIndex: number\n  ) =&gt; StepValidationResult &amp; { fieldKeys: string[] };\n}\n\nexport function useFormState({\n  formConfig,\n  initialData,\n  initialStep = 0,\n}: UseFormStateOptions): UseFormStateReturn {\n  const [state, dispatch] = useReducer(\n    reducer,\n    undefined,\n    () =&gt; createInitialFormState(initialData ?? {}, initialStep)\n  );\n\n  const touchedMap = useMemo(() =&gt; {\n    const result: Record&lt;string, boolean&gt; = {};\n    state.touched.forEach((key) =&gt; {\n      result[key] = true;\n    });\n    return result;\n  }, [state.touched]);\n\n  const setFieldValue = useCallback((fieldKey: string, value: unknown) =&gt; {\n    dispatch({ type: \&quot;SET_FIELD_VALUE\&quot;, fieldKey, value });\n  }, []);\n\n  const markFieldTouched = useCallback((fieldKey: string) =&gt; {\n    dispatch({ type: \&quot;MARK_TOUCHED\&quot;, fieldKey });\n  }, []);\n\n  const markFieldsTouched = useCallback((fieldKeys: string[]) =&gt; {\n    dispatch({ type: \&quot;MARK_TOUCHED_FIELDS\&quot;, fieldKeys });\n  }, []);\n\n  const setStepErrors = useCallback(\n    (fieldKeys: string[], errors: Record&lt;string, string&gt;) =&gt; {\n      dispatch({\n        type: \&quot;SET_STEP_ERRORS\&quot;,\n        fieldKeys,\n        errors,\n      });\n    },\n    []\n  );\n\n  const setErrors = useCallback((errors: Record&lt;string, string&gt;) =&gt; {\n    dispatch({ type: \&quot;SET_ERRORS\&quot;, errors });\n  }, []);\n\n  const goToStep = useCallback((step: number) =&gt; {\n    dispatch({ type: \&quot;SET_CURRENT_STEP\&quot;, step });\n  }, []);\n\n  const markStepComplete = useCallback((step: number) =&gt; {\n    dispatch({ type: \&quot;MARK_STEP_COMPLETE\&quot;, step });\n  }, []);\n\n  const setIsSubmitting = useCallback((value: boolean) =&gt; {\n    dispatch({ type: \&quot;SET_SUBMITTING\&quot;, value });\n  }, []);\n\n  const markClean = useCallback(() =&gt; {\n    dispatch({ type: \&quot;SET_DIRTY\&quot;, value: false });\n  }, []);\n\n  const validateStepAt = useCallback(\n    (stepIndex: number) =&gt; {\n      const result = validateStep(stepIndex, state.formData, formConfig);\n      const fieldKeys = getStepFieldKeys(stepIndex, formConfig);\n      return {\n        ...result,\n        fieldKeys,\n      };\n    },\n    [formConfig, state.formData]\n  );\n\n  const validateAndCommitStep = useCallback(\n    (stepIndex: number) =&gt; {\n      const validation = validateStepAt(stepIndex);\n      markFieldsTouched(validation.fieldKeys);\n      setStepErrors(validation.fieldKeys, validation.errors);\n      return validation;\n    },\n    [markFieldsTouched, setStepErrors, validateStepAt]\n  );\n\n  return {\n    state,\n    touchedMap,\n    setFieldValue,\n    markFieldTouched,\n    markFieldsTouched,\n    setStepErrors,\n    setErrors,\n    goToStep,\n    markStepComplete,\n    setIsSubmitting,\n    markClean,\n    validateStepAt,\n    validateAndCommitStep,\n  };\n}\n\n&quot;
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Designing a robust autosave hook**

I'm mapping out an autosave React hook that manages save timing, debouncing, and error handling while letting components provide save logic and data fingerprints; it supports manual saves, unload warnings, and tracks save status with hooks like useTransition and useEffect to ensure efficient, flexible form draft saving.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  &quot;relativeWorkspacePath&quot;: &quot;/Users/sahilmehta/supplier-onboarding-simple/hooks/use-autosave.ts&quot;
}
```
Additional data:

```json
{
  &quot;codeblockId&quot;: &quot;e237e740-6380-47f3-a573-6cdcff930e95&quot;,
  &quot;reviewData&quot;: {
    &quot;status&quot;: &quot;None&quot;,
    &quot;selectedOption&quot;: &quot;accept&quot;,
    &quot;isShowingInput&quot;: false,
    &quot;firstTimeReviewMode&quot;: false
  }
}
```
Result:

```json
{
  &quot;diff&quot;: {
    &quot;chunks&quot;: [
      {
        &quot;diffString&quot;: &quot;- \n+ \&quot;use client\&quot;;\n+ \n+ import { useCallback, useEffect, useRef, useState, useTransition } from \&quot;react\&quot;;\n+ \n+ export type AutosaveStatus = \&quot;idle\&quot; | \&quot;saving\&quot; | \&quot;saved\&quot; | \&quot;error\&quot;;\n+ export type AutosaveReason = \&quot;debounce\&quot; | \&quot;step-change\&quot; | \&quot;manual\&quot;;\n+ \n+ export interface UseAutosaveOptions&lt;TResult&gt; {\n+   /**\n+    * When true, autosave timers will run. Typically tied to &#96;isDirty&#96;.\n+    */\n+   shouldAutosave: boolean;\n+   /**\n+    * Unique string representing the data that should trigger autosave.\n+    * Commonly a JSON string of the form data.\n+    */\n+   dataFingerprint: string;\n+   /**\n+    * Debounce delay in milliseconds before triggering autosave.\n+    */\n+   debounceMs?: number;\n+   /**\n+    * Called to persist the draft. Should throw on failure.\n+    */\n+   save: () =&gt; Promise&lt;TResult&gt;;\n+   /**\n+    * Optional callback invoked when a save succeeds.\n+    */\n+   onSuccess?: (result: TResult) =&gt; void;\n+   /**\n+    * Optional callback invoked when a save fails.\n+    */\n+   onError?: (error: Error) =&gt; void;\n+   /**\n+    * Whether to show a browser prompt on unload when unsaved changes exist.\n+    */\n+   warnOnUnload?: boolean;\n+ }\n+ \n+ export interface UseAutosaveReturn&lt;TResult&gt; {\n+   status: AutosaveStatus;\n+   isSaving: boolean;\n+   lastSavedAt?: string;\n+   error?: string;\n+   triggerSave: (reason?: AutosaveReason) =&gt; Promise&lt;TResult | null&gt;;\n+ }\n+ \n+ export function useAutosave&lt;TResult&gt;({\n+   shouldAutosave,\n+   dataFingerprint,\n+   debounceMs = 2000,\n+   save,\n+   onSuccess,\n+   onError,\n+   warnOnUnload = true,\n+ }: UseAutosaveOptions&lt;TResult&gt;): UseAutosaveReturn&lt;TResult&gt; {\n+   const [status, setStatus] = useState&lt;AutosaveStatus&gt;(\&quot;idle\&quot;);\n+   const [error, setError] = useState&lt;string | undefined&gt;();\n+   const [lastSavedAt, setLastSavedAt] = useState&lt;string | undefined&gt;();\n+   const [isSaving, startSaving] = useTransition();\n+ \n+   const debounceTimerRef = useRef&lt;NodeJS.Timeout | null&gt;(null);\n+   const lastFingerprintRef = useRef&lt;string&gt;(dataFingerprint);\n+   const lastSuccessfulFingerprintRef = useRef&lt;string | null&gt;(null);\n+ \n+   const clearTimer = () =&gt; {\n+     if (debounceTimerRef.current) {\n+       clearTimeout(debounceTimerRef.current);\n+       debounceTimerRef.current = null;\n+     }\n+   };\n+ \n+   const performSave = useCallback(\n+     async (reason: AutosaveReason) =&gt; {\n+       clearTimer();\n+       setStatus(\&quot;saving\&quot;);\n+       setError(undefined);\n+ \n+       return new Promise&lt;TResult | null&gt;((resolve) =&gt; {\n+         startSaving(async () =&gt; {\n+           try {\n+             const result = await save();\n+             lastSuccessfulFingerprintRef.current = dataFingerprint;\n+             setStatus(\&quot;saved\&quot;);\n+             setLastSavedAt(new Date().toISOString());\n+             onSuccess?.(result);\n+             resolve(result);\n+           } catch (err) {\n+             console.error(&#96;[autosave] Failed to save draft (${reason})&#96;, err);\n+             setStatus(\&quot;error\&quot;);\n+             const message =\n+               err instanceof Error ? err.message : \&quot;Failed to save draft\&quot;;\n+             setError(message);\n+             onError?.(err instanceof Error ? err : new Error(message));\n+             resolve(null);\n+           }\n+         });\n+       });\n+     },\n+     [dataFingerprint, onError, onSuccess, save]\n+   );\n+ \n+   const triggerSave = useCallback(\n+     async (reason: AutosaveReason = \&quot;manual\&quot;) =&gt; {\n+       return performSave(reason);\n+     },\n+     [performSave]\n+   );\n+ \n+   useEffect(() =&gt; {\n+     if (!shouldAutosave) {\n+       clearTimer();\n+       return;\n+     }\n+ \n+     if (dataFingerprint === lastSuccessfulFingerprintRef.current) {\n+       lastFingerprintRef.current = dataFingerprint;\n+       return;\n+     }\n+ \n+     if (dataFingerprint === lastFingerprintRef.current) {\n+       return;\n+     }\n+ \n+     lastFingerprintRef.current = dataFingerprint;\n+     clearTimer();\n+     debounceTimerRef.current = setTimeout(() =&gt; {\n+       void triggerSave(\&quot;debounce\&quot;);\n+     }, debounceMs);\n+ \n+     return clearTimer;\n+   }, [dataFingerprint, debounceMs, shouldAutosave, triggerSave]);\n+ \n+   useEffect(() =&gt; {\n+     if (!warnOnUnload) {\n+       return;\n+     }\n+ \n+     const handler = (event: BeforeUnloadEvent) =&gt; {\n+       if (!shouldAutosave) {\n+         return;\n+       }\n+       event.preventDefault();\n+       // eslint-disable-next-line no-param-reassign\n+       event.returnValue = \&quot;\&quot;;\n+     };\n+ \n+     window.addEventListener(\&quot;beforeunload\&quot;, handler);\n+     return () =&gt; {\n+       window.removeEventListener(\&quot;beforeunload\&quot;, handler);\n+     };\n+   }, [shouldAutosave, warnOnUnload]);\n+ \n+   return {\n+     status,\n+     isSaving,\n+     lastSavedAt,\n+     error,\n+     triggerSave,\n+   };\n+ }\n+ &quot;,
        &quot;oldStart&quot;: 1,
        &quot;newStart&quot;: 1,
        &quot;oldLines&quot;: 1,
        &quot;newLines&quot;: 162,
        &quot;linesRemoved&quot;: 1,
        &quot;linesAdded&quot;: 162
      }
    ],
    &quot;editor&quot;: &quot;EDITOR_AI&quot;
  },
  &quot;shouldAutoFixLints&quot;: true,
  &quot;resultForModel&quot;: &quot;Success. Updated the following files:\nM /Users/sahilmehta/supplier-onboarding-simple/hooks/use-autosave.ts&quot;,
  &quot;contentsAfterEdit&quot;: &quot;\&quot;use client\&quot;;\n\nimport { useCallback, useEffect, useRef, useState, useTransition } from \&quot;react\&quot;;\n\nexport type AutosaveStatus = \&quot;idle\&quot; | \&quot;saving\&quot; | \&quot;saved\&quot; | \&quot;error\&quot;;\nexport type AutosaveReason = \&quot;debounce\&quot; | \&quot;step-change\&quot; | \&quot;manual\&quot;;\n\nexport interface UseAutosaveOptions&lt;TResult&gt; {\n  /**\n   * When true, autosave timers will run. Typically tied to &#96;isDirty&#96;.\n   */\n  shouldAutosave: boolean;\n  /**\n   * Unique string representing the data that should trigger autosave.\n   * Commonly a JSON string of the form data.\n   */\n  dataFingerprint: string;\n  /**\n   * Debounce delay in milliseconds before triggering autosave.\n   */\n  debounceMs?: number;\n  /**\n   * Called to persist the draft. Should throw on failure.\n   */\n  save: () =&gt; Promise&lt;TResult&gt;;\n  /**\n   * Optional callback invoked when a save succeeds.\n   */\n  onSuccess?: (result: TResult) =&gt; void;\n  /**\n   * Optional callback invoked when a save fails.\n   */\n  onError?: (error: Error) =&gt; void;\n  /**\n   * Whether to show a browser prompt on unload when unsaved changes exist.\n   */\n  warnOnUnload?: boolean;\n}\n\nexport interface UseAutosaveReturn&lt;TResult&gt; {\n  status: AutosaveStatus;\n  isSaving: boolean;\n  lastSavedAt?: string;\n  error?: string;\n  triggerSave: (reason?: AutosaveReason) =&gt; Promise&lt;TResult | null&gt;;\n}\n\nexport function useAutosave&lt;TResult&gt;({\n  shouldAutosave,\n  dataFingerprint,\n  debounceMs = 2000,\n  save,\n  onSuccess,\n  onError,\n  warnOnUnload = true,\n}: UseAutosaveOptions&lt;TResult&gt;): UseAutosaveReturn&lt;TResult&gt; {\n  const [status, setStatus] = useState&lt;AutosaveStatus&gt;(\&quot;idle\&quot;);\n  const [error, setError] = useState&lt;string | undefined&gt;();\n  const [lastSavedAt, setLastSavedAt] = useState&lt;string | undefined&gt;();\n  const [isSaving, startSaving] = useTransition();\n\n  const debounceTimerRef = useRef&lt;NodeJS.Timeout | null&gt;(null);\n  const lastFingerprintRef = useRef&lt;string&gt;(dataFingerprint);\n  const lastSuccessfulFingerprintRef = useRef&lt;string | null&gt;(null);\n\n  const clearTimer = () =&gt; {\n    if (debounceTimerRef.current) {\n      clearTimeout(debounceTimerRef.current);\n      debounceTimerRef.current = null;\n    }\n  };\n\n  const performSave = useCallback(\n    async (reason: AutosaveReason) =&gt; {\n      clearTimer();\n      setStatus(\&quot;saving\&quot;);\n      setError(undefined);\n\n      return new Promise&lt;TResult | null&gt;((resolve) =&gt; {\n        startSaving(async () =&gt; {\n          try {\n            const result = await save();\n            lastSuccessfulFingerprintRef.current = dataFingerprint;\n            setStatus(\&quot;saved\&quot;);\n            setLastSavedAt(new Date().toISOString());\n            onSuccess?.(result);\n            resolve(result);\n          } catch (err) {\n            console.error(&#96;[autosave] Failed to save draft (${reason})&#96;, err);\n            setStatus(\&quot;error\&quot;);\n            const message =\n              err instanceof Error ? err.message : \&quot;Failed to save draft\&quot;;\n            setError(message);\n            onError?.(err instanceof Error ? err : new Error(message));\n            resolve(null);\n          }\n        });\n      });\n    },\n    [dataFingerprint, onError, onSuccess, save]\n  );\n\n  const triggerSave = useCallback(\n    async (reason: AutosaveReason = \&quot;manual\&quot;) =&gt; {\n      return performSave(reason);\n    },\n    [performSave]\n  );\n\n  useEffect(() =&gt; {\n    if (!shouldAutosave) {\n      clearTimer();\n      return;\n    }\n\n    if (dataFingerprint === lastSuccessfulFingerprintRef.current) {\n      lastFingerprintRef.current = dataFingerprint;\n      return;\n    }\n\n    if (dataFingerprint === lastFingerprintRef.current) {\n      return;\n    }\n\n    lastFingerprintRef.current = dataFingerprint;\n    clearTimer();\n    debounceTimerRef.current = setTimeout(() =&gt; {\n      void triggerSave(\&quot;debounce\&quot;);\n    }, debounceMs);\n\n    return clearTimer;\n  }, [dataFingerprint, debounceMs, shouldAutosave, triggerSave]);\n\n  useEffect(() =&gt; {\n    if (!warnOnUnload) {\n      return;\n    }\n\n    const handler = (event: BeforeUnloadEvent) =&gt; {\n      if (!shouldAutosave) {\n        return;\n      }\n      event.preventDefault();\n      // eslint-disable-next-line no-param-reassign\n      event.returnValue = \&quot;\&quot;;\n    };\n\n    window.addEventListener(\&quot;beforeunload\&quot;, handler);\n    return () =&gt; {\n      window.removeEventListener(\&quot;beforeunload\&quot;, handler);\n    };\n  }, [shouldAutosave, warnOnUnload]);\n\n  return {\n    status,\n    isSaving,\n    lastSavedAt,\n    error,\n    triggerSave,\n  };\n}\n\n&quot;
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Preparing hook integration and props update**

I'm making sure event types and timers are properly handled before integrating new hooks into `DynamicFormWizard`. I plan to replace its internal state with `useFormState` and `useAutosave`, update props to support autosave and server actions, and carefully preserve existing validation and side-effect behavior while removing deprecated callbacks. Next, I'll focus on reshaping the component to fit this new architecture.</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/sahilmehta/supplier-onboarding-simple/components/forms/step-indicator.tsx</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Designing form autosave integration and server actions**

I'm mapping out how to integrate new hooks like `useAutosave` into `DynamicFormWizard`, carefully tracking `applicationId` and managing autosave state with callbacks and fingerprints. Then, I plan to implement the essential server actions (`saveFormDraft`, `loadFormDraft`, `deleteFormDraft`) with membership checks to securely persist draft data, creating a new server file with proper types and helper functions.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  &quot;relativeWorkspacePath&quot;: &quot;/Users/sahilmehta/supplier-onboarding-simple/app/forms/actions.ts&quot;
}
```
Additional data:

```json
{
  &quot;codeblockId&quot;: &quot;0a855a26-f0ea-4dfc-b8a4-a1d0441e33e5&quot;,
  &quot;reviewData&quot;: {
    &quot;status&quot;: &quot;None&quot;,
    &quot;selectedOption&quot;: &quot;accept&quot;,
    &quot;isShowingInput&quot;: false,
    &quot;firstTimeReviewMode&quot;: false
  }
}
```
Result:

```json
{
  &quot;diff&quot;: {
    &quot;chunks&quot;: [
      {
        &quot;diffString&quot;: &quot;- \n+ \&quot;use server\&quot;;\n+ \n+ import { auth } from \&quot;@/lib/auth\&quot;;\n+ import { prisma } from \&quot;@/lib/prisma\&quot;;\n+ import {\n+   deleteDraftRecord,\n+   loadDraftRecord,\n+   saveDraftRecord,\n+   type DraftRecord,\n+ } from \&quot;@/lib/forms/draft-manager\&quot;;\n+ \n+ interface SaveFormDraftInput {\n+   formConfigId: string;\n+   organizationId: string;\n+   entityId: string;\n+   geographyId: string;\n+   applicationId?: string | null;\n+   formData: Record&lt;string, unknown&gt;;\n+   currentStep: number;\n+ }\n+ \n+ export interface DraftSaveResult {\n+   success: boolean;\n+   applicationId: string;\n+   currentStep: number;\n+   updatedAt: string;\n+ }\n+ \n+ export interface DraftLoadResult extends DraftRecord {}\n+ \n+ interface LoadFormDraftInput {\n+   organizationId: string;\n+   applicationId: string;\n+ }\n+ \n+ interface DeleteFormDraftInput extends LoadFormDraftInput {}\n+ \n+ async function ensureMembership(userId: string, organizationId: string) {\n+   const membership = await prisma.membership.findFirst({\n+     where: { userId, organizationId },\n+     select: { id: true },\n+   });\n+ \n+   if (!membership) {\n+     throw new Error(\&quot;Unauthorized\&quot;);\n+   }\n+ }\n+ \n+ export async function saveFormDraft(\n+   input: SaveFormDraftInput\n+ ): Promise&lt;DraftSaveResult&gt; {\n+   const session = await auth();\n+   if (!session?.user?.id) {\n+     throw new Error(\&quot;Unauthorized\&quot;);\n+   }\n+ \n+   await ensureMembership(session.user.id, input.organizationId);\n+ \n+   const record = await saveDraftRecord({\n+     applicationId: input.applicationId,\n+     formConfigId: input.formConfigId,\n+     organizationId: input.organizationId,\n+     entityId: input.entityId,\n+     geographyId: input.geographyId,\n+     formData: input.formData,\n+     currentStep: input.currentStep,\n+     userId: session.user.id,\n+   });\n+ \n+   return {\n+     success: true,\n+     applicationId: record.applicationId,\n+     currentStep: record.currentStep,\n+     updatedAt: record.updatedAt,\n+   };\n+ }\n+ \n+ export async function loadFormDraft(\n+   input: LoadFormDraftInput\n+ ): Promise&lt;DraftLoadResult | null&gt; {\n+   const session = await auth();\n+   if (!session?.user?.id) {\n+     throw new Error(\&quot;Unauthorized\&quot;);\n+   }\n+ \n+   await ensureMembership(session.user.id, input.organizationId);\n+ \n+   return loadDraftRecord({\n+     applicationId: input.applicationId,\n+     organizationId: input.organizationId,\n+     userId: session.user.id,\n+   });\n+ }\n+ \n+ export async function deleteFormDraft(\n+   input: DeleteFormDraftInput\n+ ): Promise&lt;{ success: boolean }&gt; {\n+   const session = await auth();\n+   if (!session?.user?.id) {\n+     throw new Error(\&quot;Unauthorized\&quot;);\n+   }\n+ \n+   await ensureMembership(session.user.id, input.organizationId);\n+   await deleteDraftRecord({\n+     applicationId: input.applicationId,\n+     organizationId: input.organizationId,\n+     userId: session.user.id,\n+   });\n+ \n+   return { success: true };\n+ }\n+ &quot;,
        &quot;oldStart&quot;: 1,
        &quot;newStart&quot;: 1,
        &quot;oldLines&quot;: 1,
        &quot;newLines&quot;: 112,
        &quot;linesRemoved&quot;: 1,
        &quot;linesAdded&quot;: 112
      }
    ],
    &quot;editor&quot;: &quot;EDITOR_AI&quot;
  },
  &quot;shouldAutoFixLints&quot;: true,
  &quot;resultForModel&quot;: &quot;Success. Updated the following files:\nM /Users/sahilmehta/supplier-onboarding-simple/app/forms/actions.ts&quot;,
  &quot;contentsAfterEdit&quot;: &quot;\&quot;use server\&quot;;\n\nimport { auth } from \&quot;@/lib/auth\&quot;;\nimport { prisma } from \&quot;@/lib/prisma\&quot;;\nimport {\n  deleteDraftRecord,\n  loadDraftRecord,\n  saveDraftRecord,\n  type DraftRecord,\n} from \&quot;@/lib/forms/draft-manager\&quot;;\n\ninterface SaveFormDraftInput {\n  formConfigId: string;\n  organizationId: string;\n  entityId: string;\n  geographyId: string;\n  applicationId?: string | null;\n  formData: Record&lt;string, unknown&gt;;\n  currentStep: number;\n}\n\nexport interface DraftSaveResult {\n  success: boolean;\n  applicationId: string;\n  currentStep: number;\n  updatedAt: string;\n}\n\nexport interface DraftLoadResult extends DraftRecord {}\n\ninterface LoadFormDraftInput {\n  organizationId: string;\n  applicationId: string;\n}\n\ninterface DeleteFormDraftInput extends LoadFormDraftInput {}\n\nasync function ensureMembership(userId: string, organizationId: string) {\n  const membership = await prisma.membership.findFirst({\n    where: { userId, organizationId },\n    select: { id: true },\n  });\n\n  if (!membership) {\n    throw new Error(\&quot;Unauthorized\&quot;);\n  }\n}\n\nexport async function saveFormDraft(\n  input: SaveFormDraftInput\n): Promise&lt;DraftSaveResult&gt; {\n  const session = await auth();\n  if (!session?.user?.id) {\n    throw new Error(\&quot;Unauthorized\&quot;);\n  }\n\n  await ensureMembership(session.user.id, input.organizationId);\n\n  const record = await saveDraftRecord({\n    applicationId: input.applicationId,\n    formConfigId: input.formConfigId,\n    organizationId: input.organizationId,\n    entityId: input.entityId,\n    geographyId: input.geographyId,\n    formData: input.formData,\n    currentStep: input.currentStep,\n    userId: session.user.id,\n  });\n\n  return {\n    success: true,\n    applicationId: record.applicationId,\n    currentStep: record.currentStep,\n    updatedAt: record.updatedAt,\n  };\n}\n\nexport async function loadFormDraft(\n  input: LoadFormDraftInput\n): Promise&lt;DraftLoadResult | null&gt; {\n  const session = await auth();\n  if (!session?.user?.id) {\n    throw new Error(\&quot;Unauthorized\&quot;);\n  }\n\n  await ensureMembership(session.user.id, input.organizationId);\n\n  return loadDraftRecord({\n    applicationId: input.applicationId,\n    organizationId: input.organizationId,\n    userId: session.user.id,\n  });\n}\n\nexport async function deleteFormDraft(\n  input: DeleteFormDraftInput\n): Promise&lt;{ success: boolean }&gt; {\n  const session = await auth();\n  if (!session?.user?.id) {\n    throw new Error(\&quot;Unauthorized\&quot;);\n  }\n\n  await ensureMembership(session.user.id, input.organizationId);\n  await deleteDraftRecord({\n    applicationId: input.applicationId,\n    organizationId: input.organizationId,\n    userId: session.user.id,\n  });\n\n  return { success: true };\n}\n\n&quot;
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Planning draft-save-indicator component**</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  &quot;relativeWorkspacePath&quot;: &quot;/Users/sahilmehta/supplier-onboarding-simple/components/forms/draft-save-indicator.tsx&quot;
}
```
Additional data:

```json
{
  &quot;codeblockId&quot;: &quot;c965ebe3-7b3a-485a-bf4a-2a06bb8d176b&quot;,
  &quot;reviewData&quot;: {
    &quot;status&quot;: &quot;None&quot;,
    &quot;selectedOption&quot;: &quot;accept&quot;,
    &quot;isShowingInput&quot;: false,
    &quot;firstTimeReviewMode&quot;: false
  }
}
```
Result:

```json
{
  &quot;diff&quot;: {
    &quot;chunks&quot;: [
      {
        &quot;diffString&quot;: &quot;+ \&quot;use client\&quot;;\n+ \n+ import { AlertTriangle, Check, Loader2 } from \&quot;lucide-react\&quot;;\n+ import type { AutosaveStatus } from \&quot;@/hooks/use-autosave\&quot;;\n+ \n+ interface DraftSaveIndicatorProps {\n+   status: AutosaveStatus;\n+   lastSavedAt?: string;\n+   error?: string;\n+ }\n+ \n+ export function DraftSaveIndicator({\n+   status,\n+   lastSavedAt,\n+   error,\n+ }: DraftSaveIndicatorProps) {\n+   if (status === \&quot;idle\&quot;) {\n+     return null;\n+   }\n+ \n+   if (status === \&quot;saving\&quot;) {\n+     return (\n+       &lt;div className=\&quot;flex items-center gap-2 text-xs text-muted-foreground\&quot;&gt;\n+         &lt;Loader2 className=\&quot;size-3 animate-spin\&quot; aria-hidden=\&quot;true\&quot; /&gt;\n+         &lt;span&gt;Saving draft…&lt;/span&gt;\n+       &lt;/div&gt;\n+     );\n+   }\n+ \n+   if (status === \&quot;error\&quot;) {\n+     return (\n+       &lt;div className=\&quot;flex items-center gap-2 text-xs text-red-600\&quot;&gt;\n+         &lt;AlertTriangle className=\&quot;size-3\&quot; aria-hidden=\&quot;true\&quot; /&gt;\n+         &lt;span&gt;{error ?? \&quot;Failed to save draft\&quot;}&lt;/span&gt;\n+       &lt;/div&gt;\n+     );\n+   }\n+ \n+   return (\n+     &lt;div className=\&quot;flex items-center gap-2 text-xs text-emerald-600\&quot;&gt;\n+       &lt;Check className=\&quot;size-3\&quot; aria-hidden=\&quot;true\&quot; /&gt;\n+       &lt;span&gt;\n+         Draft saved{\&quot; \&quot;}\n+         {lastSavedAt\n+           ? new Date(lastSavedAt).toLocaleTimeString([], {\n+               hour: \&quot;2-digit\&quot;,\n+               minute: \&quot;2-digit\&quot;,\n+             })\n+           : \&quot;just now\&quot;}\n+       &lt;/span&gt;\n+     &lt;/div&gt;\n+   );\n+ }\n  \&quot;use client\&quot;;\n  &quot;,
        &quot;oldStart&quot;: 1,
        &quot;newStart&quot;: 1,
        &quot;oldLines&quot;: 2,
        &quot;newLines&quot;: 55,
        &quot;linesAdded&quot;: 53
      }
    ],
    &quot;editor&quot;: &quot;EDITOR_AI&quot;
  },
  &quot;shouldAutoFixLints&quot;: true,
  &quot;resultForModel&quot;: &quot;Success. Updated the following files:\nM /Users/sahilmehta/supplier-onboarding-simple/components/forms/draft-save-indicator.tsx&quot;,
  &quot;contentsAfterEdit&quot;: &quot;\&quot;use client\&quot;;\n\nimport { AlertTriangle, Check, Loader2 } from \&quot;lucide-react\&quot;;\nimport type { AutosaveStatus } from \&quot;@/hooks/use-autosave\&quot;;\n\ninterface DraftSaveIndicatorProps {\n  status: AutosaveStatus;\n  lastSavedAt?: string;\n  error?: string;\n}\n\nexport function DraftSaveIndicator({\n  status,\n  lastSavedAt,\n  error,\n}: DraftSaveIndicatorProps) {\n  if (status === \&quot;idle\&quot;) {\n    return null;\n  }\n\n  if (status === \&quot;saving\&quot;) {\n    return (\n      &lt;div className=\&quot;flex items-center gap-2 text-xs text-muted-foreground\&quot;&gt;\n        &lt;Loader2 className=\&quot;size-3 animate-spin\&quot; aria-hidden=\&quot;true\&quot; /&gt;\n        &lt;span&gt;Saving draft…&lt;/span&gt;\n      &lt;/div&gt;\n    );\n  }\n\n  if (status === \&quot;error\&quot;) {\n    return (\n      &lt;div className=\&quot;flex items-center gap-2 text-xs text-red-600\&quot;&gt;\n        &lt;AlertTriangle className=\&quot;size-3\&quot; aria-hidden=\&quot;true\&quot; /&gt;\n        &lt;span&gt;{error ?? \&quot;Failed to save draft\&quot;}&lt;/span&gt;\n      &lt;/div&gt;\n    );\n  }\n\n  return (\n    &lt;div className=\&quot;flex items-center gap-2 text-xs text-emerald-600\&quot;&gt;\n      &lt;Check className=\&quot;size-3\&quot; aria-hidden=\&quot;true\&quot; /&gt;\n      &lt;span&gt;\n        Draft saved{\&quot; \&quot;}\n        {lastSavedAt\n          ? new Date(lastSavedAt).toLocaleTimeString([], {\n              hour: \&quot;2-digit\&quot;,\n              minute: \&quot;2-digit\&quot;,\n            })\n          : \&quot;just now\&quot;}\n      &lt;/span&gt;\n    &lt;/div&gt;\n  );\n}\n\&quot;use client\&quot;;\n\nimport { cn } from \&quot;@/lib/utils\&quot;;\nimport { AlertTriangle, CheckCircle2, Loader2, Save } from \&quot;lucide-react\&quot;;\n\nexport type DraftStatus = \&quot;idle\&quot; | \&quot;saving\&quot; | \&quot;success\&quot; | \&quot;error\&quot;;\n\ninterface DraftSaveIndicatorProps {\n  status: DraftStatus;\n  lastSavedAt?: Date | null;\n  errorMessage?: string;\n  className?: string;\n}\n\nexport function DraftSaveIndicator({\n  status,\n  lastSavedAt,\n  errorMessage,\n  className,\n}: DraftSaveIndicatorProps) {\n  let icon = &lt;Save className=\&quot;size-4\&quot; aria-hidden=\&quot;true\&quot; /&gt;;\n  let message = \&quot;Draft not saved yet\&quot;;\n\n  if (status === \&quot;saving\&quot;) {\n    icon = &lt;Loader2 className=\&quot;size-4 animate-spin\&quot; aria-hidden=\&quot;true\&quot; /&gt;;\n    message = \&quot;Saving draft…\&quot;;\n  } else if (status === \&quot;success\&quot; &amp;&amp; lastSavedAt) {\n    icon = &lt;CheckCircle2 className=\&quot;size-4 text-emerald-600\&quot; aria-hidden=\&quot;true\&quot; /&gt;;\n    message = &#96;Draft saved ${lastSavedAt.toLocaleTimeString([], { hour: \&quot;numeric\&quot;, minute: \&quot;2-digit\&quot; })}&#96;;\n  } else if (status === \&quot;error\&quot;) {\n    icon = &lt;AlertTriangle className=\&quot;size-4 text-destructive\&quot; aria-hidden=\&quot;true\&quot; /&gt;;\n    message = errorMessage ?? \&quot;Unable to save draft. Please try again.\&quot;;\n  }\n\n  return (\n    &lt;div\n      className={cn(\n        \&quot;flex items-center gap-2 rounded-xl bg-muted/60 px-3 py-2 text-xs text-muted-foreground\&quot;,\n        status === \&quot;error\&quot; &amp;&amp; \&quot;text-destructive\&quot;,\n        className\n      )}\n      role=\&quot;status\&quot;\n      aria-live=\&quot;polite\&quot;\n    &gt;\n      {icon}\n      &lt;span&gt;{message}&lt;/span&gt;\n    &lt;/div&gt;\n  );\n}\n\n&quot;
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Designing DraftResumeDialog component**

I'm planning how to build a client-side `DraftResumeDialog` using Shadcn dialog components. I'll manage local loading states for resuming and deleting drafts, handle async callbacks for selecting and deleting drafts, and add a "Start new" option. I'll include relative time display with `date-fns` and keep server logic outside this UI component for clarity.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  &quot;relativeWorkspacePath&quot;: &quot;/Users/sahilmehta/supplier-onboarding-simple/components/forms/draft-resume-dialog.tsx&quot;
}
```
Additional data:

```json
{
  &quot;codeblockId&quot;: &quot;3097d456-0b32-4e2f-801d-5647aa9c7204&quot;,
  &quot;reviewData&quot;: {
    &quot;status&quot;: &quot;None&quot;,
    &quot;selectedOption&quot;: &quot;accept&quot;,
    &quot;isShowingInput&quot;: false,
    &quot;firstTimeReviewMode&quot;: false
  }
}
```
Result:

```json
{
  &quot;diff&quot;: {
    &quot;chunks&quot;: [
      {
        &quot;diffString&quot;: &quot;- \n+ \&quot;use client\&quot;;\n+ \n+ import { useCallback, useState } from \&quot;react\&quot;;\n+ import { formatDistanceToNow } from \&quot;date-fns\&quot;;\n+ import { Loader2, Trash2 } from \&quot;lucide-react\&quot;;\n+ import type { DraftSummary } from \&quot;@/lib/forms/draft-manager\&quot;;\n+ import {\n+   Dialog,\n+   DialogContent,\n+   DialogDescription,\n+   DialogHeader,\n+   DialogTitle,\n+   DialogTrigger,\n+ } from \&quot;@/components/ui/dialog\&quot;;\n+ import { Button } from \&quot;@/components/ui/button\&quot;;\n+ import { ScrollArea } from \&quot;@/components/ui/scroll-area\&quot;;\n+ \n+ interface DraftResumeDialogProps {\n+   drafts: DraftSummary[];\n+   open?: boolean;\n+   onOpenChange?: (open: boolean) =&gt; void;\n+   onSelectDraft: (applicationId: string | null) =&gt; Promise&lt;void&gt; | void;\n+   onDeleteDraft: (applicationId: string) =&gt; Promise&lt;void&gt; | void;\n+   triggerLabel?: string;\n+ }\n+ \n+ export function DraftResumeDialog({\n+   drafts,\n+   open,\n+   onOpenChange,\n+   onSelectDraft,\n+   onDeleteDraft,\n+   triggerLabel = \&quot;Resume draft\&quot;,\n+ }: DraftResumeDialogProps) {\n+   const [isOpen, setIsOpen] = useState(open ?? false);\n+   const [resumingId, setResumingId] = useState&lt;string | null&gt;(null);\n+   const [deletingId, setDeletingId] = useState&lt;string | null&gt;(null);\n+   const [error, setError] = useState&lt;string | null&gt;(null);\n+ \n+   const handleOpenChange = useCallback(\n+     (nextOpen: boolean) =&gt; {\n+       setIsOpen(nextOpen);\n+       onOpenChange?.(nextOpen);\n+       if (!nextOpen) {\n+         setError(null);\n+       }\n+     },\n+     [onOpenChange]\n+   );\n+ \n+   const handleSelect = useCallback(\n+     async (applicationId: string | null) =&gt; {\n+       setResumingId(applicationId ?? \&quot;new\&quot;);\n+       setError(null);\n+       try {\n+         await onSelectDraft(applicationId);\n+         handleOpenChange(false);\n+       } catch (err) {\n+         console.error(\&quot;Failed to select draft\&quot;, err);\n+         setError(\n+           err instanceof Error ? err.message : \&quot;Failed to resume draft. Try again.\&quot;\n+         );\n+       } finally {\n+         setResumingId(null);\n+       }\n+     },\n+     [handleOpenChange, onSelectDraft]\n+   );\n+ \n+   const handleDelete = useCallback(\n+     async (applicationId: string) =&gt; {\n+       setDeletingId(applicationId);\n+       setError(null);\n+       try {\n+         await onDeleteDraft(applicationId);\n+       } catch (err) {\n+         console.error(\&quot;Failed to delete draft\&quot;, err);\n+         setError(\n+           err instanceof Error ? err.message : \&quot;Failed to delete draft. Try again.\&quot;\n+         );\n+       } finally {\n+         setDeletingId(null);\n+       }\n+     },\n+     [onDeleteDraft]\n+   );\n+ \n+   if (drafts.length === 0) {\n+     return null;\n+   }\n+ \n+   return (\n+     &lt;Dialog open={isOpen} onOpenChange={handleOpenChange}&gt;\n+       &lt;DialogTrigger asChild&gt;\n+         &lt;Button variant=\&quot;outline\&quot; size=\&quot;sm\&quot;&gt;\n+           {triggerLabel}\n+         &lt;/Button&gt;\n+       &lt;/DialogTrigger&gt;\n+       &lt;DialogContent className=\&quot;sm:max-w-lg\&quot;&gt;\n+         &lt;DialogHeader&gt;\n+           &lt;DialogTitle&gt;Resume a saved draft&lt;/DialogTitle&gt;\n+           &lt;DialogDescription&gt;\n+             Choose an existing draft to continue or start a new submission.\n+           &lt;/DialogDescription&gt;\n+         &lt;/DialogHeader&gt;\n+         &lt;ScrollArea className=\&quot;max-h-80\&quot;&gt;\n+           &lt;div className=\&quot;space-y-3 py-2\&quot;&gt;\n+             {drafts.map((draft) =&gt; {\n+               const isResuming =\n+                 resumingId !== null &amp;&amp;\n+                 (resumingId === draft.applicationId || resumingId === \&quot;new\&quot;);\n+               const isDeleting = deletingId === draft.applicationId;\n+ \n+               return (\n+                 &lt;div\n+                   key={draft.applicationId}\n+                   className=\&quot;rounded-lg border border-border/60 p-4\&quot;\n+                 &gt;\n+                   &lt;div className=\&quot;flex items-center justify-between gap-4\&quot;&gt;\n+                     &lt;div&gt;\n+                       &lt;p className=\&quot;text-sm font-semibold\&quot;&gt;\n+                         Draft #{draft.applicationId.slice(0, 6).toUpperCase()}\n+                       &lt;/p&gt;\n+                       &lt;p className=\&quot;text-xs text-muted-foreground\&quot;&gt;\n+                         Step {draft.currentStep + 1} · Updated{\&quot; \&quot;}\n+                         {formatDistanceToNow(new Date(draft.updatedAt), {\n+                           addSuffix: true,\n+                         })}\n+                       &lt;/p&gt;\n+                     &lt;/div&gt;\n+                     &lt;div className=\&quot;flex items-center gap-2\&quot;&gt;\n+                       &lt;Button\n+                         type=\&quot;button\&quot;\n+                         size=\&quot;sm\&quot;\n+                         onClick={() =&gt; void handleSelect(draft.applicationId)}\n+                         disabled={isDeleting || resumingId !== null}\n+                       &gt;\n+                         {isResuming &amp;&amp; (\n+                           &lt;Loader2 className=\&quot;mr-2 size-3 animate-spin\&quot; /&gt;\n+                         )}\n+                         Resume\n+                       &lt;/Button&gt;\n+                       &lt;Button\n+                         type=\&quot;button\&quot;\n+                         variant=\&quot;ghost\&quot;\n+                         size=\&quot;icon\&quot;\n+                         onClick={() =&gt; void handleDelete(draft.applicationId)}\n+                         disabled={isDeleting || resumingId !== null}\n+                         aria-label=\&quot;Delete draft\&quot;\n+                       &gt;\n+                         {isDeleting ? (\n+                           &lt;Loader2 className=\&quot;size-4 animate-spin\&quot; /&gt;\n+                         ) : (\n+                           &lt;Trash2 className=\&quot;size-4 text-muted-foreground\&quot; /&gt;\n+                         )}\n+                       &lt;/Button&gt;\n+                     &lt;/div&gt;\n+                   &lt;/div&gt;\n+                 &lt;/div&gt;\n+               );\n+             })}\n+           &lt;/div&gt;\n+         &lt;/ScrollArea&gt;\n+         &lt;div className=\&quot;flex flex-col gap-3 border-t border-border/60 pt-4\&quot;&gt;\n+           {error &amp;&amp; &lt;p className=\&quot;text-sm text-red-600\&quot;&gt;{error}&lt;/p&gt;}\n+           &lt;Button\n+             type=\&quot;button\&quot;\n+             variant=\&quot;secondary\&quot;\n+             onClick={() =&gt; void handleSelect(null)}\n+             disabled={resumingId !== null}\n+           &gt;\n+             {resumingId === \&quot;new\&quot; &amp;&amp; (\n+               &lt;Loader2 className=\&quot;mr-2 size-3 animate-spin\&quot; /&gt;\n+             )}\n+             Start new submission\n+           &lt;/Button&gt;\n+         &lt;/div&gt;\n+       &lt;/DialogContent&gt;\n+     &lt;/Dialog&gt;\n+   );\n+ }\n+ &quot;,
        &quot;oldStart&quot;: 1,
        &quot;newStart&quot;: 1,
        &quot;oldLines&quot;: 1,
        &quot;newLines&quot;: 182,
        &quot;linesRemoved&quot;: 1,
        &quot;linesAdded&quot;: 182
      }
    ],
    &quot;editor&quot;: &quot;EDITOR_AI&quot;
  },
  &quot;shouldAutoFixLints&quot;: true,
  &quot;resultForModel&quot;: &quot;Success. Updated the following files:\nM /Users/sahilmehta/supplier-onboarding-simple/components/forms/draft-resume-dialog.tsx&quot;,
  &quot;contentsAfterEdit&quot;: &quot;\&quot;use client\&quot;;\n\nimport { useCallback, useState } from \&quot;react\&quot;;\nimport { formatDistanceToNow } from \&quot;date-fns\&quot;;\nimport { Loader2, Trash2 } from \&quot;lucide-react\&quot;;\nimport type { DraftSummary } from \&quot;@/lib/forms/draft-manager\&quot;;\nimport {\n  Dialog,\n  DialogContent,\n  DialogDescription,\n  DialogHeader,\n  DialogTitle,\n  DialogTrigger,\n} from \&quot;@/components/ui/dialog\&quot;;\nimport { Button } from \&quot;@/components/ui/button\&quot;;\nimport { ScrollArea } from \&quot;@/components/ui/scroll-area\&quot;;\n\ninterface DraftResumeDialogProps {\n  drafts: DraftSummary[];\n  open?: boolean;\n  onOpenChange?: (open: boolean) =&gt; void;\n  onSelectDraft: (applicationId: string | null) =&gt; Promise&lt;void&gt; | void;\n  onDeleteDraft: (applicationId: string) =&gt; Promise&lt;void&gt; | void;\n  triggerLabel?: string;\n}\n\nexport function DraftResumeDialog({\n  drafts,\n  open,\n  onOpenChange,\n  onSelectDraft,\n  onDeleteDraft,\n  triggerLabel = \&quot;Resume draft\&quot;,\n}: DraftResumeDialogProps) {\n  const [isOpen, setIsOpen] = useState(open ?? false);\n  const [resumingId, setResumingId] = useState&lt;string | null&gt;(null);\n  const [deletingId, setDeletingId] = useState&lt;string | null&gt;(null);\n  const [error, setError] = useState&lt;string | null&gt;(null);\n\n  const handleOpenChange = useCallback(\n    (nextOpen: boolean) =&gt; {\n      setIsOpen(nextOpen);\n      onOpenChange?.(nextOpen);\n      if (!nextOpen) {\n        setError(null);\n      }\n    },\n    [onOpenChange]\n  );\n\n  const handleSelect = useCallback(\n    async (applicationId: string | null) =&gt; {\n      setResumingId(applicationId ?? \&quot;new\&quot;);\n      setError(null);\n      try {\n        await onSelectDraft(applicationId);\n        handleOpenChange(false);\n      } catch (err) {\n        console.error(\&quot;Failed to select draft\&quot;, err);\n        setError(\n          err instanceof Error ? err.message : \&quot;Failed to resume draft. Try again.\&quot;\n        );\n      } finally {\n        setResumingId(null);\n      }\n    },\n    [handleOpenChange, onSelectDraft]\n  );\n\n  const handleDelete = useCallback(\n    async (applicationId: string) =&gt; {\n      setDeletingId(applicationId);\n      setError(null);\n      try {\n        await onDeleteDraft(applicationId);\n      } catch (err) {\n        console.error(\&quot;Failed to delete draft\&quot;, err);\n        setError(\n          err instanceof Error ? err.message : \&quot;Failed to delete draft. Try again.\&quot;\n        );\n      } finally {\n        setDeletingId(null);\n      }\n    },\n    [onDeleteDraft]\n  );\n\n  if (drafts.length === 0) {\n    return null;\n  }\n\n  return (\n    &lt;Dialog open={isOpen} onOpenChange={handleOpenChange}&gt;\n      &lt;DialogTrigger asChild&gt;\n        &lt;Button variant=\&quot;outline\&quot; size=\&quot;sm\&quot;&gt;\n          {triggerLabel}\n        &lt;/Button&gt;\n      &lt;/DialogTrigger&gt;\n      &lt;DialogContent className=\&quot;sm:max-w-lg\&quot;&gt;\n        &lt;DialogHeader&gt;\n          &lt;DialogTitle&gt;Resume a saved draft&lt;/DialogTitle&gt;\n          &lt;DialogDescription&gt;\n            Choose an existing draft to continue or start a new submission.\n          &lt;/DialogDescription&gt;\n        &lt;/DialogHeader&gt;\n        &lt;ScrollArea className=\&quot;max-h-80\&quot;&gt;\n          &lt;div className=\&quot;space-y-3 py-2\&quot;&gt;\n            {drafts.map((draft) =&gt; {\n              const isResuming =\n                resumingId !== null &amp;&amp;\n                (resumingId === draft.applicationId || resumingId === \&quot;new\&quot;);\n              const isDeleting = deletingId === draft.applicationId;\n\n              return (\n                &lt;div\n                  key={draft.applicationId}\n                  className=\&quot;rounded-lg border border-border/60 p-4\&quot;\n                &gt;\n                  &lt;div className=\&quot;flex items-center justify-between gap-4\&quot;&gt;\n                    &lt;div&gt;\n                      &lt;p className=\&quot;text-sm font-semibold\&quot;&gt;\n                        Draft #{draft.applicationId.slice(0, 6).toUpperCase()}\n                      &lt;/p&gt;\n                      &lt;p className=\&quot;text-xs text-muted-foreground\&quot;&gt;\n                        Step {draft.currentStep + 1} · Updated{\&quot; \&quot;}\n                        {formatDistanceToNow(new Date(draft.updatedAt), {\n                          addSuffix: true,\n                        })}\n                      &lt;/p&gt;\n                    &lt;/div&gt;\n                    &lt;div className=\&quot;flex items-center gap-2\&quot;&gt;\n                      &lt;Button\n                        type=\&quot;button\&quot;\n                        size=\&quot;sm\&quot;\n                        onClick={() =&gt; void handleSelect(draft.applicationId)}\n                        disabled={isDeleting || resumingId !== null}\n                      &gt;\n                        {isResuming &amp;&amp; (\n                          &lt;Loader2 className=\&quot;mr-2 size-3 animate-spin\&quot; /&gt;\n                        )}\n                        Resume\n                      &lt;/Button&gt;\n                      &lt;Button\n                        type=\&quot;button\&quot;\n                        variant=\&quot;ghost\&quot;\n                        size=\&quot;icon\&quot;\n                        onClick={() =&gt; void handleDelete(draft.applicationId)}\n                        disabled={isDeleting || resumingId !== null}\n                        aria-label=\&quot;Delete draft\&quot;\n                      &gt;\n                        {isDeleting ? (\n                          &lt;Loader2 className=\&quot;size-4 animate-spin\&quot; /&gt;\n                        ) : (\n                          &lt;Trash2 className=\&quot;size-4 text-muted-foreground\&quot; /&gt;\n                        )}\n                      &lt;/Button&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                &lt;/div&gt;\n              );\n            })}\n          &lt;/div&gt;\n        &lt;/ScrollArea&gt;\n        &lt;div className=\&quot;flex flex-col gap-3 border-t border-border/60 pt-4\&quot;&gt;\n          {error &amp;&amp; &lt;p className=\&quot;text-sm text-red-600\&quot;&gt;{error}&lt;/p&gt;}\n          &lt;Button\n            type=\&quot;button\&quot;\n            variant=\&quot;secondary\&quot;\n            onClick={() =&gt; void handleSelect(null)}\n            disabled={resumingId !== null}\n          &gt;\n            {resumingId === \&quot;new\&quot; &amp;&amp; (\n              &lt;Loader2 className=\&quot;mr-2 size-3 animate-spin\&quot; /&gt;\n            )}\n            Start new submission\n          &lt;/Button&gt;\n        &lt;/div&gt;\n      &lt;/DialogContent&gt;\n    &lt;/Dialog&gt;\n  );\n}\n\n&quot;
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Verifying and replacing missing ScrollArea component**</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  &quot;relativeWorkspacePath&quot;: &quot;/Users/sahilmehta/supplier-onboarding-simple/components/forms/draft-resume-dialog.tsx&quot;
}
```
Additional data:

```json
{
  &quot;codeblockId&quot;: &quot;d1456793-28fa-4d44-a6f1-c5ca730c03f0&quot;,
  &quot;reviewData&quot;: {
    &quot;status&quot;: &quot;None&quot;,
    &quot;selectedOption&quot;: &quot;accept&quot;,
    &quot;isShowingInput&quot;: false,
    &quot;firstTimeReviewMode&quot;: false
  }
}
```
Result:

```json
{
  &quot;diff&quot;: {
    &quot;chunks&quot;: [
      {
        &quot;diffString&quot;: &quot;  } from \&quot;@/components/ui/dialog\&quot;;\n  import { Button } from \&quot;@/components/ui/button\&quot;;\n- import { ScrollArea } from \&quot;@/components/ui/scroll-area\&quot;;\n  \n  interface DraftResumeDialogProps {&quot;,
        &quot;oldStart&quot;: 14,
        &quot;newStart&quot;: 14,
        &quot;oldLines&quot;: 5,
        &quot;newLines&quot;: 4,
        &quot;linesRemoved&quot;: 1
      },
      {
        &quot;diffString&quot;: &quot;            &lt;/DialogDescription&gt;\n          &lt;/DialogHeader&gt;\n-         &lt;ScrollArea className=\&quot;max-h-80\&quot;&gt;\n-           &lt;div className=\&quot;space-y-3 py-2\&quot;&gt;\n+         &lt;div className=\&quot;max-h-80 space-y-3 overflow-y-auto py-2 pr-2\&quot;&gt;\n              {drafts.map((draft) =&gt; {\n                const isResuming =&quot;,
        &quot;oldStart&quot;: 104,
        &quot;newStart&quot;: 103,
        &quot;oldLines&quot;: 6,
        &quot;newLines&quot;: 5,
        &quot;linesRemoved&quot;: 2,
        &quot;linesAdded&quot;: 1
      },
      {
        &quot;diffString&quot;: &quot;              })}\n            &lt;/div&gt;\n-         &lt;/ScrollArea&gt;\n+         &lt;/div&gt;\n          &lt;div className=\&quot;flex flex-col gap-3 border-t border-border/60 pt-4\&quot;&gt;\n            {error &amp;&amp; &lt;p className=\&quot;text-sm text-red-600\&quot;&gt;{error}&lt;/p&gt;}&quot;,
        &quot;oldStart&quot;: 161,
        &quot;newStart&quot;: 159,
        &quot;oldLines&quot;: 5,
        &quot;newLines&quot;: 5,
        &quot;linesRemoved&quot;: 1,
        &quot;linesAdded&quot;: 1
      }
    ],
    &quot;editor&quot;: &quot;EDITOR_AI&quot;
  },
  &quot;shouldAutoFixLints&quot;: true,
  &quot;resultForModel&quot;: &quot;Success. Updated the following files:\nM /Users/sahilmehta/supplier-onboarding-simple/components/forms/draft-resume-dialog.tsx&quot;,
  &quot;contentsAfterEdit&quot;: &quot;\&quot;use client\&quot;;\n\nimport { useCallback, useState } from \&quot;react\&quot;;\nimport { formatDistanceToNow } from \&quot;date-fns\&quot;;\nimport { Loader2, Trash2 } from \&quot;lucide-react\&quot;;\nimport type { DraftSummary } from \&quot;@/lib/forms/draft-manager\&quot;;\nimport {\n  Dialog,\n  DialogContent,\n  DialogDescription,\n  DialogHeader,\n  DialogTitle,\n  DialogTrigger,\n} from \&quot;@/components/ui/dialog\&quot;;\nimport { Button } from \&quot;@/components/ui/button\&quot;;\n\ninterface DraftResumeDialogProps {\n  drafts: DraftSummary[];\n  open?: boolean;\n  onOpenChange?: (open: boolean) =&gt; void;\n  onSelectDraft: (applicationId: string | null) =&gt; Promise&lt;void&gt; | void;\n  onDeleteDraft: (applicationId: string) =&gt; Promise&lt;void&gt; | void;\n  triggerLabel?: string;\n}\n\nexport function DraftResumeDialog({\n  drafts,\n  open,\n  onOpenChange,\n  onSelectDraft,\n  onDeleteDraft,\n  triggerLabel = \&quot;Resume draft\&quot;,\n}: DraftResumeDialogProps) {\n  const [isOpen, setIsOpen] = useState(open ?? false);\n  const [resumingId, setResumingId] = useState&lt;string | null&gt;(null);\n  const [deletingId, setDeletingId] = useState&lt;string | null&gt;(null);\n  const [error, setError] = useState&lt;string | null&gt;(null);\n\n  const handleOpenChange = useCallback(\n    (nextOpen: boolean) =&gt; {\n      setIsOpen(nextOpen);\n      onOpenChange?.(nextOpen);\n      if (!nextOpen) {\n        setError(null);\n      }\n    },\n    [onOpenChange]\n  );\n\n  const handleSelect = useCallback(\n    async (applicationId: string | null) =&gt; {\n      setResumingId(applicationId ?? \&quot;new\&quot;);\n      setError(null);\n      try {\n        await onSelectDraft(applicationId);\n        handleOpenChange(false);\n      } catch (err) {\n        console.error(\&quot;Failed to select draft\&quot;, err);\n        setError(\n          err instanceof Error ? err.message : \&quot;Failed to resume draft. Try again.\&quot;\n        );\n      } finally {\n        setResumingId(null);\n      }\n    },\n    [handleOpenChange, onSelectDraft]\n  );\n\n  const handleDelete = useCallback(\n    async (applicationId: string) =&gt; {\n      setDeletingId(applicationId);\n      setError(null);\n      try {\n        await onDeleteDraft(applicationId);\n      } catch (err) {\n        console.error(\&quot;Failed to delete draft\&quot;, err);\n        setError(\n          err instanceof Error ? err.message : \&quot;Failed to delete draft. Try again.\&quot;\n        );\n      } finally {\n        setDeletingId(null);\n      }\n    },\n    [onDeleteDraft]\n  );\n\n  if (drafts.length === 0) {\n    return null;\n  }\n\n  return (\n    &lt;Dialog open={isOpen} onOpenChange={handleOpenChange}&gt;\n      &lt;DialogTrigger asChild&gt;\n        &lt;Button variant=\&quot;outline\&quot; size=\&quot;sm\&quot;&gt;\n          {triggerLabel}\n        &lt;/Button&gt;\n      &lt;/DialogTrigger&gt;\n      &lt;DialogContent className=\&quot;sm:max-w-lg\&quot;&gt;\n        &lt;DialogHeader&gt;\n          &lt;DialogTitle&gt;Resume a saved draft&lt;/DialogTitle&gt;\n          &lt;DialogDescription&gt;\n            Choose an existing draft to continue or start a new submission.\n          &lt;/DialogDescription&gt;\n        &lt;/DialogHeader&gt;\n        &lt;div className=\&quot;max-h-80 space-y-3 overflow-y-auto py-2 pr-2\&quot;&gt;\n            {drafts.map((draft) =&gt; {\n              const isResuming =\n                resumingId !== null &amp;&amp;\n                (resumingId === draft.applicationId || resumingId === \&quot;new\&quot;);\n              const isDeleting = deletingId === draft.applicationId;\n\n              return (\n                &lt;div\n                  key={draft.applicationId}\n                  className=\&quot;rounded-lg border border-border/60 p-4\&quot;\n                &gt;\n                  &lt;div className=\&quot;flex items-center justify-between gap-4\&quot;&gt;\n                    &lt;div&gt;\n                      &lt;p className=\&quot;text-sm font-semibold\&quot;&gt;\n                        Draft #{draft.applicationId.slice(0, 6).toUpperCase()}\n                      &lt;/p&gt;\n                      &lt;p className=\&quot;text-xs text-muted-foreground\&quot;&gt;\n                        Step {draft.currentStep + 1} · Updated{\&quot; \&quot;}\n                        {formatDistanceToNow(new Date(draft.updatedAt), {\n                          addSuffix: true,\n                        })}\n                      &lt;/p&gt;\n                    &lt;/div&gt;\n                    &lt;div className=\&quot;flex items-center gap-2\&quot;&gt;\n                      &lt;Button\n                        type=\&quot;button\&quot;\n                        size=\&quot;sm\&quot;\n                        onClick={() =&gt; void handleSelect(draft.applicationId)}\n                        disabled={isDeleting || resumingId !== null}\n                      &gt;\n                        {isResuming &amp;&amp; (\n                          &lt;Loader2 className=\&quot;mr-2 size-3 animate-spin\&quot; /&gt;\n                        )}\n                        Resume\n                      &lt;/Button&gt;\n                      &lt;Button\n                        type=\&quot;button\&quot;\n                        variant=\&quot;ghost\&quot;\n                        size=\&quot;icon\&quot;\n                        onClick={() =&gt; void handleDelete(draft.applicationId)}\n                        disabled={isDeleting || resumingId !== null}\n                        aria-label=\&quot;Delete draft\&quot;\n                      &gt;\n                        {isDeleting ? (\n                          &lt;Loader2 className=\&quot;size-4 animate-spin\&quot; /&gt;\n                        ) : (\n                          &lt;Trash2 className=\&quot;size-4 text-muted-foreground\&quot; /&gt;\n                        )}\n                      &lt;/Button&gt;\n                    &lt;/div&gt;\n                  &lt;/div&gt;\n                &lt;/div&gt;\n              );\n            })}\n          &lt;/div&gt;\n        &lt;/div&gt;\n        &lt;div className=\&quot;flex flex-col gap-3 border-t border-border/60 pt-4\&quot;&gt;\n          {error &amp;&amp; &lt;p className=\&quot;text-sm text-red-600\&quot;&gt;{error}&lt;/p&gt;}\n          &lt;Button\n            type=\&quot;button\&quot;\n            variant=\&quot;secondary\&quot;\n            onClick={() =&gt; void handleSelect(null)}\n            disabled={resumingId !== null}\n          &gt;\n            {resumingId === \&quot;new\&quot; &amp;&amp; (\n              &lt;Loader2 className=\&quot;mr-2 size-3 animate-spin\&quot; /&gt;\n            )}\n            Start new submission\n          &lt;/Button&gt;\n        &lt;/div&gt;\n      &lt;/DialogContent&gt;\n    &lt;/Dialog&gt;\n  );\n}\n\n&quot;
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Removing unused import**</details></think>

---

The model made no changes to the file.

---

<think><details><summary>Thought Process</summary>
**Verifying line removal**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/sahilmehta/supplier-onboarding-simple/components/forms/draft-resume-dialog.tsx</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Extending form-navigation props**</details></think>

---

The model made no changes to the file.

---

<think><details><summary>Thought Process</summary>
**Reopening file for patching**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/sahilmehta/supplier-onboarding-simple/components/forms/form-navigation.tsx</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Adapting component and file interfaces**

I'm seeing the file already includes new features we haven't implemented yet, so I need to align our `DraftSaveIndicator` component to match the expected props and export the proper `DraftStatus` type to keep things consistent and avoid overwriting user changes. I'll update the component signature and types accordingly.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  &quot;relativeWorkspacePath&quot;: &quot;/Users/sahilmehta/supplier-onboarding-simple/components/forms/draft-save-indicator.tsx&quot;
}
```
Additional data:

```json
{
  &quot;codeblockId&quot;: &quot;9c4bee71-1f63-4f69-8e29-f3753a199383&quot;,
  &quot;reviewData&quot;: {
    &quot;status&quot;: &quot;None&quot;,
    &quot;selectedOption&quot;: &quot;accept&quot;,
    &quot;isShowingInput&quot;: false,
    &quot;firstTimeReviewMode&quot;: false
  }
}
```
Result:

```json
{
  &quot;diff&quot;: {
    &quot;chunks&quot;: [
      {
        &quot;diffString&quot;: &quot;  import { AlertTriangle, Check, Loader2 } from \&quot;lucide-react\&quot;;\n  import type { AutosaveStatus } from \&quot;@/hooks/use-autosave\&quot;;\n+ \n+ export type DraftStatus = AutosaveStatus;\n  \n  interface DraftSaveIndicatorProps {\n-   status: AutosaveStatus;\n+   status: DraftStatus;\n    lastSavedAt?: string;\n-   error?: string;\n+   errorMessage?: string;\n  }\n  \n  export function DraftSaveIndicator({\n    status,\n    lastSavedAt,\n-   error,\n+   errorMessage,\n  }: DraftSaveIndicatorProps) {\n    if (status === \&quot;idle\&quot;) {&quot;,
        &quot;oldStart&quot;: 3,
        &quot;newStart&quot;: 3,
        &quot;oldLines&quot;: 15,
        &quot;newLines&quot;: 17,
        &quot;linesRemoved&quot;: 3,
        &quot;linesAdded&quot;: 5
      },
      {
        &quot;diffString&quot;: &quot;        &lt;div className=\&quot;flex items-center gap-2 text-xs text-red-600\&quot;&gt;\n          &lt;AlertTriangle className=\&quot;size-3\&quot; aria-hidden=\&quot;true\&quot; /&gt;\n-         &lt;span&gt;{error ?? \&quot;Failed to save draft\&quot;}&lt;/span&gt;\n+         &lt;span&gt;{errorMessage ?? \&quot;Failed to save draft\&quot;}&lt;/span&gt;\n        &lt;/div&gt;\n      );&quot;,
        &quot;oldStart&quot;: 32,
        &quot;newStart&quot;: 34,
        &quot;oldLines&quot;: 5,
        &quot;newLines&quot;: 5,
        &quot;linesRemoved&quot;: 1,
        &quot;linesAdded&quot;: 1
      }
    ],
    &quot;editor&quot;: &quot;EDITOR_AI&quot;
  },
  &quot;shouldAutoFixLints&quot;: true,
  &quot;resultForModel&quot;: &quot;Success. Updated the following files:\nM /Users/sahilmehta/supplier-onboarding-simple/components/forms/draft-save-indicator.tsx&quot;,
  &quot;contentsAfterEdit&quot;: &quot;\&quot;use client\&quot;;\n\nimport { AlertTriangle, Check, Loader2 } from \&quot;lucide-react\&quot;;\nimport type { AutosaveStatus } from \&quot;@/hooks/use-autosave\&quot;;\n\nexport type DraftStatus = AutosaveStatus;\n\ninterface DraftSaveIndicatorProps {\n  status: DraftStatus;\n  lastSavedAt?: string;\n  errorMessage?: string;\n}\n\nexport function DraftSaveIndicator({\n  status,\n  lastSavedAt,\n  errorMessage,\n}: DraftSaveIndicatorProps) {\n  if (status === \&quot;idle\&quot;) {\n    return null;\n  }\n\n  if (status === \&quot;saving\&quot;) {\n    return (\n      &lt;div className=\&quot;flex items-center gap-2 text-xs text-muted-foreground\&quot;&gt;\n        &lt;Loader2 className=\&quot;size-3 animate-spin\&quot; aria-hidden=\&quot;true\&quot; /&gt;\n        &lt;span&gt;Saving draft…&lt;/span&gt;\n      &lt;/div&gt;\n    );\n  }\n\n  if (status === \&quot;error\&quot;) {\n    return (\n      &lt;div className=\&quot;flex items-center gap-2 text-xs text-red-600\&quot;&gt;\n        &lt;AlertTriangle className=\&quot;size-3\&quot; aria-hidden=\&quot;true\&quot; /&gt;\n        &lt;span&gt;{errorMessage ?? \&quot;Failed to save draft\&quot;}&lt;/span&gt;\n      &lt;/div&gt;\n    );\n  }\n\n  return (\n    &lt;div className=\&quot;flex items-center gap-2 text-xs text-emerald-600\&quot;&gt;\n      &lt;Check className=\&quot;size-3\&quot; aria-hidden=\&quot;true\&quot; /&gt;\n      &lt;span&gt;\n        Draft saved{\&quot; \&quot;}\n        {lastSavedAt\n          ? new Date(lastSavedAt).toLocaleTimeString([], {\n              hour: \&quot;2-digit\&quot;,\n              minute: \&quot;2-digit\&quot;,\n            })\n          : \&quot;just now\&quot;}\n      &lt;/span&gt;\n    &lt;/div&gt;\n  );\n}\n\&quot;use client\&quot;;\n\nimport { cn } from \&quot;@/lib/utils\&quot;;\nimport { AlertTriangle, CheckCircle2, Loader2, Save } from \&quot;lucide-react\&quot;;\n\nexport type DraftStatus = \&quot;idle\&quot; | \&quot;saving\&quot; | \&quot;success\&quot; | \&quot;error\&quot;;\n\ninterface DraftSaveIndicatorProps {\n  status: DraftStatus;\n  lastSavedAt?: Date | null;\n  errorMessage?: string;\n  className?: string;\n}\n\nexport function DraftSaveIndicator({\n  status,\n  lastSavedAt,\n  errorMessage,\n  className,\n}: DraftSaveIndicatorProps) {\n  let icon = &lt;Save className=\&quot;size-4\&quot; aria-hidden=\&quot;true\&quot; /&gt;;\n  let message = \&quot;Draft not saved yet\&quot;;\n\n  if (status === \&quot;saving\&quot;) {\n    icon = &lt;Loader2 className=\&quot;size-4 animate-spin\&quot; aria-hidden=\&quot;true\&quot; /&gt;;\n    message = \&quot;Saving draft…\&quot;;\n  } else if (status === \&quot;success\&quot; &amp;&amp; lastSavedAt) {\n    icon = &lt;CheckCircle2 className=\&quot;size-4 text-emerald-600\&quot; aria-hidden=\&quot;true\&quot; /&gt;;\n    message = &#96;Draft saved ${lastSavedAt.toLocaleTimeString([], { hour: \&quot;numeric\&quot;, minute: \&quot;2-digit\&quot; })}&#96;;\n  } else if (status === \&quot;error\&quot;) {\n    icon = &lt;AlertTriangle className=\&quot;size-4 text-destructive\&quot; aria-hidden=\&quot;true\&quot; /&gt;;\n    message = errorMessage ?? \&quot;Unable to save draft. Please try again.\&quot;;\n  }\n\n  return (\n    &lt;div\n      className={cn(\n        \&quot;flex items-center gap-2 rounded-xl bg-muted/60 px-3 py-2 text-xs text-muted-foreground\&quot;,\n        status === \&quot;error\&quot; &amp;&amp; \&quot;text-destructive\&quot;,\n        className\n      )}\n      role=\&quot;status\&quot;\n      aria-live=\&quot;polite\&quot;\n    &gt;\n      {icon}\n      &lt;span&gt;{message}&lt;/span&gt;\n    &lt;/div&gt;\n  );\n}\n\n&quot;
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Aligning FormNavigation types and planning DynamicFormWizard update**

I'm ensuring `FormNavigation` handles `lastSavedAt` as a string instead of `Date | null` to match the actual data flow, adjusting types accordingly while keeping existing imports and props intact. Then, I'm focusing on planning a thorough update to `dynamic-form-wizard.tsx`, involving revised imports, expanded props, adapting autosave logic with `useAutosave`, handling field validation state with enhanced `useFormState` (including adding a new action to set field errors individually), and preparing event handlers to coordinate with these changes. There is a lot going on, so I’m breaking down each detail carefully to align new behavior with existing patterns.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  &quot;relativeWorkspacePath&quot;: &quot;/Users/sahilmehta/supplier-onboarding-simple/hooks/use-form-state.ts&quot;
}
```
Additional data:

```json
{
  &quot;codeblockId&quot;: &quot;fc173fd5-67ab-43a1-8c6d-5b590000abbd&quot;,
  &quot;reviewData&quot;: {
    &quot;status&quot;: &quot;None&quot;,
    &quot;selectedOption&quot;: &quot;accept&quot;,
    &quot;isShowingInput&quot;: false,
    &quot;firstTimeReviewMode&quot;: false
  }
}
```
Result:

```json
{
  &quot;diff&quot;: {
    &quot;chunks&quot;: [
      {
        &quot;diffString&quot;: &quot;    | { type: \&quot;SET_STEP_ERRORS\&quot;; fieldKeys: string[]; errors: Record&lt;string, string&gt; }\n    | { type: \&quot;SET_ERRORS\&quot;; errors: Record&lt;string, string&gt; }\n+   | { type: \&quot;SET_FIELD_ERROR\&quot;; fieldKey: string; error?: string }\n    | { type: \&quot;SET_CURRENT_STEP\&quot;; step: number }\n    | { type: \&quot;MARK_STEP_COMPLETE\&quot;; step: number }&quot;,
        &quot;oldStart&quot;: 19,
        &quot;newStart&quot;: 19,
        &quot;oldLines&quot;: 4,
        &quot;newLines&quot;: 5,
        &quot;linesAdded&quot;: 1
      },
      {
        &quot;diffString&quot;: &quot;        };\n      }\n+     case \&quot;SET_FIELD_ERROR\&quot;: {\n+       const nextErrors = { ...state.errors };\n+       if (!action.error) {\n+         delete nextErrors[action.fieldKey];\n+       } else {\n+         nextErrors[action.fieldKey] = action.error;\n+       }\n+       return {\n+         ...state,\n+         errors: nextErrors,\n+       };\n+     }\n      case \&quot;MARK_TOUCHED\&quot;: {\n        if (state.touched.has(action.fieldKey)) {&quot;,
        &quot;oldStart&quot;: 42,
        &quot;newStart&quot;: 43,
        &quot;oldLines&quot;: 4,
        &quot;newLines&quot;: 16,
        &quot;linesAdded&quot;: 12
      },
      {
        &quot;diffString&quot;: &quot;    setStepErrors: (fieldKeys: string[], errors: Record&lt;string, string&gt;) =&gt; void;\n    setErrors: (errors: Record&lt;string, string&gt;) =&gt; void;\n+   setFieldError: (fieldKey: string, error?: string) =&gt; void;\n    goToStep: (step: number) =&gt; void;\n    markStepComplete: (step: number) =&gt; void;&quot;,
        &quot;oldStart&quot;: 157,
        &quot;newStart&quot;: 170,
        &quot;oldLines&quot;: 4,
        &quot;newLines&quot;: 5,
        &quot;linesAdded&quot;: 1
      },
      {
        &quot;diffString&quot;: &quot;      dispatch({ type: \&quot;SET_ERRORS\&quot;, errors });\n    }, []);\n+ \n+   const setFieldError = useCallback((fieldKey: string, error?: string) =&gt; {\n+     dispatch({ type: \&quot;SET_FIELD_ERROR\&quot;, fieldKey, error });\n+   }, []);\n  \n    const goToStep = useCallback((step: number) =&gt; {&quot;,
        &quot;oldStart&quot;: 214,
        &quot;newStart&quot;: 228,
        &quot;oldLines&quot;: 4,
        &quot;newLines&quot;: 8,
        &quot;linesAdded&quot;: 4
      },
      {
        &quot;diffString&quot;: &quot;      setStepErrors,\n      setErrors,\n+     setFieldError,\n+     setFieldError,\n      goToStep,\n      markStepComplete,&quot;,
        &quot;oldStart&quot;: 261,
        &quot;newStart&quot;: 279,
        &quot;oldLines&quot;: 4,
        &quot;newLines&quot;: 6,
        &quot;linesAdded&quot;: 2
      }
    ],
    &quot;editor&quot;: &quot;EDITOR_AI&quot;
  },
  &quot;shouldAutoFixLints&quot;: true,
  &quot;resultForModel&quot;: &quot;Success. Updated the following files:\nM /Users/sahilmehta/supplier-onboarding-simple/hooks/use-form-state.ts&quot;,
  &quot;contentsAfterEdit&quot;: &quot;\&quot;use client\&quot;;\n\nimport { useCallback, useMemo, useReducer } from \&quot;react\&quot;;\nimport type { FormConfigWithFields } from \&quot;@/lib/forms/types\&quot;;\nimport {\n  createInitialFormState,\n  type FormState,\n} from \&quot;@/lib/forms/form-state\&quot;;\nimport {\n  getStepFieldKeys,\n  validateStep,\n  type StepValidationResult,\n} from \&quot;@/lib/forms/form-validator\&quot;;\n\ntype FormStateAction =\n  | { type: \&quot;SET_FIELD_VALUE\&quot;; fieldKey: string; value: unknown }\n  | { type: \&quot;MARK_TOUCHED\&quot;; fieldKey: string }\n  | { type: \&quot;MARK_TOUCHED_FIELDS\&quot;; fieldKeys: string[] }\n  | { type: \&quot;SET_STEP_ERRORS\&quot;; fieldKeys: string[]; errors: Record&lt;string, string&gt; }\n  | { type: \&quot;SET_ERRORS\&quot;; errors: Record&lt;string, string&gt; }\n  | { type: \&quot;SET_FIELD_ERROR\&quot;; fieldKey: string; error?: string }\n  | { type: \&quot;SET_CURRENT_STEP\&quot;; step: number }\n  | { type: \&quot;MARK_STEP_COMPLETE\&quot;; step: number }\n  | { type: \&quot;SET_SUBMITTING\&quot;; value: boolean }\n  | { type: \&quot;SET_DIRTY\&quot;; value: boolean };\n\nfunction reducer(state: FormState, action: FormStateAction): FormState {\n  switch (action.type) {\n    case \&quot;SET_FIELD_VALUE\&quot;: {\n      const nextValue = action.value;\n      const hasChanged = state.formData[action.fieldKey] !== nextValue;\n      if (!hasChanged) {\n        return state;\n      }\n\n      return {\n        ...state,\n        formData: {\n          ...state.formData,\n          [action.fieldKey]: nextValue,\n        },\n        isDirty: true,\n      };\n    }\n    case \&quot;SET_FIELD_ERROR\&quot;: {\n      const nextErrors = { ...state.errors };\n      if (!action.error) {\n        delete nextErrors[action.fieldKey];\n      } else {\n        nextErrors[action.fieldKey] = action.error;\n      }\n      return {\n        ...state,\n        errors: nextErrors,\n      };\n    }\n    case \&quot;MARK_TOUCHED\&quot;: {\n      if (state.touched.has(action.fieldKey)) {\n        return state;\n      }\n      const touched = new Set(state.touched);\n      touched.add(action.fieldKey);\n      return {\n        ...state,\n        touched,\n      };\n    }\n    case \&quot;MARK_TOUCHED_FIELDS\&quot;: {\n      if (action.fieldKeys.length === 0) {\n        return state;\n      }\n      const touched = new Set(state.touched);\n      let modified = false;\n      action.fieldKeys.forEach((key) =&gt; {\n        if (!touched.has(key)) {\n          touched.add(key);\n          modified = true;\n        }\n      });\n      if (!modified) {\n        return state;\n      }\n      return {\n        ...state,\n        touched,\n      };\n    }\n    case \&quot;SET_STEP_ERRORS\&quot;: {\n      const nextErrors = { ...state.errors };\n      const fieldSet = new Set(action.fieldKeys);\n\n      // Remove stale errors for this step\n      fieldSet.forEach((fieldKey) =&gt; {\n        if (!(fieldKey in action.errors)) {\n          delete nextErrors[fieldKey];\n        }\n      });\n\n      // Apply new errors\n      Object.entries(action.errors).forEach(([fieldKey, message]) =&gt; {\n        nextErrors[fieldKey] = message;\n      });\n\n      return {\n        ...state,\n        errors: nextErrors,\n      };\n    }\n    case \&quot;SET_ERRORS\&quot;: {\n      return {\n        ...state,\n        errors: action.errors,\n      };\n    }\n    case \&quot;SET_CURRENT_STEP\&quot;: {\n      if (state.currentStep === action.step) {\n        return state;\n      }\n      return {\n        ...state,\n        currentStep: action.step,\n      };\n    }\n    case \&quot;MARK_STEP_COMPLETE\&quot;: {\n      if (state.completedSteps.has(action.step)) {\n        return state;\n      }\n      const completedSteps = new Set(state.completedSteps);\n      completedSteps.add(action.step);\n      return {\n        ...state,\n        completedSteps,\n      };\n    }\n    case \&quot;SET_SUBMITTING\&quot;: {\n      if (state.isSubmitting === action.value) {\n        return state;\n      }\n      return {\n        ...state,\n        isSubmitting: action.value,\n      };\n    }\n    case \&quot;SET_DIRTY\&quot;: {\n      if (state.isDirty === action.value) {\n        return state;\n      }\n      return {\n        ...state,\n        isDirty: action.value,\n      };\n    }\n    default:\n      return state;\n  }\n}\n\nexport interface UseFormStateOptions {\n  formConfig: FormConfigWithFields;\n  initialData?: Record&lt;string, unknown&gt;;\n  initialStep?: number;\n}\n\nexport interface UseFormStateReturn {\n  state: FormState;\n  touchedMap: Record&lt;string, boolean&gt;;\n  setFieldValue: (fieldKey: string, value: unknown) =&gt; void;\n  markFieldTouched: (fieldKey: string) =&gt; void;\n  markFieldsTouched: (fieldKeys: string[]) =&gt; void;\n  setStepErrors: (fieldKeys: string[], errors: Record&lt;string, string&gt;) =&gt; void;\n  setErrors: (errors: Record&lt;string, string&gt;) =&gt; void;\n  setFieldError: (fieldKey: string, error?: string) =&gt; void;\n  goToStep: (step: number) =&gt; void;\n  markStepComplete: (step: number) =&gt; void;\n  setIsSubmitting: (value: boolean) =&gt; void;\n  markClean: () =&gt; void;\n  validateStepAt: (\n    stepIndex: number\n  ) =&gt; StepValidationResult &amp; { fieldKeys: string[] };\n  validateAndCommitStep: (\n    stepIndex: number\n  ) =&gt; StepValidationResult &amp; { fieldKeys: string[] };\n}\n\nexport function useFormState({\n  formConfig,\n  initialData,\n  initialStep = 0,\n}: UseFormStateOptions): UseFormStateReturn {\n  const [state, dispatch] = useReducer(\n    reducer,\n    undefined,\n    () =&gt; createInitialFormState(initialData ?? {}, initialStep)\n  );\n\n  const touchedMap = useMemo(() =&gt; {\n    const result: Record&lt;string, boolean&gt; = {};\n    state.touched.forEach((key) =&gt; {\n      result[key] = true;\n    });\n    return result;\n  }, [state.touched]);\n\n  const setFieldValue = useCallback((fieldKey: string, value: unknown) =&gt; {\n    dispatch({ type: \&quot;SET_FIELD_VALUE\&quot;, fieldKey, value });\n  }, []);\n\n  const markFieldTouched = useCallback((fieldKey: string) =&gt; {\n    dispatch({ type: \&quot;MARK_TOUCHED\&quot;, fieldKey });\n  }, []);\n\n  const markFieldsTouched = useCallback((fieldKeys: string[]) =&gt; {\n    dispatch({ type: \&quot;MARK_TOUCHED_FIELDS\&quot;, fieldKeys });\n  }, []);\n\n  const setStepErrors = useCallback(\n    (fieldKeys: string[], errors: Record&lt;string, string&gt;) =&gt; {\n      dispatch({\n        type: \&quot;SET_STEP_ERRORS\&quot;,\n        fieldKeys,\n        errors,\n      });\n    },\n    []\n  );\n\n  const setErrors = useCallback((errors: Record&lt;string, string&gt;) =&gt; {\n    dispatch({ type: \&quot;SET_ERRORS\&quot;, errors });\n  }, []);\n\n  const setFieldError = useCallback((fieldKey: string, error?: string) =&gt; {\n    dispatch({ type: \&quot;SET_FIELD_ERROR\&quot;, fieldKey, error });\n  }, []);\n\n  const goToStep = useCallback((step: number) =&gt; {\n    dispatch({ type: \&quot;SET_CURRENT_STEP\&quot;, step });\n  }, []);\n\n  const markStepComplete = useCallback((step: number) =&gt; {\n    dispatch({ type: \&quot;MARK_STEP_COMPLETE\&quot;, step });\n  }, []);\n\n  const setIsSubmitting = useCallback((value: boolean) =&gt; {\n    dispatch({ type: \&quot;SET_SUBMITTING\&quot;, value });\n  }, []);\n\n  const markClean = useCallback(() =&gt; {\n    dispatch({ type: \&quot;SET_DIRTY\&quot;, value: false });\n  }, []);\n\n  const validateStepAt = useCallback(\n    (stepIndex: number) =&gt; {\n      const result = validateStep(stepIndex, state.formData, formConfig);\n      const fieldKeys = getStepFieldKeys(stepIndex, formConfig);\n      return {\n        ...result,\n        fieldKeys,\n      };\n    },\n    [formConfig, state.formData]\n  );\n\n  const validateAndCommitStep = useCallback(\n    (stepIndex: number) =&gt; {\n      const validation = validateStepAt(stepIndex);\n      markFieldsTouched(validation.fieldKeys);\n      setStepErrors(validation.fieldKeys, validation.errors);\n      return validation;\n    },\n    [markFieldsTouched, setStepErrors, validateStepAt]\n  );\n\n  return {\n    state,\n    touchedMap,\n    setFieldValue,\n    markFieldTouched,\n    markFieldsTouched,\n    setStepErrors,\n    setErrors,\n    setFieldError,\n    setFieldError,\n    goToStep,\n    markStepComplete,\n    setIsSubmitting,\n    markClean,\n    validateStepAt,\n    validateAndCommitStep,\n  };\n}\n\n&quot;
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Adding new property to return object**</details></think>

---

<tool-use data-tool-type="grep" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "return \{" in "/Users/sahilmehta/supplier-onboarding-simple/hooks/use-form-state.ts" • 12 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `hooks/use-form-state.ts` | `return \{` | L36 |
| `hooks/use-form-state.ts` | `return \{` | L52 |
| `hooks/use-form-state.ts` | `return \{` | L63 |
| `hooks/use-form-state.ts` | `return \{` | L83 |
| `hooks/use-form-state.ts` | `return \{` | L104 |
| `hooks/use-form-state.ts` | `return \{` | L110 |
| `hooks/use-form-state.ts` | `return \{` | L119 |
| `hooks/use-form-state.ts` | `return \{` | L130 |
| `hooks/use-form-state.ts` | `return \{` | L139 |
| `hooks/use-form-state.ts` | `return \{` | L148 |
| `hooks/use-form-state.ts` | `return \{` | L255 |
| `hooks/use-form-state.ts` | `return \{` | L273 |


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Checking return statement for setFieldError**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/sahilmehta/supplier-onboarding-simple/hooks/use-form-state.ts</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Removing duplicate setFieldError return**</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  &quot;relativeWorkspacePath&quot;: &quot;/Users/sahilmehta/supplier-onboarding-simple/hooks/use-form-state.ts&quot;
}
```
Additional data:

```json
{
  &quot;codeblockId&quot;: &quot;f2237e4b-4d43-4ba6-a0ce-f3ae2759b125&quot;,
  &quot;reviewData&quot;: {
    &quot;status&quot;: &quot;None&quot;,
    &quot;selectedOption&quot;: &quot;accept&quot;,
    &quot;isShowingInput&quot;: false,
    &quot;firstTimeReviewMode&quot;: false
  }
}
```
Result:

```json
{
  &quot;diff&quot;: {
    &quot;chunks&quot;: [
      {
        &quot;diffString&quot;: &quot;      setStepErrors,\n      setErrors,\n-     setFieldError,\n      setFieldError,\n      goToStep,&quot;,
        &quot;oldStart&quot;: 279,
        &quot;newStart&quot;: 279,
        &quot;oldLines&quot;: 5,
        &quot;newLines&quot;: 4,
        &quot;linesRemoved&quot;: 1
      }
    ],
    &quot;editor&quot;: &quot;EDITOR_AI&quot;
  },
  &quot;shouldAutoFixLints&quot;: true,
  &quot;resultForModel&quot;: &quot;Success. Updated the following files:\nM /Users/sahilmehta/supplier-onboarding-simple/hooks/use-form-state.ts&quot;,
  &quot;contentsAfterEdit&quot;: &quot;\&quot;use client\&quot;;\n\nimport { useCallback, useMemo, useReducer } from \&quot;react\&quot;;\nimport type { FormConfigWithFields } from \&quot;@/lib/forms/types\&quot;;\nimport {\n  createInitialFormState,\n  type FormState,\n} from \&quot;@/lib/forms/form-state\&quot;;\nimport {\n  getStepFieldKeys,\n  validateStep,\n  type StepValidationResult,\n} from \&quot;@/lib/forms/form-validator\&quot;;\n\ntype FormStateAction =\n  | { type: \&quot;SET_FIELD_VALUE\&quot;; fieldKey: string; value: unknown }\n  | { type: \&quot;MARK_TOUCHED\&quot;; fieldKey: string }\n  | { type: \&quot;MARK_TOUCHED_FIELDS\&quot;; fieldKeys: string[] }\n  | { type: \&quot;SET_STEP_ERRORS\&quot;; fieldKeys: string[]; errors: Record&lt;string, string&gt; }\n  | { type: \&quot;SET_ERRORS\&quot;; errors: Record&lt;string, string&gt; }\n  | { type: \&quot;SET_FIELD_ERROR\&quot;; fieldKey: string; error?: string }\n  | { type: \&quot;SET_CURRENT_STEP\&quot;; step: number }\n  | { type: \&quot;MARK_STEP_COMPLETE\&quot;; step: number }\n  | { type: \&quot;SET_SUBMITTING\&quot;; value: boolean }\n  | { type: \&quot;SET_DIRTY\&quot;; value: boolean };\n\nfunction reducer(state: FormState, action: FormStateAction): FormState {\n  switch (action.type) {\n    case \&quot;SET_FIELD_VALUE\&quot;: {\n      const nextValue = action.value;\n      const hasChanged = state.formData[action.fieldKey] !== nextValue;\n      if (!hasChanged) {\n        return state;\n      }\n\n      return {\n        ...state,\n        formData: {\n          ...state.formData,\n          [action.fieldKey]: nextValue,\n        },\n        isDirty: true,\n      };\n    }\n    case \&quot;SET_FIELD_ERROR\&quot;: {\n      const nextErrors = { ...state.errors };\n      if (!action.error) {\n        delete nextErrors[action.fieldKey];\n      } else {\n        nextErrors[action.fieldKey] = action.error;\n      }\n      return {\n        ...state,\n        errors: nextErrors,\n      };\n    }\n    case \&quot;MARK_TOUCHED\&quot;: {\n      if (state.touched.has(action.fieldKey)) {\n        return state;\n      }\n      const touched = new Set(state.touched);\n      touched.add(action.fieldKey);\n      return {\n        ...state,\n        touched,\n      };\n    }\n    case \&quot;MARK_TOUCHED_FIELDS\&quot;: {\n      if (action.fieldKeys.length === 0) {\n        return state;\n      }\n      const touched = new Set(state.touched);\n      let modified = false;\n      action.fieldKeys.forEach((key) =&gt; {\n        if (!touched.has(key)) {\n          touched.add(key);\n          modified = true;\n        }\n      });\n      if (!modified) {\n        return state;\n      }\n      return {\n        ...state,\n        touched,\n      };\n    }\n    case \&quot;SET_STEP_ERRORS\&quot;: {\n      const nextErrors = { ...state.errors };\n      const fieldSet = new Set(action.fieldKeys);\n\n      // Remove stale errors for this step\n      fieldSet.forEach((fieldKey) =&gt; {\n        if (!(fieldKey in action.errors)) {\n          delete nextErrors[fieldKey];\n        }\n      });\n\n      // Apply new errors\n      Object.entries(action.errors).forEach(([fieldKey, message]) =&gt; {\n        nextErrors[fieldKey] = message;\n      });\n\n      return {\n        ...state,\n        errors: nextErrors,\n      };\n    }\n    case \&quot;SET_ERRORS\&quot;: {\n      return {\n        ...state,\n        errors: action.errors,\n      };\n    }\n    case \&quot;SET_CURRENT_STEP\&quot;: {\n      if (state.currentStep === action.step) {\n        return state;\n      }\n      return {\n        ...state,\n        currentStep: action.step,\n      };\n    }\n    case \&quot;MARK_STEP_COMPLETE\&quot;: {\n      if (state.completedSteps.has(action.step)) {\n        return state;\n      }\n      const completedSteps = new Set(state.completedSteps);\n      completedSteps.add(action.step);\n      return {\n        ...state,\n        completedSteps,\n      };\n    }\n    case \&quot;SET_SUBMITTING\&quot;: {\n      if (state.isSubmitting === action.value) {\n        return state;\n      }\n      return {\n        ...state,\n        isSubmitting: action.value,\n      };\n    }\n    case \&quot;SET_DIRTY\&quot;: {\n      if (state.isDirty === action.value) {\n        return state;\n      }\n      return {\n        ...state,\n        isDirty: action.value,\n      };\n    }\n    default:\n      return state;\n  }\n}\n\nexport interface UseFormStateOptions {\n  formConfig: FormConfigWithFields;\n  initialData?: Record&lt;string, unknown&gt;;\n  initialStep?: number;\n}\n\nexport interface UseFormStateReturn {\n  state: FormState;\n  touchedMap: Record&lt;string, boolean&gt;;\n  setFieldValue: (fieldKey: string, value: unknown) =&gt; void;\n  markFieldTouched: (fieldKey: string) =&gt; void;\n  markFieldsTouched: (fieldKeys: string[]) =&gt; void;\n  setStepErrors: (fieldKeys: string[], errors: Record&lt;string, string&gt;) =&gt; void;\n  setErrors: (errors: Record&lt;string, string&gt;) =&gt; void;\n  setFieldError: (fieldKey: string, error?: string) =&gt; void;\n  goToStep: (step: number) =&gt; void;\n  markStepComplete: (step: number) =&gt; void;\n  setIsSubmitting: (value: boolean) =&gt; void;\n  markClean: () =&gt; void;\n  validateStepAt: (\n    stepIndex: number\n  ) =&gt; StepValidationResult &amp; { fieldKeys: string[] };\n  validateAndCommitStep: (\n    stepIndex: number\n  ) =&gt; StepValidationResult &amp; { fieldKeys: string[] };\n}\n\nexport function useFormState({\n  formConfig,\n  initialData,\n  initialStep = 0,\n}: UseFormStateOptions): UseFormStateReturn {\n  const [state, dispatch] = useReducer(\n    reducer,\n    undefined,\n    () =&gt; createInitialFormState(initialData ?? {}, initialStep)\n  );\n\n  const touchedMap = useMemo(() =&gt; {\n    const result: Record&lt;string, boolean&gt; = {};\n    state.touched.forEach((key) =&gt; {\n      result[key] = true;\n    });\n    return result;\n  }, [state.touched]);\n\n  const setFieldValue = useCallback((fieldKey: string, value: unknown) =&gt; {\n    dispatch({ type: \&quot;SET_FIELD_VALUE\&quot;, fieldKey, value });\n  }, []);\n\n  const markFieldTouched = useCallback((fieldKey: string) =&gt; {\n    dispatch({ type: \&quot;MARK_TOUCHED\&quot;, fieldKey });\n  }, []);\n\n  const markFieldsTouched = useCallback((fieldKeys: string[]) =&gt; {\n    dispatch({ type: \&quot;MARK_TOUCHED_FIELDS\&quot;, fieldKeys });\n  }, []);\n\n  const setStepErrors = useCallback(\n    (fieldKeys: string[], errors: Record&lt;string, string&gt;) =&gt; {\n      dispatch({\n        type: \&quot;SET_STEP_ERRORS\&quot;,\n        fieldKeys,\n        errors,\n      });\n    },\n    []\n  );\n\n  const setErrors = useCallback((errors: Record&lt;string, string&gt;) =&gt; {\n    dispatch({ type: \&quot;SET_ERRORS\&quot;, errors });\n  }, []);\n\n  const setFieldError = useCallback((fieldKey: string, error?: string) =&gt; {\n    dispatch({ type: \&quot;SET_FIELD_ERROR\&quot;, fieldKey, error });\n  }, []);\n\n  const goToStep = useCallback((step: number) =&gt; {\n    dispatch({ type: \&quot;SET_CURRENT_STEP\&quot;, step });\n  }, []);\n\n  const markStepComplete = useCallback((step: number) =&gt; {\n    dispatch({ type: \&quot;MARK_STEP_COMPLETE\&quot;, step });\n  }, []);\n\n  const setIsSubmitting = useCallback((value: boolean) =&gt; {\n    dispatch({ type: \&quot;SET_SUBMITTING\&quot;, value });\n  }, []);\n\n  const markClean = useCallback(() =&gt; {\n    dispatch({ type: \&quot;SET_DIRTY\&quot;, value: false });\n  }, []);\n\n  const validateStepAt = useCallback(\n    (stepIndex: number) =&gt; {\n      const result = validateStep(stepIndex, state.formData, formConfig);\n      const fieldKeys = getStepFieldKeys(stepIndex, formConfig);\n      return {\n        ...result,\n        fieldKeys,\n      };\n    },\n    [formConfig, state.formData]\n  );\n\n  const validateAndCommitStep = useCallback(\n    (stepIndex: number) =&gt; {\n      const validation = validateStepAt(stepIndex);\n      markFieldsTouched(validation.fieldKeys);\n      setStepErrors(validation.fieldKeys, validation.errors);\n      return validation;\n    },\n    [markFieldsTouched, setStepErrors, validateStepAt]\n  );\n\n  return {\n    state,\n    touchedMap,\n    setFieldValue,\n    markFieldTouched,\n    markFieldsTouched,\n    setStepErrors,\n    setErrors,\n    setFieldError,\n    goToStep,\n    markStepComplete,\n    setIsSubmitting,\n    markClean,\n    validateStepAt,\n    validateAndCommitStep,\n  };\n}\n\n&quot;
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Planning comprehensive rewrite of DynamicFormWizard**

I'm mapping out a full rewrite of DynamicFormWizard to incorporate complex state management, validation debouncing, autosave integration, step navigation, and error handling. Since changes are extensive, I'll recreate the file from scratch, ensuring latest form schema usage, touched field tracking, and syncing with autosave and navigation components. This approach should keep logic clear while carefully handling async updates and UI feedback.</details></think>

---

The model made no changes to the file.

---

<think><details><summary>Thought Process</summary>
**Considering full file replacement strategy**</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  &quot;relativeWorkspacePath&quot;: &quot;/Users/sahilmehta/supplier-onboarding-simple/components/forms/dynamic-form-wizard.tsx&quot;
}
```
Additional data:

```json
{
  &quot;codeblockId&quot;: &quot;41d20d4e-4374-41a7-9168-665d1f1a690c&quot;,
  &quot;reviewData&quot;: {
    &quot;status&quot;: &quot;None&quot;,
    &quot;selectedOption&quot;: &quot;accept&quot;,
    &quot;isShowingInput&quot;: false,
    &quot;firstTimeReviewMode&quot;: false
  }
}
```
Result:

```json
{
  &quot;diff&quot;: {
    &quot;editor&quot;: &quot;EDITOR_AI&quot;
  },
  &quot;shouldAutoFixLints&quot;: true,
  &quot;resultForModel&quot;: &quot;Success. Updated the following files:\nM /Users/sahilmehta/supplier-onboarding-simple/components/forms/dynamic-form-wizard.tsx&quot;,
  &quot;contentsAfterEdit&quot;: &quot;\&quot;use client\&quot;;\n\nimport { useState, useCallback, useRef, useEffect } from \&quot;react\&quot;;\nimport type { FormConfigWithFields } from \&quot;@/lib/forms/types\&quot;;\nimport { validateStep, getStepFieldKeys } from \&quot;@/lib/forms/form-validator\&quot;;\nimport { buildFormSchema } from \&quot;@/lib/form-schema\&quot;;\nimport { StepIndicator } from \&quot;./step-indicator\&quot;;\nimport { FormStep } from \&quot;./form-step\&quot;;\nimport { FormNavigation } from \&quot;./form-navigation\&quot;;\nimport { FormErrorSummary } from \&quot;./form-error-summary\&quot;;\nimport { usePrefersReducedMotion } from \&quot;@/hooks/use-prefers-reduced-motion\&quot;;\nimport { useToast } from \&quot;@/components/ui/use-toast\&quot;;\nimport { cn } from \&quot;@/lib/utils\&quot;;\nimport type { DraftStatus } from \&quot;./draft-save-indicator\&quot;;\n\ninterface DynamicFormWizardProps {\n  formConfig: FormConfigWithFields;\n  initialData?: Record&lt;string, unknown&gt;;\n  onStepChange?: (stepIndex: number) =&gt; void;\n  onComplete?: (formData: Record&lt;string, unknown&gt;) =&gt; void;\n  onSaveDraft?: (formData: Record&lt;string, unknown&gt;) =&gt; void;\n}\n\nexport function DynamicFormWizard({\n  formConfig,\n  initialData = {},\n  onStepChange,\n  onComplete,\n  onSaveDraft,\n}: DynamicFormWizardProps) {\n  const sortedSections = [...formConfig.sections].sort(\n    (a, b) =&gt; a.order - b.order\n  );\n\n  const [currentStep, setCurrentStep] = useState(0);\n  const [formData, setFormData] = useState&lt;Record&lt;string, unknown&gt;&gt;(\n    initialData\n  );\n  const [completedSteps, setCompletedSteps] = useState&lt;Set&lt;number&gt;&gt;(\n    new Set()\n  );\n  const [errors, setErrors] = useState&lt;Record&lt;string, string&gt;&gt;({});\n  const [touched, setTouched] = useState&lt;Record&lt;string, boolean&gt;&gt;({});\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  const [isSavingDraft, setIsSavingDraft] = useState(false);\n  const [draftStatus, setDraftStatus] = useState&lt;DraftStatus&gt;(\&quot;idle\&quot;);\n  const [draftError, setDraftError] = useState&lt;string | null&gt;(null);\n  const [lastSavedAt, setLastSavedAt] = useState&lt;Date | null&gt;(null);\n  const [liveMessage, setLiveMessage] = useState(\&quot;\&quot;);\n  const validationTimersRef = useRef&lt;Record&lt;string, NodeJS.Timeout&gt;&gt;({});\n  const formSchemaRef = useRef(buildFormSchema(formConfig));\n  const prefersReducedMotion = usePrefersReducedMotion();\n  const { toast } = useToast();\n\n  const totalSteps = sortedSections.length;\n  const currentSection = sortedSections[currentStep];\n  const isFirstStep = currentStep === 0;\n  const isLastStep = currentStep === totalSteps - 1;\n\n  // Rebuild schema if form config changes\n  useEffect(() =&gt; {\n    formSchemaRef.current = buildFormSchema(formConfig);\n  }, [formConfig]);\n\n  /**\n   * Validate a single field with debouncing\n   */\n  const validateField = useCallback(\n    (fieldKey: string, value: unknown, immediate = false) =&gt; {\n      // Clear existing timer for this field\n      if (validationTimersRef.current[fieldKey]) {\n        clearTimeout(validationTimersRef.current[fieldKey]);\n      }\n\n      const performValidation = () =&gt; {\n        const fieldSchema = formSchemaRef.current.shape[fieldKey];\n        if (!fieldSchema) {\n          return;\n        }\n\n        try {\n          fieldSchema.parse(value);\n          // Clear error if validation passes\n          setErrors((prev) =&gt; {\n            const next = { ...prev };\n            delete next[fieldKey];\n            return next;\n          });\n        } catch (error) {\n          if (error &amp;&amp; typeof error === \&quot;object\&quot; &amp;&amp; \&quot;issues\&quot; in error) {\n            const zodError = error as { issues: Array&lt;{ message: string }&gt; };\n            const firstIssue = zodError.issues[0];\n            if (firstIssue) {\n              setErrors((prev) =&gt; ({\n                ...prev,\n                [fieldKey]: firstIssue.message,\n              }));\n            }\n          } else if (error instanceof Error) {\n            setErrors((prev) =&gt; ({\n              ...prev,\n              [fieldKey]: error.message,\n            }));\n          }\n        }\n      };\n\n      if (immediate) {\n        performValidation();\n      } else {\n        // Debounce validation on change (300ms)\n        validationTimersRef.current[fieldKey] = setTimeout(performValidation, 300);\n      }\n    },\n    []\n  );\n\n  const handleFieldChange = useCallback(\n    (fieldKey: string, value: unknown) =&gt; {\n      setFormData((prev) =&gt; ({\n        ...prev,\n        [fieldKey]: value,\n      }));\n\n      // Validate on change with debounce (only if field has been touched)\n      if (touched[fieldKey]) {\n        validateField(fieldKey, value, false);\n      }\n    },\n    [touched, validateField]\n  );\n\n  const handleFieldBlur = useCallback(\n    (fieldKey: string) =&gt; {\n      setTouched((prev) =&gt; ({\n        ...prev,\n        [fieldKey]: true,\n      }));\n\n      // Validate immediately on blur\n      const value = formData[fieldKey];\n      validateField(fieldKey, value, true);\n    },\n    [formData, validateField]\n  );\n\n  /**\n   * Validate current step using the validation utilities\n   */\n  const validateCurrentStep = useCallback((): boolean =&gt; {\n    const stepResult = validateStep(currentStep, formData, formConfig);\n\n    if (!stepResult.isValid) {\n      // Update errors for current step fields only\n      const stepFieldKeys = getStepFieldKeys(currentStep, formConfig);\n      setErrors((prev) =&gt; {\n        const next = { ...prev };\n        // Clear errors for fields not in current step\n        stepFieldKeys.forEach((key) =&gt; {\n          if (stepResult.errors[key]) {\n            next[key] = stepResult.errors[key];\n          } else {\n            delete next[key];\n          }\n        });\n        return next;\n      });\n\n      // Mark all fields in step as touched\n      setTouched((prev) =&gt; {\n        const next = { ...prev };\n        stepFieldKeys.forEach((key) =&gt; {\n          next[key] = true;\n        });\n        return next;\n      });\n\n      // Focus first error field\n      if (stepResult.firstErrorField) {\n        // Find the field by key to get its ID\n        const errorField = currentSection.fields.find(\n          (f) =&gt; f.key === stepResult.firstErrorField\n        );\n        if (errorField) {\n          // Field components use &#96;field-${field.id}&#96; as the ID\n          const fieldElement = document.getElementById(&#96;field-${errorField.id}&#96;);\n          if (fieldElement) {\n            fieldElement.focus();\n            fieldElement.scrollIntoView({ behavior: \&quot;smooth\&quot;, block: \&quot;center\&quot; });\n          }\n        }\n      }\n    }\n\n    return stepResult.isValid;\n  }, [currentStep, formData, formConfig, currentSection]);\n\n  const handleNext = useCallback(async () =&gt; {\n    if (isSubmitting) {\n      return;\n    }\n\n    const isStepValid = validateCurrentStep();\n    if (!isStepValid) {\n      toast({\n        variant: \&quot;destructive\&quot;,\n        title: \&quot;Please fix validation errors\&quot;,\n        description: \&quot;Resolve highlighted fields before continuing.\&quot;,\n      });\n      return;\n    }\n\n    setCompletedSteps((prev) =&gt; new Set(prev).add(currentStep));\n\n    if (isLastStep) {\n      if (!onComplete) {\n        return;\n      }\n      try {\n        setIsSubmitting(true);\n        await onComplete(formData);\n        toast({\n          title: \&quot;Form submitted\&quot;,\n          description: \&quot;Thanks! We received your information.\&quot;,\n        });\n      } catch (error) {\n        toast({\n          variant: \&quot;destructive\&quot;,\n          title: \&quot;Submission failed\&quot;,\n          description:\n            error instanceof Error\n              ? error.message\n              : \&quot;Something went wrong while submitting. Please try again.\&quot;,\n        });\n      } finally {\n        setIsSubmitting(false);\n      }\n    } else {\n      const nextStep = currentStep + 1;\n      setCurrentStep(nextStep);\n      onStepChange?.(nextStep);\n    }\n  }, [\n    currentStep,\n    formData,\n    isLastStep,\n    isSubmitting,\n    onComplete,\n    onStepChange,\n    toast,\n    validateCurrentStep,\n  ]);\n\n  const handlePrevious = useCallback(() =&gt; {\n    if (!isFirstStep) {\n      const prevStep = currentStep - 1;\n      setCurrentStep(prevStep);\n      onStepChange?.(prevStep);\n    }\n  }, [currentStep, isFirstStep, onStepChange]);\n\n  const handleStepClick = useCallback(\n    (stepIndex: number) =&gt; {\n      // Validate current step before allowing navigation\n      if (stepIndex !== currentStep) {\n        if (!validateCurrentStep()) {\n          return; // Don&#39;t allow navigation if current step is invalid\n        }\n      }\n\n      // Allow navigation to completed steps or the next step\n      if (completedSteps.has(stepIndex) || stepIndex === currentStep + 1) {\n        setCurrentStep(stepIndex);\n        onStepChange?.(stepIndex);\n      }\n    },\n    [completedSteps, currentStep, onStepChange, validateCurrentStep]\n  );\n\n  const handleSaveDraft = useCallback(async () =&gt; {\n    if (!onSaveDraft || isSavingDraft) {\n      return;\n    }\n    try {\n      setIsSavingDraft(true);\n      setDraftStatus(\&quot;saving\&quot;);\n      setDraftError(null);\n      await onSaveDraft(formData);\n      setDraftStatus(\&quot;success\&quot;);\n      const savedAt = new Date();\n      setLastSavedAt(savedAt);\n      toast({\n        title: \&quot;Draft saved\&quot;,\n        description: &#96;Progress saved at ${savedAt.toLocaleTimeString([], {\n          hour: \&quot;numeric\&quot;,\n          minute: \&quot;2-digit\&quot;,\n        })}&#96;,\n      });\n    } catch (error) {\n      setDraftStatus(\&quot;error\&quot;);\n      const message =\n        error instanceof Error\n          ? error.message\n          : \&quot;Unable to save your draft right now.\&quot;;\n      setDraftError(message);\n      toast({\n        variant: \&quot;destructive\&quot;,\n        title: \&quot;Draft not saved\&quot;,\n        description: message,\n      });\n    } finally {\n      setIsSavingDraft(false);\n    }\n  }, [formData, isSavingDraft, onSaveDraft, toast]);\n\n  // Cleanup timers on unmount\n  useEffect(() =&gt; {\n    return () =&gt; {\n      const timers = validationTimersRef.current;\n      Object.values(timers).forEach((timer) =&gt; {\n        clearTimeout(timer);\n      });\n    };\n  }, []);\n\n  const progress = totalSteps &gt; 0 ? ((currentStep + 1) / totalSteps) * 100 : 0;\n\n  useEffect(() =&gt; {\n    const sectionLabel = currentSection?.label ?? &#96;Step ${currentStep + 1}&#96;;\n    setLiveMessage(&#96;Now viewing ${sectionLabel} (${currentStep + 1} of ${totalSteps})&#96;);\n  }, [currentSection, currentStep, totalSteps]);\n\n  return (\n    &lt;div className=\&quot;flex flex-col gap-6 pb-32 sm:pb-12\&quot;&gt;\n      &lt;StepIndicator\n        steps={sortedSections.map((section, index) =&gt; ({\n          id: section.id,\n          label: section.label,\n          order: section.order,\n        }))}\n        currentStep={currentStep}\n        completedSteps={completedSteps}\n        onStepClick={handleStepClick}\n      /&gt;\n\n      &lt;div\n        className={cn(\n          \&quot;min-h-[400px] space-y-6 rounded-3xl border border-border/60 bg-background/70 p-4 shadow-lg sm:p-8\&quot;,\n          !prefersReducedMotion &amp;&amp; \&quot;transition-shadow duration-300\&quot;\n        )}\n      &gt;\n        {/* Error summary for current step */}\n        {(() =&gt; {\n          const stepFieldKeys = getStepFieldKeys(currentStep, formConfig);\n          const stepErrors: Record&lt;string, string&gt; = {};\n          stepFieldKeys.forEach((key) =&gt; {\n            if (errors[key] &amp;&amp; touched[key]) {\n              stepErrors[key] = errors[key];\n            }\n          });\n\n          if (Object.keys(stepErrors).length &gt; 0) {\n            return (\n              &lt;FormErrorSummary\n                errors={stepErrors}\n                onErrorClick={(fieldKey) =&gt; {\n                  // Find the field by key to get its ID\n                  const errorField = currentSection.fields.find(\n                    (f) =&gt; f.key === fieldKey\n                  );\n                  if (errorField) {\n                    // Field components use &#96;field-${field.id}&#96; as the ID\n                    const fieldElement = document.getElementById(&#96;field-${errorField.id}&#96;);\n                    if (fieldElement) {\n                      fieldElement.focus();\n                      fieldElement.scrollIntoView({\n                        behavior: \&quot;smooth\&quot;,\n                        block: \&quot;center\&quot;,\n                      });\n                    }\n                  }\n                }}\n              /&gt;\n            );\n          }\n          return null;\n        })()}\n\n        &lt;FormStep\n          section={currentSection}\n          formData={formData}\n          errors={errors}\n          touched={touched}\n          onFieldChange={handleFieldChange}\n          onFieldBlur={handleFieldBlur}\n        /&gt;\n      &lt;/div&gt;\n\n      &lt;FormNavigation\n        isFirstStep={isFirstStep}\n        isLastStep={isLastStep}\n        onNext={handleNext}\n        onPrevious={handlePrevious}\n        onSaveDraft={handleSaveDraft}\n        progress={progress}\n        isSubmitting={isSubmitting}\n        isSavingDraft={isSavingDraft}\n        draftStatus={draftStatus}\n        draftError={draftError}\n        lastSavedAt={lastSavedAt}\n      /&gt;\n      &lt;p role=\&quot;status\&quot; aria-live=\&quot;polite\&quot; className=\&quot;sr-only\&quot;&gt;\n        {liveMessage}\n      &lt;/p&gt;\n    &lt;/div&gt;\n  );\n}\n\n&quot;
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Checking empty file update**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/sahilmehta/supplier-onboarding-simple/components/forms/dynamic-form-wizard.tsx</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Reassessing file changes**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/sahilmehta/supplier-onboarding-simple/components/forms/dynamic-form-wizard.tsx</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Planning comprehensive rewrite**

This is a big task! I’m figuring out how to rewrite the file from scratch to integrate new state management, autosave, and server actions while preserving key existing features like toasts and prefersReducedMotion. I’ll carefully incorporate hooks, props, validation, autosave logic, and accessibility—all in a fresh structure that fits the new architecture without losing essentials.</details></think>

---

The model made no changes to the file.

---

<think><details><summary>Thought Process</summary>
**Recreating file to avoid patch errors**</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  &quot;relativeWorkspacePath&quot;: &quot;/Users/sahilmehta/supplier-onboarding-simple/components/forms/dynamic-form-wizard.tsx&quot;
}
```
Additional data:

```json
{
  &quot;codeblockId&quot;: &quot;efd6d1c9-6dba-4bd4-8326-a6a6f01f5419&quot;,
  &quot;reviewData&quot;: {
    &quot;status&quot;: &quot;None&quot;,
    &quot;selectedOption&quot;: &quot;accept&quot;,
    &quot;isShowingInput&quot;: false,
    &quot;firstTimeReviewMode&quot;: false
  }
}
```
Result:

```json
{
  &quot;diff&quot;: {
    &quot;editor&quot;: &quot;EDITOR_AI&quot;
  },
  &quot;shouldAutoFixLints&quot;: true,
  &quot;resultForModel&quot;: &quot;Success. Updated the following files:\nM /Users/sahilmehta/supplier-onboarding-simple/components/forms/dynamic-form-wizard.tsx&quot;,
  &quot;contentsAfterEdit&quot;: &quot;\&quot;use client\&quot;;\n\nimport { useState, useCallback, useRef, useEffect } from \&quot;react\&quot;;\nimport type { FormConfigWithFields } from \&quot;@/lib/forms/types\&quot;;\nimport { validateStep, getStepFieldKeys } from \&quot;@/lib/forms/form-validator\&quot;;\nimport { buildFormSchema } from \&quot;@/lib/form-schema\&quot;;\nimport { StepIndicator } from \&quot;./step-indicator\&quot;;\nimport { FormStep } from \&quot;./form-step\&quot;;\nimport { FormNavigation } from \&quot;./form-navigation\&quot;;\nimport { FormErrorSummary } from \&quot;./form-error-summary\&quot;;\nimport { usePrefersReducedMotion } from \&quot;@/hooks/use-prefers-reduced-motion\&quot;;\nimport { useToast } from \&quot;@/components/ui/use-toast\&quot;;\nimport { cn } from \&quot;@/lib/utils\&quot;;\nimport type { DraftStatus } from \&quot;./draft-save-indicator\&quot;;\n\ninterface DynamicFormWizardProps {\n  formConfig: FormConfigWithFields;\n  initialData?: Record&lt;string, unknown&gt;;\n  onStepChange?: (stepIndex: number) =&gt; void;\n  onComplete?: (formData: Record&lt;string, unknown&gt;) =&gt; void;\n  onSaveDraft?: (formData: Record&lt;string, unknown&gt;) =&gt; void;\n}\n\nexport function DynamicFormWizard({\n  formConfig,\n  initialData = {},\n  onStepChange,\n  onComplete,\n  onSaveDraft,\n}: DynamicFormWizardProps) {\n  const sortedSections = [...formConfig.sections].sort(\n    (a, b) =&gt; a.order - b.order\n  );\n\n  const [currentStep, setCurrentStep] = useState(0);\n  const [formData, setFormData] = useState&lt;Record&lt;string, unknown&gt;&gt;(\n    initialData\n  );\n  const [completedSteps, setCompletedSteps] = useState&lt;Set&lt;number&gt;&gt;(\n    new Set()\n  );\n  const [errors, setErrors] = useState&lt;Record&lt;string, string&gt;&gt;({});\n  const [touched, setTouched] = useState&lt;Record&lt;string, boolean&gt;&gt;({});\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  const [isSavingDraft, setIsSavingDraft] = useState(false);\n  const [draftStatus, setDraftStatus] = useState&lt;DraftStatus&gt;(\&quot;idle\&quot;);\n  const [draftError, setDraftError] = useState&lt;string | null&gt;(null);\n  const [lastSavedAt, setLastSavedAt] = useState&lt;Date | null&gt;(null);\n  const [liveMessage, setLiveMessage] = useState(\&quot;\&quot;);\n  const validationTimersRef = useRef&lt;Record&lt;string, NodeJS.Timeout&gt;&gt;({});\n  const formSchemaRef = useRef(buildFormSchema(formConfig));\n  const prefersReducedMotion = usePrefersReducedMotion();\n  const { toast } = useToast();\n\n  const totalSteps = sortedSections.length;\n  const currentSection = sortedSections[currentStep];\n  const isFirstStep = currentStep === 0;\n  const isLastStep = currentStep === totalSteps - 1;\n\n  // Rebuild schema if form config changes\n  useEffect(() =&gt; {\n    formSchemaRef.current = buildFormSchema(formConfig);\n  }, [formConfig]);\n\n  /**\n   * Validate a single field with debouncing\n   */\n  const validateField = useCallback(\n    (fieldKey: string, value: unknown, immediate = false) =&gt; {\n      // Clear existing timer for this field\n      if (validationTimersRef.current[fieldKey]) {\n        clearTimeout(validationTimersRef.current[fieldKey]);\n      }\n\n      const performValidation = () =&gt; {\n        const fieldSchema = formSchemaRef.current.shape[fieldKey];\n        if (!fieldSchema) {\n          return;\n        }\n\n        try {\n          fieldSchema.parse(value);\n          // Clear error if validation passes\n          setErrors((prev) =&gt; {\n            const next = { ...prev };\n            delete next[fieldKey];\n            return next;\n          });\n        } catch (error) {\n          if (error &amp;&amp; typeof error === \&quot;object\&quot; &amp;&amp; \&quot;issues\&quot; in error) {\n            const zodError = error as { issues: Array&lt;{ message: string }&gt; };\n            const firstIssue = zodError.issues[0];\n            if (firstIssue) {\n              setErrors((prev) =&gt; ({\n                ...prev,\n                [fieldKey]: firstIssue.message,\n              }));\n            }\n          } else if (error instanceof Error) {\n            setErrors((prev) =&gt; ({\n              ...prev,\n              [fieldKey]: error.message,\n            }));\n          }\n        }\n      };\n\n      if (immediate) {\n        performValidation();\n      } else {\n        // Debounce validation on change (300ms)\n        validationTimersRef.current[fieldKey] = setTimeout(performValidation, 300);\n      }\n    },\n    []\n  );\n\n  const handleFieldChange = useCallback(\n    (fieldKey: string, value: unknown) =&gt; {\n      setFormData((prev) =&gt; ({\n        ...prev,\n        [fieldKey]: value,\n      }));\n\n      // Validate on change with debounce (only if field has been touched)\n      if (touched[fieldKey]) {\n        validateField(fieldKey, value, false);\n      }\n    },\n    [touched, validateField]\n  );\n\n  const handleFieldBlur = useCallback(\n    (fieldKey: string) =&gt; {\n      setTouched((prev) =&gt; ({\n        ...prev,\n        [fieldKey]: true,\n      }));\n\n      // Validate immediately on blur\n      const value = formData[fieldKey];\n      validateField(fieldKey, value, true);\n    },\n    [formData, validateField]\n  );\n\n  /**\n   * Validate current step using the validation utilities\n   */\n  const validateCurrentStep = useCallback((): boolean =&gt; {\n    const stepResult = validateStep(currentStep, formData, formConfig);\n\n    if (!stepResult.isValid) {\n      // Update errors for current step fields only\n      const stepFieldKeys = getStepFieldKeys(currentStep, formConfig);\n      setErrors((prev) =&gt; {\n        const next = { ...prev };\n        // Clear errors for fields not in current step\n        stepFieldKeys.forEach((key) =&gt; {\n          if (stepResult.errors[key]) {\n            next[key] = stepResult.errors[key];\n          } else {\n            delete next[key];\n          }\n        });\n        return next;\n      });\n\n      // Mark all fields in step as touched\n      setTouched((prev) =&gt; {\n        const next = { ...prev };\n        stepFieldKeys.forEach((key) =&gt; {\n          next[key] = true;\n        });\n        return next;\n      });\n\n      // Focus first error field\n      if (stepResult.firstErrorField) {\n        // Find the field by key to get its ID\n        const errorField = currentSection.fields.find(\n          (f) =&gt; f.key === stepResult.firstErrorField\n        );\n        if (errorField) {\n          // Field components use &#96;field-${field.id}&#96; as the ID\n          const fieldElement = document.getElementById(&#96;field-${errorField.id}&#96;);\n          if (fieldElement) {\n            fieldElement.focus();\n            fieldElement.scrollIntoView({ behavior: \&quot;smooth\&quot;, block: \&quot;center\&quot; });\n          }\n        }\n      }\n    }\n\n    return stepResult.isValid;\n  }, [currentStep, formData, formConfig, currentSection]);\n\n  const handleNext = useCallback(async () =&gt; {\n    if (isSubmitting) {\n      return;\n    }\n\n    const isStepValid = validateCurrentStep();\n    if (!isStepValid) {\n      toast({\n        variant: \&quot;destructive\&quot;,\n        title: \&quot;Please fix validation errors\&quot;,\n        description: \&quot;Resolve highlighted fields before continuing.\&quot;,\n      });\n      return;\n    }\n\n    setCompletedSteps((prev) =&gt; new Set(prev).add(currentStep));\n\n    if (isLastStep) {\n      if (!onComplete) {\n        return;\n      }\n      try {\n        setIsSubmitting(true);\n        await onComplete(formData);\n        toast({\n          title: \&quot;Form submitted\&quot;,\n          description: \&quot;Thanks! We received your information.\&quot;,\n        });\n      } catch (error) {\n        toast({\n          variant: \&quot;destructive\&quot;,\n          title: \&quot;Submission failed\&quot;,\n          description:\n            error instanceof Error\n              ? error.message\n              : \&quot;Something went wrong while submitting. Please try again.\&quot;,\n        });\n      } finally {\n        setIsSubmitting(false);\n      }\n    } else {\n      const nextStep = currentStep + 1;\n      setCurrentStep(nextStep);\n      onStepChange?.(nextStep);\n    }\n  }, [\n    currentStep,\n    formData,\n    isLastStep,\n    isSubmitting,\n    onComplete,\n    onStepChange,\n    toast,\n    validateCurrentStep,\n  ]);\n\n  const handlePrevious = useCallback(() =&gt; {\n    if (!isFirstStep) {\n      const prevStep = currentStep - 1;\n      setCurrentStep(prevStep);\n      onStepChange?.(prevStep);\n    }\n  }, [currentStep, isFirstStep, onStepChange]);\n\n  const handleStepClick = useCallback(\n    (stepIndex: number) =&gt; {\n      // Validate current step before allowing navigation\n      if (stepIndex !== currentStep) {\n        if (!validateCurrentStep()) {\n          return; // Don&#39;t allow navigation if current step is invalid\n        }\n      }\n\n      // Allow navigation to completed steps or the next step\n      if (completedSteps.has(stepIndex) || stepIndex === currentStep + 1) {\n        setCurrentStep(stepIndex);\n        onStepChange?.(stepIndex);\n      }\n    },\n    [completedSteps, currentStep, onStepChange, validateCurrentStep]\n  );\n\n  const handleSaveDraft = useCallback(async () =&gt; {\n    if (!onSaveDraft || isSavingDraft) {\n      return;\n    }\n    try {\n      setIsSavingDraft(true);\n      setDraftStatus(\&quot;saving\&quot;);\n      setDraftError(null);\n      await onSaveDraft(formData);\n      setDraftStatus(\&quot;success\&quot;);\n      const savedAt = new Date();\n      setLastSavedAt(savedAt);\n      toast({\n        title: \&quot;Draft saved\&quot;,\n        description: &#96;Progress saved at ${savedAt.toLocaleTimeString([], {\n          hour: \&quot;numeric\&quot;,\n          minute: \&quot;2-digit\&quot;,\n        })}&#96;,\n      });\n    } catch (error) {\n      setDraftStatus(\&quot;error\&quot;);\n      const message =\n        error instanceof Error\n          ? error.message\n          : \&quot;Unable to save your draft right now.\&quot;;\n      setDraftError(message);\n      toast({\n        variant: \&quot;destructive\&quot;,\n        title: \&quot;Draft not saved\&quot;,\n        description: message,\n      });\n    } finally {\n      setIsSavingDraft(false);\n    }\n  }, [formData, isSavingDraft, onSaveDraft, toast]);\n\n  // Cleanup timers on unmount\n  useEffect(() =&gt; {\n    const timers = validationTimersRef.current;\n    return () =&gt; {\n      Object.values(timers).forEach((timer) =&gt; {\n        clearTimeout(timer);\n      });\n    };\n  }, []);\n\n  const progress = totalSteps &gt; 0 ? ((currentStep + 1) / totalSteps) * 100 : 0;\n\n  useEffect(() =&gt; {\n    const sectionLabel = currentSection?.label ?? &#96;Step ${currentStep + 1}&#96;;\n    setLiveMessage(&#96;Now viewing ${sectionLabel} (${currentStep + 1} of ${totalSteps})&#96;);\n  }, [currentSection, currentStep, totalSteps]);\n\n  return (\n    &lt;div className=\&quot;flex flex-col gap-6 pb-32 sm:pb-12\&quot;&gt;\n      &lt;StepIndicator\n        steps={sortedSections.map((section, index) =&gt; ({\n          id: section.id,\n          label: section.label,\n          order: section.order,\n        }))}\n        currentStep={currentStep}\n        completedSteps={completedSteps}\n        onStepClick={handleStepClick}\n      /&gt;\n\n      &lt;div\n        className={cn(\n          \&quot;min-h-[400px] space-y-6 rounded-3xl border border-border/60 bg-background/70 p-4 shadow-lg sm:p-8\&quot;,\n          !prefersReducedMotion &amp;&amp; \&quot;transition-shadow duration-300\&quot;\n        )}\n      &gt;\n        {/* Error summary for current step */}\n        {(() =&gt; {\n          const stepFieldKeys = getStepFieldKeys(currentStep, formConfig);\n          const stepErrors: Record&lt;string, string&gt; = {};\n          stepFieldKeys.forEach((key) =&gt; {\n            if (errors[key] &amp;&amp; touched[key]) {\n              stepErrors[key] = errors[key];\n            }\n          });\n\n          if (Object.keys(stepErrors).length &gt; 0) {\n            return (\n              &lt;FormErrorSummary\n                errors={stepErrors}\n                onErrorClick={(fieldKey) =&gt; {\n                  // Find the field by key to get its ID\n                  const errorField = currentSection.fields.find(\n                    (f) =&gt; f.key === fieldKey\n                  );\n                  if (errorField) {\n                    // Field components use &#96;field-${field.id}&#96; as the ID\n                    const fieldElement = document.getElementById(&#96;field-${errorField.id}&#96;);\n                    if (fieldElement) {\n                      fieldElement.focus();\n                      fieldElement.scrollIntoView({\n                        behavior: \&quot;smooth\&quot;,\n                        block: \&quot;center\&quot;,\n                      });\n                    }\n                  }\n                }}\n              /&gt;\n            );\n          }\n          return null;\n        })()}\n\n        &lt;FormStep\n          section={currentSection}\n          formData={formData}\n          errors={errors}\n          touched={touched}\n          onFieldChange={handleFieldChange}\n          onFieldBlur={handleFieldBlur}\n        /&gt;\n      &lt;/div&gt;\n\n      &lt;FormNavigation\n        isFirstStep={isFirstStep}\n        isLastStep={isLastStep}\n        onNext={handleNext}\n        onPrevious={handlePrevious}\n        onSaveDraft={handleSaveDraft}\n        progress={progress}\n        isSubmitting={isSubmitting}\n        isSavingDraft={isSavingDraft}\n        draftStatus={draftStatus}\n        draftError={draftError}\n        lastSavedAt={lastSavedAt}\n      /&gt;\n      &lt;p role=\&quot;status\&quot; aria-live=\&quot;polite\&quot; className=\&quot;sr-only\&quot;&gt;\n        {liveMessage}\n      &lt;/p&gt;\n    &lt;/div&gt;\n  );\n}\n\n&quot;
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Checking if file is empty**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/sahilmehta/supplier-onboarding-simple/components/forms/dynamic-form-wizard.tsx</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Deleting file by patch application**</details></think>

---

The model made no changes to the file.

---

<think><details><summary>Thought Process</summary>
**Handling patch conflicts with file deletion**</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  &quot;relativeWorkspacePath&quot;: &quot;/Users/sahilmehta/supplier-onboarding-simple/components/forms/dynamic-form-wizard.tsx&quot;
}
```
Additional data:

```json
{
  &quot;codeblockId&quot;: &quot;80b1b16f-4091-4976-b948-178032eeadd0&quot;,
  &quot;reviewData&quot;: {
    &quot;status&quot;: &quot;None&quot;,
    &quot;selectedOption&quot;: &quot;accept&quot;,
    &quot;isShowingInput&quot;: false,
    &quot;firstTimeReviewMode&quot;: false
  }
}
```
Result:

```json
{
  &quot;diff&quot;: {
    &quot;editor&quot;: &quot;EDITOR_AI&quot;
  },
  &quot;shouldAutoFixLints&quot;: true,
  &quot;resultForModel&quot;: &quot;Success. Updated the following files:\nM /Users/sahilmehta/supplier-onboarding-simple/components/forms/dynamic-form-wizard.tsx&quot;,
  &quot;contentsAfterEdit&quot;: &quot;\&quot;use client\&quot;;\n\nimport { useState, useCallback, useRef, useEffect } from \&quot;react\&quot;;\nimport type { FormConfigWithFields } from \&quot;@/lib/forms/types\&quot;;\nimport { validateStep, getStepFieldKeys } from \&quot;@/lib/forms/form-validator\&quot;;\nimport { buildFormSchema } from \&quot;@/lib/form-schema\&quot;;\nimport { StepIndicator } from \&quot;./step-indicator\&quot;;\nimport { FormStep } from \&quot;./form-step\&quot;;\nimport { FormNavigation } from \&quot;./form-navigation\&quot;;\nimport { FormErrorSummary } from \&quot;./form-error-summary\&quot;;\nimport { usePrefersReducedMotion } from \&quot;@/hooks/use-prefers-reduced-motion\&quot;;\nimport { useToast } from \&quot;@/components/ui/use-toast\&quot;;\nimport { cn } from \&quot;@/lib/utils\&quot;;\nimport type { DraftStatus } from \&quot;./draft-save-indicator\&quot;;\n\ninterface DynamicFormWizardProps {\n  formConfig: FormConfigWithFields;\n  initialData?: Record&lt;string, unknown&gt;;\n  onStepChange?: (stepIndex: number) =&gt; void;\n  onComplete?: (formData: Record&lt;string, unknown&gt;) =&gt; void;\n  onSaveDraft?: (formData: Record&lt;string, unknown&gt;) =&gt; void;\n}\n\nexport function DynamicFormWizard({\n  formConfig,\n  initialData = {},\n  onStepChange,\n  onComplete,\n  onSaveDraft,\n}: DynamicFormWizardProps) {\n  const sortedSections = [...formConfig.sections].sort(\n    (a, b) =&gt; a.order - b.order\n  );\n\n  const [currentStep, setCurrentStep] = useState(0);\n  const [formData, setFormData] = useState&lt;Record&lt;string, unknown&gt;&gt;(\n    initialData\n  );\n  const [completedSteps, setCompletedSteps] = useState&lt;Set&lt;number&gt;&gt;(\n    new Set()\n  );\n  const [errors, setErrors] = useState&lt;Record&lt;string, string&gt;&gt;({});\n  const [touched, setTouched] = useState&lt;Record&lt;string, boolean&gt;&gt;({});\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  const [isSavingDraft, setIsSavingDraft] = useState(false);\n  const [draftStatus, setDraftStatus] = useState&lt;DraftStatus&gt;(\&quot;idle\&quot;);\n  const [draftError, setDraftError] = useState&lt;string | null&gt;(null);\n  const [lastSavedAt, setLastSavedAt] = useState&lt;Date | null&gt;(null);\n  const [liveMessage, setLiveMessage] = useState(\&quot;\&quot;);\n  const validationTimersRef = useRef&lt;Record&lt;string, NodeJS.Timeout&gt;&gt;({});\n  const formSchemaRef = useRef(buildFormSchema(formConfig));\n  const prefersReducedMotion = usePrefersReducedMotion();\n  const { toast } = useToast();\n\n  const totalSteps = sortedSections.length;\n  const currentSection = sortedSections[currentStep];\n  const isFirstStep = currentStep === 0;\n  const isLastStep = currentStep === totalSteps - 1;\n\n  // Rebuild schema if form config changes\n  useEffect(() =&gt; {\n    formSchemaRef.current = buildFormSchema(formConfig);\n  }, [formConfig]);\n\n  /**\n   * Validate a single field with debouncing\n   */\n  const validateField = useCallback(\n    (fieldKey: string, value: unknown, immediate = false) =&gt; {\n      // Clear existing timer for this field\n      if (validationTimersRef.current[fieldKey]) {\n        clearTimeout(validationTimersRef.current[fieldKey]);\n      }\n\n      const performValidation = () =&gt; {\n        const fieldSchema = formSchemaRef.current.shape[fieldKey];\n        if (!fieldSchema) {\n          return;\n        }\n\n        try {\n          fieldSchema.parse(value);\n          // Clear error if validation passes\n          setErrors((prev) =&gt; {\n            const next = { ...prev };\n            delete next[fieldKey];\n            return next;\n          });\n        } catch (error) {\n          if (error &amp;&amp; typeof error === \&quot;object\&quot; &amp;&amp; \&quot;issues\&quot; in error) {\n            const zodError = error as { issues: Array&lt;{ message: string }&gt; };\n            const firstIssue = zodError.issues[0];\n            if (firstIssue) {\n              setErrors((prev) =&gt; ({\n                ...prev,\n                [fieldKey]: firstIssue.message,\n              }));\n            }\n          } else if (error instanceof Error) {\n            setErrors((prev) =&gt; ({\n              ...prev,\n              [fieldKey]: error.message,\n            }));\n          }\n        }\n      };\n\n      if (immediate) {\n        performValidation();\n      } else {\n        // Debounce validation on change (300ms)\n        validationTimersRef.current[fieldKey] = setTimeout(performValidation, 300);\n      }\n    },\n    []\n  );\n\n  const handleFieldChange = useCallback(\n    (fieldKey: string, value: unknown) =&gt; {\n      setFormData((prev) =&gt; ({\n        ...prev,\n        [fieldKey]: value,\n      }));\n\n      // Validate on change with debounce (only if field has been touched)\n      if (touched[fieldKey]) {\n        validateField(fieldKey, value, false);\n      }\n    },\n    [touched, validateField]\n  );\n\n  const handleFieldBlur = useCallback(\n    (fieldKey: string) =&gt; {\n      setTouched((prev) =&gt; ({\n        ...prev,\n        [fieldKey]: true,\n      }));\n\n      // Validate immediately on blur\n      const value = formData[fieldKey];\n      validateField(fieldKey, value, true);\n    },\n    [formData, validateField]\n  );\n\n  /**\n   * Validate current step using the validation utilities\n   */\n  const validateCurrentStep = useCallback((): boolean =&gt; {\n    const stepResult = validateStep(currentStep, formData, formConfig);\n\n    if (!stepResult.isValid) {\n      // Update errors for current step fields only\n      const stepFieldKeys = getStepFieldKeys(currentStep, formConfig);\n      setErrors((prev) =&gt; {\n        const next = { ...prev };\n        // Clear errors for fields not in current step\n        stepFieldKeys.forEach((key) =&gt; {\n          if (stepResult.errors[key]) {\n            next[key] = stepResult.errors[key];\n          } else {\n            delete next[key];\n          }\n        });\n        return next;\n      });\n\n      // Mark all fields in step as touched\n      setTouched((prev) =&gt; {\n        const next = { ...prev };\n        stepFieldKeys.forEach((key) =&gt; {\n          next[key] = true;\n        });\n        return next;\n      });\n\n      // Focus first error field\n      if (stepResult.firstErrorField) {\n        // Find the field by key to get its ID\n        const errorField = currentSection.fields.find(\n          (f) =&gt; f.key === stepResult.firstErrorField\n        );\n        if (errorField) {\n          // Field components use &#96;field-${field.id}&#96; as the ID\n          const fieldElement = document.getElementById(&#96;field-${errorField.id}&#96;);\n          if (fieldElement) {\n            fieldElement.focus();\n            fieldElement.scrollIntoView({ behavior: \&quot;smooth\&quot;, block: \&quot;center\&quot; });\n          }\n        }\n      }\n    }\n\n    return stepResult.isValid;\n  }, [currentStep, formData, formConfig, currentSection]);\n\n  const handleNext = useCallback(async () =&gt; {\n    if (isSubmitting) {\n      return;\n    }\n\n    const isStepValid = validateCurrentStep();\n    if (!isStepValid) {\n      toast({\n        variant: \&quot;destructive\&quot;,\n        title: \&quot;Please fix validation errors\&quot;,\n        description: \&quot;Resolve highlighted fields before continuing.\&quot;,\n      });\n      return;\n    }\n\n    setCompletedSteps((prev) =&gt; new Set(prev).add(currentStep));\n\n    if (isLastStep) {\n      if (!onComplete) {\n        return;\n      }\n      try {\n        setIsSubmitting(true);\n        await onComplete(formData);\n        toast({\n          title: \&quot;Form submitted\&quot;,\n          description: \&quot;Thanks! We received your information.\&quot;,\n        });\n      } catch (error) {\n        toast({\n          variant: \&quot;destructive\&quot;,\n          title: \&quot;Submission failed\&quot;,\n          description:\n            error instanceof Error\n              ? error.message\n              : \&quot;Something went wrong while submitting. Please try again.\&quot;,\n        });\n      } finally {\n        setIsSubmitting(false);\n      }\n    } else {\n      const nextStep = currentStep + 1;\n      setCurrentStep(nextStep);\n      onStepChange?.(nextStep);\n    }\n  }, [\n    currentStep,\n    formData,\n    isLastStep,\n    isSubmitting,\n    onComplete,\n    onStepChange,\n    toast,\n    validateCurrentStep,\n  ]);\n\n  const handlePrevious = useCallback(() =&gt; {\n    if (!isFirstStep) {\n      const prevStep = currentStep - 1;\n      setCurrentStep(prevStep);\n      onStepChange?.(prevStep);\n    }\n  }, [currentStep, isFirstStep, onStepChange]);\n\n  const handleStepClick = useCallback(\n    (stepIndex: number) =&gt; {\n      // Validate current step before allowing navigation\n      if (stepIndex !== currentStep) {\n        if (!validateCurrentStep()) {\n          return; // Don&#39;t allow navigation if current step is invalid\n        }\n      }\n\n      // Allow navigation to completed steps or the next step\n      if (completedSteps.has(stepIndex) || stepIndex === currentStep + 1) {\n        setCurrentStep(stepIndex);\n        onStepChange?.(stepIndex);\n      }\n    },\n    [completedSteps, currentStep, onStepChange, validateCurrentStep]\n  );\n\n  const handleSaveDraft = useCallback(async () =&gt; {\n    if (!onSaveDraft || isSavingDraft) {\n      return;\n    }\n    try {\n      setIsSavingDraft(true);\n      setDraftStatus(\&quot;saving\&quot;);\n      setDraftError(null);\n      await onSaveDraft(formData);\n      setDraftStatus(\&quot;success\&quot;);\n      const savedAt = new Date();\n      setLastSavedAt(savedAt);\n      toast({\n        title: \&quot;Draft saved\&quot;,\n        description: &#96;Progress saved at ${savedAt.toLocaleTimeString([], {\n          hour: \&quot;numeric\&quot;,\n          minute: \&quot;2-digit\&quot;,\n        })}&#96;,\n      });\n    } catch (error) {\n      setDraftStatus(\&quot;error\&quot;);\n      const message =\n        error instanceof Error\n          ? error.message\n          : \&quot;Unable to save your draft right now.\&quot;;\n      setDraftError(message);\n      toast({\n        variant: \&quot;destructive\&quot;,\n        title: \&quot;Draft not saved\&quot;,\n        description: message,\n      });\n    } finally {\n      setIsSavingDraft(false);\n    }\n  }, [formData, isSavingDraft, onSaveDraft, toast]);\n\n  // Cleanup timers on unmount\n  useEffect(() =&gt; {\n    const timers = validationTimersRef.current;\n    return () =&gt; {\n      Object.values(timers).forEach((timer) =&gt; {\n        clearTimeout(timer);\n      });\n    };\n  }, []);\n\n  const progress = totalSteps &gt; 0 ? ((currentStep + 1) / totalSteps) * 100 : 0;\n\n  useEffect(() =&gt; {\n    const sectionLabel = currentSection?.label ?? &#96;Step ${currentStep + 1}&#96;;\n    setLiveMessage(&#96;Now viewing ${sectionLabel} (${currentStep + 1} of ${totalSteps})&#96;);\n  }, [currentSection, currentStep, totalSteps]);\n\n  return (\n    &lt;div className=\&quot;flex flex-col gap-6 pb-32 sm:pb-12\&quot;&gt;\n      &lt;StepIndicator\n        steps={sortedSections.map((section, index) =&gt; ({\n          id: section.id,\n          label: section.label,\n          order: section.order,\n        }))}\n        currentStep={currentStep}\n        completedSteps={completedSteps}\n        onStepClick={handleStepClick}\n      /&gt;\n\n      &lt;div\n        className={cn(\n          \&quot;min-h-[400px] space-y-6 rounded-3xl border border-border/60 bg-background/70 p-4 shadow-lg sm:p-8\&quot;,\n          !prefersReducedMotion &amp;&amp; \&quot;transition-shadow duration-300\&quot;\n        )}\n      &gt;\n        {/* Error summary for current step */}\n        {(() =&gt; {\n          const stepFieldKeys = getStepFieldKeys(currentStep, formConfig);\n          const stepErrors: Record&lt;string, string&gt; = {};\n          stepFieldKeys.forEach((key) =&gt; {\n            if (errors[key] &amp;&amp; touched[key]) {\n              stepErrors[key] = errors[key];\n            }\n          });\n\n          if (Object.keys(stepErrors).length &gt; 0) {\n            return (\n              &lt;FormErrorSummary\n                errors={stepErrors}\n                onErrorClick={(fieldKey) =&gt; {\n                  // Find the field by key to get its ID\n                  const errorField = currentSection.fields.find(\n                    (f) =&gt; f.key === fieldKey\n                  );\n                  if (errorField) {\n                    // Field components use &#96;field-${field.id}&#96; as the ID\n                    const fieldElement = document.getElementById(&#96;field-${errorField.id}&#96;);\n                    if (fieldElement) {\n                      fieldElement.focus();\n                      fieldElement.scrollIntoView({\n                        behavior: \&quot;smooth\&quot;,\n                        block: \&quot;center\&quot;,\n                      });\n                    }\n                  }\n                }}\n              /&gt;\n            );\n          }\n          return null;\n        })()}\n\n        &lt;FormStep\n          section={currentSection}\n          formData={formData}\n          errors={errors}\n          touched={touched}\n          onFieldChange={handleFieldChange}\n          onFieldBlur={handleFieldBlur}\n        /&gt;\n      &lt;/div&gt;\n\n      &lt;FormNavigation\n        isFirstStep={isFirstStep}\n        isLastStep={isLastStep}\n        onNext={handleNext}\n        onPrevious={handlePrevious}\n        onSaveDraft={handleSaveDraft}\n        progress={progress}\n        isSubmitting={isSubmitting}\n        isSavingDraft={isSavingDraft}\n        draftStatus={draftStatus}\n        draftError={draftError}\n        lastSavedAt={lastSavedAt}\n      /&gt;\n      &lt;p role=\&quot;status\&quot; aria-live=\&quot;polite\&quot; className=\&quot;sr-only\&quot;&gt;\n        {liveMessage}\n      &lt;/p&gt;\n    &lt;/div&gt;\n  );\n}\n\n&quot;
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Confirming presence by reading**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/sahilmehta/supplier-onboarding-simple/components/forms/dynamic-form-wizard.tsx</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Preparing patch to delete file**</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  &quot;relativeWorkspacePath&quot;: &quot;/Users/sahilmehta/supplier-onboarding-simple/components/forms/dynamic-form-wizard.tsx&quot;
}
```
Additional data:

```json
{
  &quot;codeblockId&quot;: &quot;ec7353c0-b4e7-4406-a82c-d319c6da66b8&quot;,
  &quot;reviewData&quot;: {
    &quot;status&quot;: &quot;None&quot;,
    &quot;selectedOption&quot;: &quot;accept&quot;,
    &quot;isShowingInput&quot;: false,
    &quot;firstTimeReviewMode&quot;: false
  }
}
```
Result:

```json
{
  &quot;diff&quot;: {
    &quot;chunks&quot;: [
      {
        &quot;diffString&quot;: &quot;+ \&quot;use client\&quot;;\n+ \n+ import { useCallback, useEffect, useMemo, useRef, useState } from \&quot;react\&quot;;\n+ import type { FormConfigWithFields } from \&quot;@/lib/forms/types\&quot;;\n+ import { getStepFieldKeys } from \&quot;@/lib/forms/form-validator\&quot;;\n+ import { buildFormSchema } from \&quot;@/lib/form-schema\&quot;;\n+ import { saveFormDraft, type DraftSaveResult } from \&quot;@/app/forms/actions\&quot;;\n+ import { StepIndicator } from \&quot;./step-indicator\&quot;;\n+ import { FormStep } from \&quot;./form-step\&quot;;\n+ import { FormNavigation } from \&quot;./form-navigation\&quot;;\n+ import { FormErrorSummary } from \&quot;./form-error-summary\&quot;;\n+ import { useFormState } from \&quot;@/hooks/use-form-state\&quot;;\n+ import { useAutosave } from \&quot;@/hooks/use-autosave\&quot;;\n+ import { useToast } from \&quot;@/components/ui/use-toast\&quot;;\n+ import { usePrefersReducedMotion } from \&quot;@/hooks/use-prefers-reduced-motion\&quot;;\n+ import { cn } from \&quot;@/lib/utils\&quot;;\n+ \n+ interface DynamicFormWizardProps {\n+   formConfig: FormConfigWithFields;\n+   initialData?: Record&lt;string, unknown&gt;;\n+   initialStep?: number;\n+   applicationId: string | null;\n+   organizationId: string;\n+   onApplicationIdChange?: (applicationId: string) =&gt; void;\n+   onDraftSaved?: (result: DraftSaveResult) =&gt; void;\n+   onStepChange?: (stepIndex: number) =&gt; void;\n+   onComplete?: (formData: Record&lt;string, unknown&gt;) =&gt; Promise&lt;void&gt; | void;\n+ }\n+ \n+ export function DynamicFormWizard({\n+   formConfig,\n+   initialData = {},\n+   initialStep = 0,\n+   applicationId,\n+   organizationId,\n+   onApplicationIdChange,\n+   onDraftSaved,\n+   onStepChange,\n+   onComplete,\n+ }: DynamicFormWizardProps) {\n+   const sortedSections = useMemo(\n+     () =&gt; [...formConfig.sections].sort((a, b) =&gt; a.order - b.order),\n+     [formConfig.sections]\n+   );\n+ \n+   const {\n+     state,\n+     touchedMap,\n+     setFieldValue,\n+     markFieldTouched,\n+     markFieldsTouched,\n+     setFieldError,\n+     setStepErrors,\n+     goToStep,\n+     markStepComplete,\n+     setIsSubmitting,\n+     markClean,\n+     validateAndCommitStep,\n+   } = useFormState({\n+     formConfig,\n+     initialData,\n+     initialStep,\n+   });\n+ \n+   const [liveMessage, setLiveMessage] = useState(\&quot;\&quot;);\n+   const validationTimersRef = useRef&lt;Record&lt;string, NodeJS.Timeout&gt;&gt;({});\n+   const formSchemaRef = useRef(buildFormSchema(formConfig));\n+   const prefersReducedMotion = usePrefersReducedMotion();\n+   const { toast } = useToast();\n+ \n+   const totalSteps = sortedSections.length;\n+   const currentSection = sortedSections[state.currentStep];\n+   const isFirstStep = state.currentStep === 0;\n+   const isLastStep = state.currentStep === totalSteps - 1;\n+ \n+   useEffect(() =&gt; {\n+     formSchemaRef.current = buildFormSchema(formConfig);\n+   }, [formConfig]);\n+ \n+   const focusFirstError = useCallback(\n+     (fieldKey?: string) =&gt; {\n+       if (!fieldKey || !currentSection) {\n+         return;\n+       }\n+       const errorField = currentSection.fields.find((field) =&gt; field.key === fieldKey);\n+       const fieldElement = errorField\n+         ? document.getElementById(&#96;field-${errorField.id}&#96;)\n+         : null;\n+       fieldElement?.focus();\n+       fieldElement?.scrollIntoView({ behavior: \&quot;smooth\&quot;, block: \&quot;center\&quot; });\n+     },\n+     [currentSection]\n+   );\n+ \n+   const validateField = useCallback(\n+     (fieldKey: string, value: unknown, immediate = false) =&gt; {\n+       if (validationTimersRef.current[fieldKey]) {\n+         clearTimeout(validationTimersRef.current[fieldKey]);\n+       }\n+ \n+       const performValidation = () =&gt; {\n+         const fieldSchema = formSchemaRef.current.shape[fieldKey];\n+         if (!fieldSchema) {\n+           return;\n+         }\n+ \n+         try {\n+           fieldSchema.parse(value);\n+           setFieldError(fieldKey);\n+         } catch (error) {\n+           if (error &amp;&amp; typeof error === \&quot;object\&quot; &amp;&amp; \&quot;issues\&quot; in error) {\n+             const zodError = error as { issues: Array&lt;{ message: string }&gt; };\n+             const firstIssue = zodError.issues[0];\n+             if (firstIssue) {\n+               setFieldError(fieldKey, firstIssue.message);\n+             }\n+           } else if (error instanceof Error) {\n+             setFieldError(fieldKey, error.message);\n+           }\n+         }\n+       };\n+ \n+       if (immediate) {\n+         performValidation();\n+       } else {\n+         validationTimersRef.current[fieldKey] = setTimeout(performValidation, 300);\n+       }\n+     },\n+     [setFieldError]\n+   );\n+ \n+   const handleFieldChange = useCallback(\n+     (fieldKey: string, value: unknown) =&gt; {\n+       setFieldValue(fieldKey, value);\n+       if (state.touched.has(fieldKey)) {\n+         validateField(fieldKey, value, false);\n+       }\n+     },\n+     [setFieldValue, state.touched, validateField]\n+   );\n+ \n+   const handleFieldBlur = useCallback(\n+     (fieldKey: string) =&gt; {\n+       markFieldTouched(fieldKey);\n+       validateField(fieldKey, state.formData[fieldKey], true);\n+     },\n+     [markFieldTouched, state.formData, validateField]\n+   );\n+ \n+   const autosaveFingerprint = useMemo(\n+     () =&gt; JSON.stringify({ data: state.formData, step: state.currentStep }),\n+     [state.formData, state.currentStep]\n+   );\n+ \n+   const runDraftSave = useCallback(() =&gt; {\n+     return saveFormDraft({\n+       formConfigId: formConfig.id,\n+       organizationId,\n+       entityId: formConfig.entityId,\n+       geographyId: formConfig.geographyId,\n+       applicationId,\n+       formData: state.formData,\n+       currentStep: state.currentStep,\n+     });\n+   }, [\n+     applicationId,\n+     formConfig.entityId,\n+     formConfig.geographyId,\n+     formConfig.id,\n+     organizationId,\n+     state.currentStep,\n+     state.formData,\n+   ]);\n+ \n+   const {\n+     status: draftStatus,\n+     isSaving: isSavingDraft,\n+     lastSavedAt,\n+     error: draftError,\n+     triggerSave,\n+   } = useAutosave&lt;DraftSaveResult&gt;({\n+     shouldAutosave: state.isDirty,\n+     dataFingerprint: autosaveFingerprint,\n+     save: runDraftSave,\n+     onSuccess: (result) =&gt; {\n+       markClean();\n+       if (result.applicationId &amp;&amp; result.applicationId !== applicationId) {\n+         onApplicationIdChange?.(result.applicationId);\n+       }\n+       onDraftSaved?.(result);\n+     },\n+     onError: (error) =&gt; {\n+       toast({\n+         variant: \&quot;destructive\&quot;,\n+         title: \&quot;Draft save failed\&quot;,\n+         description: error.message,\n+       });\n+     },\n+   });\n+ \n+   const handleNext = useCallback(async () =&gt; {\n+     if (state.isSubmitting) {\n+       return;\n+     }\n+ \n+     const validation = validateAndCommitStep(state.currentStep);\n+     if (!validation.isValid) {\n+       toast({\n+         variant: \&quot;destructive\&quot;,\n+         title: \&quot;Please fix validation errors\&quot;,\n+         description: \&quot;Resolve highlighted fields before continuing.\&quot;,\n+       });\n+       focusFirstError(validation.firstErrorField);\n+       return;\n+     }\n+ \n+     markStepComplete(state.currentStep);\n+ \n+     if (isLastStep &amp;&amp; onComplete) {\n+       try {\n+         setIsSubmitting(true);\n+         await onComplete(state.formData);\n+         toast({\n+           title: \&quot;Form submitted\&quot;,\n+           description: \&quot;Thank you! We received your information.\&quot;,\n+         });\n+       } catch (error) {\n+         toast({\n+           variant: \&quot;destructive\&quot;,\n+           title: \&quot;Submission failed\&quot;,\n+           description:\n+             error instanceof Error\n+               ? error.message\n+               : \&quot;Something went wrong while submitting. Please try again.\&quot;,\n+         });\n+       } finally {\n+         setIsSubmitting(false);\n+       }\n+       return;\n+     }\n+ \n+     const nextStep = state.currentStep + 1;\n+     goToStep(nextStep);\n+     onStepChange?.(nextStep);\n+     void triggerSave(\&quot;step-change\&quot;);\n+   }, [\n+     focusFirstError,\n+     goToStep,\n+     isLastStep,\n+     markStepComplete,\n+     onComplete,\n+     onStepChange,\n+     setIsSubmitting,\n+     state.currentStep,\n+     state.formData,\n+     state.isSubmitting,\n+     toast,\n+     triggerSave,\n+     validateAndCommitStep,\n+   ]);\n+ \n+   const handlePrevious = useCallback(() =&gt; {\n+     if (isFirstStep) {\n+       return;\n+     }\n+     const prevStep = state.currentStep - 1;\n+     goToStep(prevStep);\n+     onStepChange?.(prevStep);\n+   }, [goToStep, isFirstStep, onStepChange, state.currentStep]);\n+ \n+   const handleStepClick = useCallback(\n+     (stepIndex: number) =&gt; {\n+       if (stepIndex === state.currentStep) {\n+         return;\n+       }\n+ \n+       const validation = validateAndCommitStep(state.currentStep);\n+       if (!validation.isValid) {\n+         toast({\n+           variant: \&quot;destructive\&quot;,\n+           title: \&quot;Cannot leave step yet\&quot;,\n+           description: \&quot;Fix validation errors before moving on.\&quot;,\n+         });\n+         focusFirstError(validation.firstErrorField);\n+         return;\n+       }\n+ \n+       if (\n+         state.completedSteps.has(stepIndex) ||\n+         stepIndex === state.currentStep + 1\n+       ) {\n+         goToStep(stepIndex);\n+         onStepChange?.(stepIndex);\n+         void triggerSave(\&quot;step-change\&quot;);\n+       }\n+     },\n+     [\n+       focusFirstError,\n+       goToStep,\n+       onStepChange,\n+       state.completedSteps,\n+       state.currentStep,\n+       toast,\n+       triggerSave,\n+       validateAndCommitStep,\n+     ]\n+   );\n+ \n+   const handleManualSave = useCallback(() =&gt; {\n+     void triggerSave(\&quot;manual\&quot;);\n+   }, [triggerSave]);\n+ \n+   useEffect(() =&gt; {\n+     return () =&gt; {\n+       Object.values(validationTimersRef.current).forEach((timer) =&gt; {\n+         clearTimeout(timer);\n+       });\n+     };\n+   }, []);\n+ \n+   useEffect(() =&gt; {\n+     const sectionLabel = currentSection?.label ?? &#96;Step ${state.currentStep + 1}&#96;;\n+     setLiveMessage(\n+       &#96;Now viewing ${sectionLabel} (${state.currentStep + 1} of ${totalSteps})&#96;\n+     );\n+   }, [currentSection, state.currentStep, totalSteps]);\n+ \n+   const progress =\n+     totalSteps &gt; 0 ? ((state.currentStep + 1) / totalSteps) * 100 : 0;\n+ \n+   return (\n+     &lt;div className=\&quot;flex flex-col gap-6 pb-32 sm:pb-12\&quot;&gt;\n+       &lt;StepIndicator\n+         steps={sortedSections.map((section) =&gt; ({\n+           id: section.id,\n+           label: section.label,\n+           order: section.order,\n+         }))}\n+         currentStep={state.currentStep}\n+         completedSteps={state.completedSteps}\n+         onStepClick={handleStepClick}\n+       /&gt;\n+ \n+       &lt;div\n+         className={cn(\n+           \&quot;min-h-[400px] space-y-6 rounded-3xl border border-border/60 bg-background/70 p-4 shadow-lg sm:p-8\&quot;,\n+           !prefersReducedMotion &amp;&amp; \&quot;transition-shadow duration-300\&quot;\n+         )}\n+       &gt;\n+         {(() =&gt; {\n+           const stepFieldKeys = getStepFieldKeys(state.currentStep, formConfig);\n+           const stepErrors: Record&lt;string, string&gt; = {};\n+           stepFieldKeys.forEach((key) =&gt; {\n+             if (state.errors[key] &amp;&amp; touchedMap[key]) {\n+               stepErrors[key] = state.errors[key];\n+             }\n+           });\n+ \n+           if (Object.keys(stepErrors).length &gt; 0) {\n+             return (\n+               &lt;FormErrorSummary\n+                 errors={stepErrors}\n+                 onErrorClick={(fieldKey) =&gt; focusFirstError(fieldKey)}\n+               /&gt;\n+             );\n+           }\n+           return null;\n+         })()}\n+ \n+         {currentSection &amp;&amp; (\n+           &lt;FormStep\n+             section={currentSection}\n+             formData={state.formData}\n+             errors={state.errors}\n+             touched={touchedMap}\n+             onFieldChange={handleFieldChange}\n+             onFieldBlur={handleFieldBlur}\n+           /&gt;\n+         )}\n+       &lt;/div&gt;\n+ \n+       &lt;FormNavigation\n+         isFirstStep={isFirstStep}\n+         isLastStep={isLastStep}\n+         onNext={handleNext}\n+         onPrevious={handlePrevious}\n+         onSaveDraft={handleManualSave}\n+         progress={progress}\n+         isSubmitting={state.isSubmitting}\n+         isSavingDraft={isSavingDraft}\n+         draftStatus={draftStatus}\n+         draftError={draftError}\n+         lastSavedAt={lastSavedAt}\n+       /&gt;\n+       &lt;p role=\&quot;status\&quot; aria-live=\&quot;polite\&quot; className=\&quot;sr-only\&quot;&gt;\n+         {liveMessage}\n+       &lt;/p&gt;\n+     &lt;/div&gt;\n+   );\n+ }\n  \&quot;use client\&quot;;\n  &quot;,
        &quot;oldStart&quot;: 1,
        &quot;newStart&quot;: 1,
        &quot;oldLines&quot;: 2,
        &quot;newLines&quot;: 402,
        &quot;linesAdded&quot;: 400
      }
    ],
    &quot;editor&quot;: &quot;EDITOR_AI&quot;
  },
  &quot;shouldAutoFixLints&quot;: true,
  &quot;resultForModel&quot;: &quot;Success. Updated the following files:\nM /Users/sahilmehta/supplier-onboarding-simple/components/forms/dynamic-form-wizard.tsx&quot;,
  &quot;contentsAfterEdit&quot;: &quot;\&quot;use client\&quot;;\n\nimport { useCallback, useEffect, useMemo, useRef, useState } from \&quot;react\&quot;;\nimport type { FormConfigWithFields } from \&quot;@/lib/forms/types\&quot;;\nimport { getStepFieldKeys } from \&quot;@/lib/forms/form-validator\&quot;;\nimport { buildFormSchema } from \&quot;@/lib/form-schema\&quot;;\nimport { saveFormDraft, type DraftSaveResult } from \&quot;@/app/forms/actions\&quot;;\nimport { StepIndicator } from \&quot;./step-indicator\&quot;;\nimport { FormStep } from \&quot;./form-step\&quot;;\nimport { FormNavigation } from \&quot;./form-navigation\&quot;;\nimport { FormErrorSummary } from \&quot;./form-error-summary\&quot;;\nimport { useFormState } from \&quot;@/hooks/use-form-state\&quot;;\nimport { useAutosave } from \&quot;@/hooks/use-autosave\&quot;;\nimport { useToast } from \&quot;@/components/ui/use-toast\&quot;;\nimport { usePrefersReducedMotion } from \&quot;@/hooks/use-prefers-reduced-motion\&quot;;\nimport { cn } from \&quot;@/lib/utils\&quot;;\n\ninterface DynamicFormWizardProps {\n  formConfig: FormConfigWithFields;\n  initialData?: Record&lt;string, unknown&gt;;\n  initialStep?: number;\n  applicationId: string | null;\n  organizationId: string;\n  onApplicationIdChange?: (applicationId: string) =&gt; void;\n  onDraftSaved?: (result: DraftSaveResult) =&gt; void;\n  onStepChange?: (stepIndex: number) =&gt; void;\n  onComplete?: (formData: Record&lt;string, unknown&gt;) =&gt; Promise&lt;void&gt; | void;\n}\n\nexport function DynamicFormWizard({\n  formConfig,\n  initialData = {},\n  initialStep = 0,\n  applicationId,\n  organizationId,\n  onApplicationIdChange,\n  onDraftSaved,\n  onStepChange,\n  onComplete,\n}: DynamicFormWizardProps) {\n  const sortedSections = useMemo(\n    () =&gt; [...formConfig.sections].sort((a, b) =&gt; a.order - b.order),\n    [formConfig.sections]\n  );\n\n  const {\n    state,\n    touchedMap,\n    setFieldValue,\n    markFieldTouched,\n    markFieldsTouched,\n    setFieldError,\n    setStepErrors,\n    goToStep,\n    markStepComplete,\n    setIsSubmitting,\n    markClean,\n    validateAndCommitStep,\n  } = useFormState({\n    formConfig,\n    initialData,\n    initialStep,\n  });\n\n  const [liveMessage, setLiveMessage] = useState(\&quot;\&quot;);\n  const validationTimersRef = useRef&lt;Record&lt;string, NodeJS.Timeout&gt;&gt;({});\n  const formSchemaRef = useRef(buildFormSchema(formConfig));\n  const prefersReducedMotion = usePrefersReducedMotion();\n  const { toast } = useToast();\n\n  const totalSteps = sortedSections.length;\n  const currentSection = sortedSections[state.currentStep];\n  const isFirstStep = state.currentStep === 0;\n  const isLastStep = state.currentStep === totalSteps - 1;\n\n  useEffect(() =&gt; {\n    formSchemaRef.current = buildFormSchema(formConfig);\n  }, [formConfig]);\n\n  const focusFirstError = useCallback(\n    (fieldKey?: string) =&gt; {\n      if (!fieldKey || !currentSection) {\n        return;\n      }\n      const errorField = currentSection.fields.find((field) =&gt; field.key === fieldKey);\n      const fieldElement = errorField\n        ? document.getElementById(&#96;field-${errorField.id}&#96;)\n        : null;\n      fieldElement?.focus();\n      fieldElement?.scrollIntoView({ behavior: \&quot;smooth\&quot;, block: \&quot;center\&quot; });\n    },\n    [currentSection]\n  );\n\n  const validateField = useCallback(\n    (fieldKey: string, value: unknown, immediate = false) =&gt; {\n      if (validationTimersRef.current[fieldKey]) {\n        clearTimeout(validationTimersRef.current[fieldKey]);\n      }\n\n      const performValidation = () =&gt; {\n        const fieldSchema = formSchemaRef.current.shape[fieldKey];\n        if (!fieldSchema) {\n          return;\n        }\n\n        try {\n          fieldSchema.parse(value);\n          setFieldError(fieldKey);\n        } catch (error) {\n          if (error &amp;&amp; typeof error === \&quot;object\&quot; &amp;&amp; \&quot;issues\&quot; in error) {\n            const zodError = error as { issues: Array&lt;{ message: string }&gt; };\n            const firstIssue = zodError.issues[0];\n            if (firstIssue) {\n              setFieldError(fieldKey, firstIssue.message);\n            }\n          } else if (error instanceof Error) {\n            setFieldError(fieldKey, error.message);\n          }\n        }\n      };\n\n      if (immediate) {\n        performValidation();\n      } else {\n        validationTimersRef.current[fieldKey] = setTimeout(performValidation, 300);\n      }\n    },\n    [setFieldError]\n  );\n\n  const handleFieldChange = useCallback(\n    (fieldKey: string, value: unknown) =&gt; {\n      setFieldValue(fieldKey, value);\n      if (state.touched.has(fieldKey)) {\n        validateField(fieldKey, value, false);\n      }\n    },\n    [setFieldValue, state.touched, validateField]\n  );\n\n  const handleFieldBlur = useCallback(\n    (fieldKey: string) =&gt; {\n      markFieldTouched(fieldKey);\n      validateField(fieldKey, state.formData[fieldKey], true);\n    },\n    [markFieldTouched, state.formData, validateField]\n  );\n\n  const autosaveFingerprint = useMemo(\n    () =&gt; JSON.stringify({ data: state.formData, step: state.currentStep }),\n    [state.formData, state.currentStep]\n  );\n\n  const runDraftSave = useCallback(() =&gt; {\n    return saveFormDraft({\n      formConfigId: formConfig.id,\n      organizationId,\n      entityId: formConfig.entityId,\n      geographyId: formConfig.geographyId,\n      applicationId,\n      formData: state.formData,\n      currentStep: state.currentStep,\n    });\n  }, [\n    applicationId,\n    formConfig.entityId,\n    formConfig.geographyId,\n    formConfig.id,\n    organizationId,\n    state.currentStep,\n    state.formData,\n  ]);\n\n  const {\n    status: draftStatus,\n    isSaving: isSavingDraft,\n    lastSavedAt,\n    error: draftError,\n    triggerSave,\n  } = useAutosave&lt;DraftSaveResult&gt;({\n    shouldAutosave: state.isDirty,\n    dataFingerprint: autosaveFingerprint,\n    save: runDraftSave,\n    onSuccess: (result) =&gt; {\n      markClean();\n      if (result.applicationId &amp;&amp; result.applicationId !== applicationId) {\n        onApplicationIdChange?.(result.applicationId);\n      }\n      onDraftSaved?.(result);\n    },\n    onError: (error) =&gt; {\n      toast({\n        variant: \&quot;destructive\&quot;,\n        title: \&quot;Draft save failed\&quot;,\n        description: error.message,\n      });\n    },\n  });\n\n  const handleNext = useCallback(async () =&gt; {\n    if (state.isSubmitting) {\n      return;\n    }\n\n    const validation = validateAndCommitStep(state.currentStep);\n    if (!validation.isValid) {\n      toast({\n        variant: \&quot;destructive\&quot;,\n        title: \&quot;Please fix validation errors\&quot;,\n        description: \&quot;Resolve highlighted fields before continuing.\&quot;,\n      });\n      focusFirstError(validation.firstErrorField);\n      return;\n    }\n\n    markStepComplete(state.currentStep);\n\n    if (isLastStep &amp;&amp; onComplete) {\n      try {\n        setIsSubmitting(true);\n        await onComplete(state.formData);\n        toast({\n          title: \&quot;Form submitted\&quot;,\n          description: \&quot;Thank you! We received your information.\&quot;,\n        });\n      } catch (error) {\n        toast({\n          variant: \&quot;destructive\&quot;,\n          title: \&quot;Submission failed\&quot;,\n          description:\n            error instanceof Error\n              ? error.message\n              : \&quot;Something went wrong while submitting. Please try again.\&quot;,\n        });\n      } finally {\n        setIsSubmitting(false);\n      }\n      return;\n    }\n\n    const nextStep = state.currentStep + 1;\n    goToStep(nextStep);\n    onStepChange?.(nextStep);\n    void triggerSave(\&quot;step-change\&quot;);\n  }, [\n    focusFirstError,\n    goToStep,\n    isLastStep,\n    markStepComplete,\n    onComplete,\n    onStepChange,\n    setIsSubmitting,\n    state.currentStep,\n    state.formData,\n    state.isSubmitting,\n    toast,\n    triggerSave,\n    validateAndCommitStep,\n  ]);\n\n  const handlePrevious = useCallback(() =&gt; {\n    if (isFirstStep) {\n      return;\n    }\n    const prevStep = state.currentStep - 1;\n    goToStep(prevStep);\n    onStepChange?.(prevStep);\n  }, [goToStep, isFirstStep, onStepChange, state.currentStep]);\n\n  const handleStepClick = useCallback(\n    (stepIndex: number) =&gt; {\n      if (stepIndex === state.currentStep) {\n        return;\n      }\n\n      const validation = validateAndCommitStep(state.currentStep);\n      if (!validation.isValid) {\n        toast({\n          variant: \&quot;destructive\&quot;,\n          title: \&quot;Cannot leave step yet\&quot;,\n          description: \&quot;Fix validation errors before moving on.\&quot;,\n        });\n        focusFirstError(validation.firstErrorField);\n        return;\n      }\n\n      if (\n        state.completedSteps.has(stepIndex) ||\n        stepIndex === state.currentStep + 1\n      ) {\n        goToStep(stepIndex);\n        onStepChange?.(stepIndex);\n        void triggerSave(\&quot;step-change\&quot;);\n      }\n    },\n    [\n      focusFirstError,\n      goToStep,\n      onStepChange,\n      state.completedSteps,\n      state.currentStep,\n      toast,\n      triggerSave,\n      validateAndCommitStep,\n    ]\n  );\n\n  const handleManualSave = useCallback(() =&gt; {\n    void triggerSave(\&quot;manual\&quot;);\n  }, [triggerSave]);\n\n  useEffect(() =&gt; {\n    return () =&gt; {\n      Object.values(validationTimersRef.current).forEach((timer) =&gt; {\n        clearTimeout(timer);\n      });\n    };\n  }, []);\n\n  useEffect(() =&gt; {\n    const sectionLabel = currentSection?.label ?? &#96;Step ${state.currentStep + 1}&#96;;\n    setLiveMessage(\n      &#96;Now viewing ${sectionLabel} (${state.currentStep + 1} of ${totalSteps})&#96;\n    );\n  }, [currentSection, state.currentStep, totalSteps]);\n\n  const progress =\n    totalSteps &gt; 0 ? ((state.currentStep + 1) / totalSteps) * 100 : 0;\n\n  return (\n    &lt;div className=\&quot;flex flex-col gap-6 pb-32 sm:pb-12\&quot;&gt;\n      &lt;StepIndicator\n        steps={sortedSections.map((section) =&gt; ({\n          id: section.id,\n          label: section.label,\n          order: section.order,\n        }))}\n        currentStep={state.currentStep}\n        completedSteps={state.completedSteps}\n        onStepClick={handleStepClick}\n      /&gt;\n\n      &lt;div\n        className={cn(\n          \&quot;min-h-[400px] space-y-6 rounded-3xl border border-border/60 bg-background/70 p-4 shadow-lg sm:p-8\&quot;,\n          !prefersReducedMotion &amp;&amp; \&quot;transition-shadow duration-300\&quot;\n        )}\n      &gt;\n        {(() =&gt; {\n          const stepFieldKeys = getStepFieldKeys(state.currentStep, formConfig);\n          const stepErrors: Record&lt;string, string&gt; = {};\n          stepFieldKeys.forEach((key) =&gt; {\n            if (state.errors[key] &amp;&amp; touchedMap[key]) {\n              stepErrors[key] = state.errors[key];\n            }\n          });\n\n          if (Object.keys(stepErrors).length &gt; 0) {\n            return (\n              &lt;FormErrorSummary\n                errors={stepErrors}\n                onErrorClick={(fieldKey) =&gt; focusFirstError(fieldKey)}\n              /&gt;\n            );\n          }\n          return null;\n        })()}\n\n        {currentSection &amp;&amp; (\n          &lt;FormStep\n            section={currentSection}\n            formData={state.formData}\n            errors={state.errors}\n            touched={touchedMap}\n            onFieldChange={handleFieldChange}\n            onFieldBlur={handleFieldBlur}\n          /&gt;\n        )}\n      &lt;/div&gt;\n\n      &lt;FormNavigation\n        isFirstStep={isFirstStep}\n        isLastStep={isLastStep}\n        onNext={handleNext}\n        onPrevious={handlePrevious}\n        onSaveDraft={handleManualSave}\n        progress={progress}\n        isSubmitting={state.isSubmitting}\n        isSavingDraft={isSavingDraft}\n        draftStatus={draftStatus}\n        draftError={draftError}\n        lastSavedAt={lastSavedAt}\n      /&gt;\n      &lt;p role=\&quot;status\&quot; aria-live=\&quot;polite\&quot; className=\&quot;sr-only\&quot;&gt;\n        {liveMessage}\n      &lt;/p&gt;\n    &lt;/div&gt;\n  );\n}\n\&quot;use client\&quot;;\n\nimport { useState, useCallback, useRef, useEffect } from \&quot;react\&quot;;\nimport type { FormConfigWithFields } from \&quot;@/lib/forms/types\&quot;;\nimport { validateStep, getStepFieldKeys } from \&quot;@/lib/forms/form-validator\&quot;;\nimport { buildFormSchema } from \&quot;@/lib/form-schema\&quot;;\nimport { StepIndicator } from \&quot;./step-indicator\&quot;;\nimport { FormStep } from \&quot;./form-step\&quot;;\nimport { FormNavigation } from \&quot;./form-navigation\&quot;;\nimport { FormErrorSummary } from \&quot;./form-error-summary\&quot;;\nimport { usePrefersReducedMotion } from \&quot;@/hooks/use-prefers-reduced-motion\&quot;;\nimport { useToast } from \&quot;@/components/ui/use-toast\&quot;;\nimport { cn } from \&quot;@/lib/utils\&quot;;\nimport type { DraftStatus } from \&quot;./draft-save-indicator\&quot;;\n\ninterface DynamicFormWizardProps {\n  formConfig: FormConfigWithFields;\n  initialData?: Record&lt;string, unknown&gt;;\n  onStepChange?: (stepIndex: number) =&gt; void;\n  onComplete?: (formData: Record&lt;string, unknown&gt;) =&gt; void;\n  onSaveDraft?: (formData: Record&lt;string, unknown&gt;) =&gt; void;\n}\n\nexport function DynamicFormWizard({\n  formConfig,\n  initialData = {},\n  onStepChange,\n  onComplete,\n  onSaveDraft,\n}: DynamicFormWizardProps) {\n  const sortedSections = [...formConfig.sections].sort(\n    (a, b) =&gt; a.order - b.order\n  );\n\n  const [currentStep, setCurrentStep] = useState(0);\n  const [formData, setFormData] = useState&lt;Record&lt;string, unknown&gt;&gt;(\n    initialData\n  );\n  const [completedSteps, setCompletedSteps] = useState&lt;Set&lt;number&gt;&gt;(\n    new Set()\n  );\n  const [errors, setErrors] = useState&lt;Record&lt;string, string&gt;&gt;({});\n  const [touched, setTouched] = useState&lt;Record&lt;string, boolean&gt;&gt;({});\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  const [isSavingDraft, setIsSavingDraft] = useState(false);\n  const [draftStatus, setDraftStatus] = useState&lt;DraftStatus&gt;(\&quot;idle\&quot;);\n  const [draftError, setDraftError] = useState&lt;string | null&gt;(null);\n  const [lastSavedAt, setLastSavedAt] = useState&lt;Date | null&gt;(null);\n  const [liveMessage, setLiveMessage] = useState(\&quot;\&quot;);\n  const validationTimersRef = useRef&lt;Record&lt;string, NodeJS.Timeout&gt;&gt;({});\n  const formSchemaRef = useRef(buildFormSchema(formConfig));\n  const prefersReducedMotion = usePrefersReducedMotion();\n  const { toast } = useToast();\n\n  const totalSteps = sortedSections.length;\n  const currentSection = sortedSections[currentStep];\n  const isFirstStep = currentStep === 0;\n  const isLastStep = currentStep === totalSteps - 1;\n\n  // Rebuild schema if form config changes\n  useEffect(() =&gt; {\n    formSchemaRef.current = buildFormSchema(formConfig);\n  }, [formConfig]);\n\n  /**\n   * Validate a single field with debouncing\n   */\n  const validateField = useCallback(\n    (fieldKey: string, value: unknown, immediate = false) =&gt; {\n      // Clear existing timer for this field\n      if (validationTimersRef.current[fieldKey]) {\n        clearTimeout(validationTimersRef.current[fieldKey]);\n      }\n\n      const performValidation = () =&gt; {\n        const fieldSchema = formSchemaRef.current.shape[fieldKey];\n        if (!fieldSchema) {\n          return;\n        }\n\n        try {\n          fieldSchema.parse(value);\n          // Clear error if validation passes\n          setErrors((prev) =&gt; {\n            const next = { ...prev };\n            delete next[fieldKey];\n            return next;\n          });\n        } catch (error) {\n          if (error &amp;&amp; typeof error === \&quot;object\&quot; &amp;&amp; \&quot;issues\&quot; in error) {\n            const zodError = error as { issues: Array&lt;{ message: string }&gt; };\n            const firstIssue = zodError.issues[0];\n            if (firstIssue) {\n              setErrors((prev) =&gt; ({\n                ...prev,\n                [fieldKey]: firstIssue.message,\n              }));\n            }\n          } else if (error instanceof Error) {\n            setErrors((prev) =&gt; ({\n              ...prev,\n              [fieldKey]: error.message,\n            }));\n          }\n        }\n      };\n\n      if (immediate) {\n        performValidation();\n      } else {\n        // Debounce validation on change (300ms)\n        validationTimersRef.current[fieldKey] = setTimeout(performValidation, 300);\n      }\n    },\n    []\n  );\n\n  const handleFieldChange = useCallback(\n    (fieldKey: string, value: unknown) =&gt; {\n      setFormData((prev) =&gt; ({\n        ...prev,\n        [fieldKey]: value,\n      }));\n\n      // Validate on change with debounce (only if field has been touched)\n      if (touched[fieldKey]) {\n        validateField(fieldKey, value, false);\n      }\n    },\n    [touched, validateField]\n  );\n\n  const handleFieldBlur = useCallback(\n    (fieldKey: string) =&gt; {\n      setTouched((prev) =&gt; ({\n        ...prev,\n        [fieldKey]: true,\n      }));\n\n      // Validate immediately on blur\n      const value = formData[fieldKey];\n      validateField(fieldKey, value, true);\n    },\n    [formData, validateField]\n  );\n\n  /**\n   * Validate current step using the validation utilities\n   */\n  const validateCurrentStep = useCallback((): boolean =&gt; {\n    const stepResult = validateStep(currentStep, formData, formConfig);\n\n    if (!stepResult.isValid) {\n      // Update errors for current step fields only\n      const stepFieldKeys = getStepFieldKeys(currentStep, formConfig);\n      setErrors((prev) =&gt; {\n        const next = { ...prev };\n        // Clear errors for fields not in current step\n        stepFieldKeys.forEach((key) =&gt; {\n          if (stepResult.errors[key]) {\n            next[key] = stepResult.errors[key];\n          } else {\n            delete next[key];\n          }\n        });\n        return next;\n      });\n\n      // Mark all fields in step as touched\n      setTouched((prev) =&gt; {\n        const next = { ...prev };\n        stepFieldKeys.forEach((key) =&gt; {\n          next[key] = true;\n        });\n        return next;\n      });\n\n      // Focus first error field\n      if (stepResult.firstErrorField) {\n        // Find the field by key to get its ID\n        const errorField = currentSection.fields.find(\n          (f) =&gt; f.key === stepResult.firstErrorField\n        );\n        if (errorField) {\n          // Field components use &#96;field-${field.id}&#96; as the ID\n          const fieldElement = document.getElementById(&#96;field-${errorField.id}&#96;);\n          if (fieldElement) {\n            fieldElement.focus();\n            fieldElement.scrollIntoView({ behavior: \&quot;smooth\&quot;, block: \&quot;center\&quot; });\n          }\n        }\n      }\n    }\n\n    return stepResult.isValid;\n  }, [currentStep, formData, formConfig, currentSection]);\n\n  const handleNext = useCallback(async () =&gt; {\n    if (isSubmitting) {\n      return;\n    }\n\n    const isStepValid = validateCurrentStep();\n    if (!isStepValid) {\n      toast({\n        variant: \&quot;destructive\&quot;,\n        title: \&quot;Please fix validation errors\&quot;,\n        description: \&quot;Resolve highlighted fields before continuing.\&quot;,\n      });\n      return;\n    }\n\n    setCompletedSteps((prev) =&gt; new Set(prev).add(currentStep));\n\n    if (isLastStep) {\n      if (!onComplete) {\n        return;\n      }\n      try {\n        setIsSubmitting(true);\n        await onComplete(formData);\n        toast({\n          title: \&quot;Form submitted\&quot;,\n          description: \&quot;Thanks! We received your information.\&quot;,\n        });\n      } catch (error) {\n        toast({\n          variant: \&quot;destructive\&quot;,\n          title: \&quot;Submission failed\&quot;,\n          description:\n            error instanceof Error\n              ? error.message\n              : \&quot;Something went wrong while submitting. Please try again.\&quot;,\n        });\n      } finally {\n        setIsSubmitting(false);\n      }\n    } else {\n      const nextStep = currentStep + 1;\n      setCurrentStep(nextStep);\n      onStepChange?.(nextStep);\n    }\n  }, [\n    currentStep,\n    formData,\n    isLastStep,\n    isSubmitting,\n    onComplete,\n    onStepChange,\n    toast,\n    validateCurrentStep,\n  ]);\n\n  const handlePrevious = useCallback(() =&gt; {\n    if (!isFirstStep) {\n      const prevStep = currentStep - 1;\n      setCurrentStep(prevStep);\n      onStepChange?.(prevStep);\n    }\n  }, [currentStep, isFirstStep, onStepChange]);\n\n  const handleStepClick = useCallback(\n    (stepIndex: number) =&gt; {\n      // Validate current step before allowing navigation\n      if (stepIndex !== currentStep) {\n        if (!validateCurrentStep()) {\n          return; // Don&#39;t allow navigation if current step is invalid\n        }\n      }\n\n      // Allow navigation to completed steps or the next step\n      if (completedSteps.has(stepIndex) || stepIndex === currentStep + 1) {\n        setCurrentStep(stepIndex);\n        onStepChange?.(stepIndex);\n      }\n    },\n    [completedSteps, currentStep, onStepChange, validateCurrentStep]\n  );\n\n  const handleSaveDraft = useCallback(async () =&gt; {\n    if (!onSaveDraft || isSavingDraft) {\n      return;\n    }\n    try {\n      setIsSavingDraft(true);\n      setDraftStatus(\&quot;saving\&quot;);\n      setDraftError(null);\n      await onSaveDraft(formData);\n      setDraftStatus(\&quot;success\&quot;);\n      const savedAt = new Date();\n      setLastSavedAt(savedAt);\n      toast({\n        title: \&quot;Draft saved\&quot;,\n        description: &#96;Progress saved at ${savedAt.toLocaleTimeString([], {\n          hour: \&quot;numeric\&quot;,\n          minute: \&quot;2-digit\&quot;,\n        })}&#96;,\n      });\n    } catch (error) {\n      setDraftStatus(\&quot;error\&quot;);\n      const message =\n        error instanceof Error\n          ? error.message\n          : \&quot;Unable to save your draft right now.\&quot;;\n      setDraftError(message);\n      toast({\n        variant: \&quot;destructive\&quot;,\n        title: \&quot;Draft not saved\&quot;,\n        description: message,\n      });\n    } finally {\n      setIsSavingDraft(false);\n    }\n  }, [formData, isSavingDraft, onSaveDraft, toast]);\n\n  // Cleanup timers on unmount\n  useEffect(() =&gt; {\n    const timers = validationTimersRef.current;\n    return () =&gt; {\n      Object.values(timers).forEach((timer) =&gt; {\n        clearTimeout(timer);\n      });\n    };\n  }, []);\n\n  const progress = totalSteps &gt; 0 ? ((currentStep + 1) / totalSteps) * 100 : 0;\n\n  useEffect(() =&gt; {\n    const sectionLabel = currentSection?.label ?? &#96;Step ${currentStep + 1}&#96;;\n    setLiveMessage(&#96;Now viewing ${sectionLabel} (${currentStep + 1} of ${totalSteps})&#96;);\n  }, [currentSection, currentStep, totalSteps]);\n\n  return (\n    &lt;div className=\&quot;flex flex-col gap-6 pb-32 sm:pb-12\&quot;&gt;\n      &lt;StepIndicator\n        steps={sortedSections.map((section, index) =&gt; ({\n          id: section.id,\n          label: section.label,\n          order: section.order,\n        }))}\n        currentStep={currentStep}\n        completedSteps={completedSteps}\n        onStepClick={handleStepClick}\n      /&gt;\n\n      &lt;div\n        className={cn(\n          \&quot;min-h-[400px] space-y-6 rounded-3xl border border-border/60 bg-background/70 p-4 shadow-lg sm:p-8\&quot;,\n          !prefersReducedMotion &amp;&amp; \&quot;transition-shadow duration-300\&quot;\n        )}\n      &gt;\n        {/* Error summary for current step */}\n        {(() =&gt; {\n          const stepFieldKeys = getStepFieldKeys(currentStep, formConfig);\n          const stepErrors: Record&lt;string, string&gt; = {};\n          stepFieldKeys.forEach((key) =&gt; {\n            if (errors[key] &amp;&amp; touched[key]) {\n              stepErrors[key] = errors[key];\n            }\n          });\n\n          if (Object.keys(stepErrors).length &gt; 0) {\n            return (\n              &lt;FormErrorSummary\n                errors={stepErrors}\n                onErrorClick={(fieldKey) =&gt; {\n                  // Find the field by key to get its ID\n                  const errorField = currentSection.fields.find(\n                    (f) =&gt; f.key === fieldKey\n                  );\n                  if (errorField) {\n                    // Field components use &#96;field-${field.id}&#96; as the ID\n                    const fieldElement = document.getElementById(&#96;field-${errorField.id}&#96;);\n                    if (fieldElement) {\n                      fieldElement.focus();\n                      fieldElement.scrollIntoView({\n                        behavior: \&quot;smooth\&quot;,\n                        block: \&quot;center\&quot;,\n                      });\n                    }\n                  }\n                }}\n              /&gt;\n            );\n          }\n          return null;\n        })()}\n\n        &lt;FormStep\n          section={currentSection}\n          formData={formData}\n          errors={errors}\n          touched={touched}\n          onFieldChange={handleFieldChange}\n          onFieldBlur={handleFieldBlur}\n        /&gt;\n      &lt;/div&gt;\n\n      &lt;FormNavigation\n        isFirstStep={isFirstStep}\n        isLastStep={isLastStep}\n        onNext={handleNext}\n        onPrevious={handlePrevious}\n        onSaveDraft={handleSaveDraft}\n        progress={progress}\n        isSubmitting={isSubmitting}\n        isSavingDraft={isSavingDraft}\n        draftStatus={draftStatus}\n        draftError={draftError}\n        lastSavedAt={lastSavedAt}\n      /&gt;\n      &lt;p role=\&quot;status\&quot; aria-live=\&quot;polite\&quot; className=\&quot;sr-only\&quot;&gt;\n        {liveMessage}\n      &lt;/p&gt;\n    &lt;/div&gt;\n  );\n}\n\n&quot;
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Verifying file contents**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/sahilmehta/supplier-onboarding-simple/components/forms/dynamic-form-wizard.tsx</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Removing duplicate file section**</details></think>

---

The model made no changes to the file.

---

<think><details><summary>Thought Process</summary>
**Planning targeted deletion**</details></think>

---

The model made no changes to the file.

---

<think><details><summary>Thought Process</summary>
**Removing duplicate "use client" block**</details></think>

---

The model made no changes to the file.

---

<think><details><summary>Thought Process</summary>
**Simplifying file update process**</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  &quot;relativeWorkspacePath&quot;: &quot;/Users/sahilmehta/supplier-onboarding-simple/components/forms/dynamic-form-wizard.tsx&quot;
}
```
Additional data:

```json
{
  &quot;codeblockId&quot;: &quot;22c245e1-26b0-40e3-baa7-c08e8cc5d032&quot;,
  &quot;reviewData&quot;: {
    &quot;status&quot;: &quot;None&quot;,
    &quot;selectedOption&quot;: &quot;accept&quot;,
    &quot;isShowingInput&quot;: false,
    &quot;firstTimeReviewMode&quot;: false
  }
}
```
Result:

```json
{
  &quot;diff&quot;: {
    &quot;chunks&quot;: [
      {
        &quot;diffString&quot;: &quot;      validateAndCommitStep,\n    ]);\n+ \n+   const handlePrevious = useCallback(() =&gt; {\n+     if (isFirstStep) {\n+       return;\n+     }\n+     const prevStep = state.currentStep - 1;\n+     goToStep(prevStep);\n+     onStepChange?.(prevStep);\n+   }, [goToStep, isFirstStep, onStepChange, state.currentStep]);\n+ \n+   const handleStepClick = useCallback(\n+     (stepIndex: number) =&gt; {\n+       if (stepIndex === state.currentStep) {\n+         return;\n+       }\n+ \n+       const validation = validateAndCommitStep(state.currentStep);\n+       if (!validation.isValid) {\n+         toast({\n+           variant: \&quot;destructive\&quot;,\n+           title: \&quot;Cannot leave step yet\&quot;,\n+           description: \&quot;Fix validation errors before moving on.\&quot;,\n+         });\n+         focusFirstError(validation.firstErrorField);\n+         return;\n+       }\n+ \n+       if (\n+         state.completedSteps.has(stepIndex) ||\n+         stepIndex === state.currentStep + 1\n+       ) {\n+         goToStep(stepIndex);\n+         onStepChange?.(stepIndex);\n+         void triggerSave(\&quot;step-change\&quot;);\n+       }\n+     },\n+     [\n+       focusFirstError,\n+       goToStep,\n+       onStepChange,\n+       state.completedSteps,\n+       state.currentStep,\n+       toast,\n+       triggerSave,\n+       validateAndCommitStep,\n+     ]\n+   );\n+ \n+   const handleManualSave = useCallback(() =&gt; {\n+     void triggerSave(\&quot;manual\&quot;);\n+   }, [triggerSave]);\n+ \n+   useEffect(() =&gt; {\n+     return () =&gt; {\n+       Object.values(validationTimersRef.current).forEach((timer) =&gt; {\n+         clearTimeout(timer);\n+       });\n+     };\n+   }, []);\n+ \n+   useEffect(() =&gt; {\n+     const sectionLabel = currentSection?.label ?? &#96;Step ${state.currentStep + 1}&#96;;\n+     setLiveMessage(\n+       &#96;Now viewing ${sectionLabel} (${state.currentStep + 1} of ${totalSteps})&#96;\n+     );\n+   }, [currentSection, state.currentStep, totalSteps]);\n+ \n+   const progress =\n+     totalSteps &gt; 0 ? ((state.currentStep + 1) / totalSteps) * 100 : 0;\n+ \n+   return (\n+     &lt;div className=\&quot;flex flex-col gap-6 pb-32 sm:pb-12\&quot;&gt;\n+       &lt;StepIndicator\n+         steps={sortedSections.map((section) =&gt; ({\n+           id: section.id,\n+           label: section.label,\n+           order: section.order,\n+         }))}\n+         currentStep={state.currentStep}\n+         completedSteps={state.completedSteps}\n+         onStepClick={handleStepClick}\n+       /&gt;\n+ \n+       &lt;div\n+         className={cn(\n+           \&quot;min-h-[400px] space-y-6 rounded-3xl border border-border/60 bg-background/70 p-4 shadow-lg sm:p-8\&quot;,\n+           !prefersReducedMotion &amp;&amp; \&quot;transition-shadow duration-300\&quot;\n+         )}\n+       &gt;\n+         {(() =&gt; {\n+           const stepFieldKeys = getStepFieldKeys(state.currentStep, formConfig);\n+           const stepErrors: Record&lt;string, string&gt; = {};\n+           stepFieldKeys.forEach((key) =&gt; {\n+             if (state.errors[key] &amp;&amp; touchedMap[key]) {\n+               stepErrors[key] = state.errors[key];\n+             }\n+           });\n+ \n+           if (Object.keys(stepErrors).length &gt; 0) {\n+             return (\n+               &lt;FormErrorSummary\n+                 errors={stepErrors}\n+                 onErrorClick={(fieldKey) =&gt; focusFirstError(fieldKey)}\n+               /&gt;\n+             );\n+           }\n+           return null;\n+         })()}\n+ \n+         {currentSection &amp;&amp; (\n+           &lt;FormStep\n+             section={currentSection}\n+             formData={state.formData}\n+             errors={state.errors}\n+             touched={touchedMap}\n+             onFieldChange={handleFieldChange}\n+             onFieldBlur={handleFieldBlur}\n+           /&gt;\n+         )}\n+       &lt;/div&gt;\n+ \n+       &lt;FormNavigation\n+         isFirstStep={isFirstStep}\n+         isLastStep={isLastStep}\n+         onNext={handleNext}\n+         onPrevious={handlePrevious}\n+         onSaveDraft={handleManualSave}\n+         progress={progress}\n+         isSubmitting={state.isSubmitting}\n+         isSavingDraft={isSavingDraft}\n+         draftStatus={draftStatus}\n+         draftError={draftError}\n+         lastSavedAt={lastSavedAt}\n+       /&gt;\n+       &lt;p role=\&quot;status\&quot; aria-live=\&quot;polite\&quot; className=\&quot;sr-only\&quot;&gt;\n+         {liveMessage}\n+       &lt;/p&gt;\n+     &lt;/div&gt;\n+   );\n+ }\n+ \&quot;use client\&quot;;\n+ \n+ import { useCallback, useEffect, useMemo, useRef, useState } from \&quot;react\&quot;;\n+ import type { FormConfigWithFields } from \&quot;@/lib/forms/types\&quot;;\n+ import { getStepFieldKeys } from \&quot;@/lib/forms/form-validator\&quot;;\n+ import { buildFormSchema } from \&quot;@/lib/form-schema\&quot;;\n+ import { saveFormDraft, type DraftSaveResult } from \&quot;@/app/forms/actions\&quot;;\n+ import { StepIndicator } from \&quot;./step-indicator\&quot;;\n+ import { FormStep } from \&quot;./form-step\&quot;;\n+ import { FormNavigation } from \&quot;./form-navigation\&quot;;\n+ import { FormErrorSummary } from \&quot;./form-error-summary\&quot;;\n+ import { useFormState } from \&quot;@/hooks/use-form-state\&quot;;\n+ import { useAutosave } from \&quot;@/hooks/use-autosave\&quot;;\n+ import { useToast } from \&quot;@/components/ui/use-toast\&quot;;\n+ import { usePrefersReducedMotion } from \&quot;@/hooks/use-prefers-reduced-motion\&quot;;\n+ import { cn } from \&quot;@/lib/utils\&quot;;\n+ \n+ interface DynamicFormWizardProps {\n+   formConfig: FormConfigWithFields;\n+   initialData?: Record&lt;string, unknown&gt;;\n+   initialStep?: number;\n+   applicationId: string | null;\n+   organizationId: string;\n+   onApplicationIdChange?: (applicationId: string) =&gt; void;\n+   onDraftSaved?: (result: DraftSaveResult) =&gt; void;\n+   onStepChange?: (stepIndex: number) =&gt; void;\n+   onComplete?: (formData: Record&lt;string, unknown&gt;) =&gt; Promise&lt;void&gt; | void;\n+ }\n+ \n+ export function DynamicFormWizard({\n+   formConfig,\n+   initialData = {},\n+   initialStep = 0,\n+   applicationId,\n+   organizationId,\n+   onApplicationIdChange,\n+   onDraftSaved,\n+   onStepChange,\n+   onComplete,\n+ }: DynamicFormWizardProps) {\n+   const sortedSections = useMemo(\n+     () =&gt; [...formConfig.sections].sort((a, b) =&gt; a.order - b.order),\n+     [formConfig.sections]\n+   );\n+ \n+   const {\n+     state,\n+     touchedMap,\n+     setFieldValue,\n+     markFieldTouched,\n+     markFieldsTouched,\n+     setFieldError,\n+     setStepErrors,\n+     goToStep,\n+     markStepComplete,\n+     setIsSubmitting,\n+     markClean,\n+     validateAndCommitStep,\n+   } = useFormState({\n+     formConfig,\n+     initialData,\n+     initialStep,\n+   });\n+ \n+   const [liveMessage, setLiveMessage] = useState(\&quot;\&quot;);\n+   const validationTimersRef = useRef&lt;Record&lt;string, NodeJS.Timeout&gt;&gt;({});\n+   const formSchemaRef = useRef(buildFormSchema(formConfig));\n+   const prefersReducedMotion = usePrefersReducedMotion();\n+   const { toast } = useToast();\n+ \n+   const totalSteps = sortedSections.length;\n+   const currentSection = sortedSections[state.currentStep];\n+   const isFirstStep = state.currentStep === 0;\n+   const isLastStep = state.currentStep === totalSteps - 1;\n+ \n+   useEffect(() =&gt; {\n+     formSchemaRef.current = buildFormSchema(formConfig);\n+   }, [formConfig]);\n+ \n+   const focusFirstError = useCallback(\n+     (fieldKey?: string) =&gt; {\n+       if (!fieldKey || !currentSection) {\n+         return;\n+       }\n+       const errorField = currentSection.fields.find((field) =&gt; field.key === fieldKey);\n+       const fieldElement = errorField\n+         ? document.getElementById(&#96;field-${errorField.id}&#96;)\n+         : null;\n+       fieldElement?.focus();\n+       fieldElement?.scrollIntoView({ behavior: \&quot;smooth\&quot;, block: \&quot;center\&quot; });\n+     },\n+     [currentSection]\n+   );\n+ \n+   const validateField = useCallback(\n+     (fieldKey: string, value: unknown, immediate = false) =&gt; {\n+       if (validationTimersRef.current[fieldKey]) {\n+         clearTimeout(validationTimersRef.current[fieldKey]);\n+       }\n+ \n+       const performValidation = () =&gt; {\n+         const fieldSchema = formSchemaRef.current.shape[fieldKey];\n+         if (!fieldSchema) {\n+           return;\n+         }\n+ \n+         try {\n+           fieldSchema.parse(value);\n+           setFieldError(fieldKey);\n+         } catch (error) {\n+           if (error &amp;&amp; typeof error === \&quot;object\&quot; &amp;&amp; \&quot;issues\&quot; in error) {\n+             const zodError = error as { issues: Array&lt;{ message: string }&gt; };\n+             const firstIssue = zodError.issues[0];\n+             if (firstIssue) {\n+               setFieldError(fieldKey, firstIssue.message);\n+             }\n+           } else if (error instanceof Error) {\n+             setFieldError(fieldKey, error.message);\n+           }\n+         }\n+       };\n+ \n+       if (immediate) {\n+         performValidation();\n+       } else {\n+         validationTimersRef.current[fieldKey] = setTimeout(performValidation, 300);\n+       }\n+     },\n+     [setFieldError]\n+   );\n+ \n+   const handleFieldChange = useCallback(\n+     (fieldKey: string, value: unknown) =&gt; {\n+       setFieldValue(fieldKey, value);\n+       if (state.touched.has(fieldKey)) {\n+         validateField(fieldKey, value, false);\n+       }\n+     },\n+     [setFieldValue, state.touched, validateField]\n+   );\n+ \n+   const handleFieldBlur = useCallback(\n+     (fieldKey: string) =&gt; {\n+       markFieldTouched(fieldKey);\n+       validateField(fieldKey, state.formData[fieldKey], true);\n+     },\n+     [markFieldTouched, state.formData, validateField]\n+   );\n+ \n+   const autosaveFingerprint = useMemo(\n+     () =&gt; JSON.stringify({ data: state.formData, step: state.currentStep }),\n+     [state.formData, state.currentStep]\n+   );\n+ \n+   const runDraftSave = useCallback(() =&gt; {\n+     return saveFormDraft({\n+       formConfigId: formConfig.id,\n+       organizationId,\n+       entityId: formConfig.entityId,\n+       geographyId: formConfig.geographyId,\n+       applicationId,\n+       formData: state.formData,\n+       currentStep: state.currentStep,\n+     });\n+   }, [\n+     applicationId,\n+     formConfig.entityId,\n+     formConfig.geographyId,\n+     formConfig.id,\n+     organizationId,\n+     state.currentStep,\n+     state.formData,\n+   ]);\n+ \n+   const {\n+     status: draftStatus,\n+     isSaving: isSavingDraft,\n+     lastSavedAt,\n+     error: draftError,\n+     triggerSave,\n+   } = useAutosave&lt;DraftSaveResult&gt;({\n+     shouldAutosave: state.isDirty,\n+     dataFingerprint: autosaveFingerprint,\n+     save: runDraftSave,\n+     onSuccess: (result) =&gt; {\n+       markClean();\n+       if (result.applicationId &amp;&amp; result.applicationId !== applicationId) {\n+         onApplicationIdChange?.(result.applicationId);\n+       }\n+       onDraftSaved?.(result);\n+     },\n+     onError: (error) =&gt; {\n+       toast({\n+         variant: \&quot;destructive\&quot;,\n+         title: \&quot;Draft save failed\&quot;,\n+         description: error.message,\n+       });\n+     },\n+   });\n+ \n+   const handleNext = useCallback(async () =&gt; {\n+     if (state.isSubmitting) {\n+       return;\n+     }\n+ \n+     const validation = validateAndCommitStep(state.currentStep);\n+     if (!validation.isValid) {\n+       toast({\n+         variant: \&quot;destructive\&quot;,\n+         title: \&quot;Please fix validation errors\&quot;,\n+         description: \&quot;Resolve highlighted fields before continuing.\&quot;,\n+       });\n+       focusFirstError(validation.firstErrorField);\n+       return;\n+     }\n+ \n+     markStepComplete(state.currentStep);\n+ \n+     if (isLastStep &amp;&amp; onComplete) {\n+       try {\n+         setIsSubmitting(true);\n+         await onComplete(state.formData);\n+         toast({\n+           title: \&quot;Form submitted\&quot;,\n+           description: \&quot;Thank you! We received your information.\&quot;,\n+         });\n+       } catch (error) {\n+         toast({\n+           variant: \&quot;destructive\&quot;,\n+           title: \&quot;Submission failed\&quot;,\n+           description:\n+             error instanceof Error\n+               ? error.message\n+               : \&quot;Something went wrong while submitting. Please try again.\&quot;,\n+         });\n+       } finally {\n+         setIsSubmitting(false);\n+       }\n+       return;\n+     }\n+ \n+     const nextStep = state.currentStep + 1;\n+     goToStep(nextStep);\n+     onStepChange?.(nextStep);\n+     void triggerSave(\&quot;step-change\&quot;);\n+   }, [\n+     focusFirstError,\n+     goToStep,\n+     isLastStep,\n+     markStepComplete,\n+     onComplete,\n+     onStepChange,\n+     setIsSubmitting,\n+     state.currentStep,\n+     state.formData,\n+     state.isSubmitting,\n+     toast,\n+     triggerSave,\n+     validateAndCommitStep,\n+   ]);\n  \n    const handlePrevious = useCallback(() =&gt; {&quot;,
        &quot;oldStart&quot;: 259,
        &quot;newStart&quot;: 259,
        &quot;oldLines&quot;: 4,
        &quot;newLines&quot;: 404,
        &quot;linesAdded&quot;: 400
      }
    ],
    &quot;editor&quot;: &quot;EDITOR_AI&quot;
  },
  &quot;shouldAutoFixLints&quot;: true,
  &quot;resultForModel&quot;: &quot;Success. Updated the following files:\nM /Users/sahilmehta/supplier-onboarding-simple/components/forms/dynamic-form-wizard.tsx&quot;,
  &quot;contentsAfterEdit&quot;: &quot;\&quot;use client\&quot;;\n\nimport { useCallback, useEffect, useMemo, useRef, useState } from \&quot;react\&quot;;\nimport type { FormConfigWithFields } from \&quot;@/lib/forms/types\&quot;;\nimport { getStepFieldKeys } from \&quot;@/lib/forms/form-validator\&quot;;\nimport { buildFormSchema } from \&quot;@/lib/form-schema\&quot;;\nimport { saveFormDraft, type DraftSaveResult } from \&quot;@/app/forms/actions\&quot;;\nimport { StepIndicator } from \&quot;./step-indicator\&quot;;\nimport { FormStep } from \&quot;./form-step\&quot;;\nimport { FormNavigation } from \&quot;./form-navigation\&quot;;\nimport { FormErrorSummary } from \&quot;./form-error-summary\&quot;;\nimport { useFormState } from \&quot;@/hooks/use-form-state\&quot;;\nimport { useAutosave } from \&quot;@/hooks/use-autosave\&quot;;\nimport { useToast } from \&quot;@/components/ui/use-toast\&quot;;\nimport { usePrefersReducedMotion } from \&quot;@/hooks/use-prefers-reduced-motion\&quot;;\nimport { cn } from \&quot;@/lib/utils\&quot;;\n\ninterface DynamicFormWizardProps {\n  formConfig: FormConfigWithFields;\n  initialData?: Record&lt;string, unknown&gt;;\n  initialStep?: number;\n  applicationId: string | null;\n  organizationId: string;\n  onApplicationIdChange?: (applicationId: string) =&gt; void;\n  onDraftSaved?: (result: DraftSaveResult) =&gt; void;\n  onStepChange?: (stepIndex: number) =&gt; void;\n  onComplete?: (formData: Record&lt;string, unknown&gt;) =&gt; Promise&lt;void&gt; | void;\n}\n\nexport function DynamicFormWizard({\n  formConfig,\n  initialData = {},\n  initialStep = 0,\n  applicationId,\n  organizationId,\n  onApplicationIdChange,\n  onDraftSaved,\n  onStepChange,\n  onComplete,\n}: DynamicFormWizardProps) {\n  const sortedSections = useMemo(\n    () =&gt; [...formConfig.sections].sort((a, b) =&gt; a.order - b.order),\n    [formConfig.sections]\n  );\n\n  const {\n    state,\n    touchedMap,\n    setFieldValue,\n    markFieldTouched,\n    markFieldsTouched,\n    setFieldError,\n    setStepErrors,\n    goToStep,\n    markStepComplete,\n    setIsSubmitting,\n    markClean,\n    validateAndCommitStep,\n  } = useFormState({\n    formConfig,\n    initialData,\n    initialStep,\n  });\n\n  const [liveMessage, setLiveMessage] = useState(\&quot;\&quot;);\n  const validationTimersRef = useRef&lt;Record&lt;string, NodeJS.Timeout&gt;&gt;({});\n  const formSchemaRef = useRef(buildFormSchema(formConfig));\n  const prefersReducedMotion = usePrefersReducedMotion();\n  const { toast } = useToast();\n\n  const totalSteps = sortedSections.length;\n  const currentSection = sortedSections[state.currentStep];\n  const isFirstStep = state.currentStep === 0;\n  const isLastStep = state.currentStep === totalSteps - 1;\n\n  useEffect(() =&gt; {\n    formSchemaRef.current = buildFormSchema(formConfig);\n  }, [formConfig]);\n\n  const focusFirstError = useCallback(\n    (fieldKey?: string) =&gt; {\n      if (!fieldKey || !currentSection) {\n        return;\n      }\n      const errorField = currentSection.fields.find((field) =&gt; field.key === fieldKey);\n      const fieldElement = errorField\n        ? document.getElementById(&#96;field-${errorField.id}&#96;)\n        : null;\n      fieldElement?.focus();\n      fieldElement?.scrollIntoView({ behavior: \&quot;smooth\&quot;, block: \&quot;center\&quot; });\n    },\n    [currentSection]\n  );\n\n  const validateField = useCallback(\n    (fieldKey: string, value: unknown, immediate = false) =&gt; {\n      if (validationTimersRef.current[fieldKey]) {\n        clearTimeout(validationTimersRef.current[fieldKey]);\n      }\n\n      const performValidation = () =&gt; {\n        const fieldSchema = formSchemaRef.current.shape[fieldKey];\n        if (!fieldSchema) {\n          return;\n        }\n\n        try {\n          fieldSchema.parse(value);\n          setFieldError(fieldKey);\n        } catch (error) {\n          if (error &amp;&amp; typeof error === \&quot;object\&quot; &amp;&amp; \&quot;issues\&quot; in error) {\n            const zodError = error as { issues: Array&lt;{ message: string }&gt; };\n            const firstIssue = zodError.issues[0];\n            if (firstIssue) {\n              setFieldError(fieldKey, firstIssue.message);\n            }\n          } else if (error instanceof Error) {\n            setFieldError(fieldKey, error.message);\n          }\n        }\n      };\n\n      if (immediate) {\n        performValidation();\n      } else {\n        validationTimersRef.current[fieldKey] = setTimeout(performValidation, 300);\n      }\n    },\n    [setFieldError]\n  );\n\n  const handleFieldChange = useCallback(\n    (fieldKey: string, value: unknown) =&gt; {\n      setFieldValue(fieldKey, value);\n      if (state.touched.has(fieldKey)) {\n        validateField(fieldKey, value, false);\n      }\n    },\n    [setFieldValue, state.touched, validateField]\n  );\n\n  const handleFieldBlur = useCallback(\n    (fieldKey: string) =&gt; {\n      markFieldTouched(fieldKey);\n      validateField(fieldKey, state.formData[fieldKey], true);\n    },\n    [markFieldTouched, state.formData, validateField]\n  );\n\n  const autosaveFingerprint = useMemo(\n    () =&gt; JSON.stringify({ data: state.formData, step: state.currentStep }),\n    [state.formData, state.currentStep]\n  );\n\n  const runDraftSave = useCallback(() =&gt; {\n    return saveFormDraft({\n      formConfigId: formConfig.id,\n      organizationId,\n      entityId: formConfig.entityId,\n      geographyId: formConfig.geographyId,\n      applicationId,\n      formData: state.formData,\n      currentStep: state.currentStep,\n    });\n  }, [\n    applicationId,\n    formConfig.entityId,\n    formConfig.geographyId,\n    formConfig.id,\n    organizationId,\n    state.currentStep,\n    state.formData,\n  ]);\n\n  const {\n    status: draftStatus,\n    isSaving: isSavingDraft,\n    lastSavedAt,\n    error: draftError,\n    triggerSave,\n  } = useAutosave&lt;DraftSaveResult&gt;({\n    shouldAutosave: state.isDirty,\n    dataFingerprint: autosaveFingerprint,\n    save: runDraftSave,\n    onSuccess: (result) =&gt; {\n      markClean();\n      if (result.applicationId &amp;&amp; result.applicationId !== applicationId) {\n        onApplicationIdChange?.(result.applicationId);\n      }\n      onDraftSaved?.(result);\n    },\n    onError: (error) =&gt; {\n      toast({\n        variant: \&quot;destructive\&quot;,\n        title: \&quot;Draft save failed\&quot;,\n        description: error.message,\n      });\n    },\n  });\n\n  const handleNext = useCallback(async () =&gt; {\n    if (state.isSubmitting) {\n      return;\n    }\n\n    const validation = validateAndCommitStep(state.currentStep);\n    if (!validation.isValid) {\n      toast({\n        variant: \&quot;destructive\&quot;,\n        title: \&quot;Please fix validation errors\&quot;,\n        description: \&quot;Resolve highlighted fields before continuing.\&quot;,\n      });\n      focusFirstError(validation.firstErrorField);\n      return;\n    }\n\n    markStepComplete(state.currentStep);\n\n    if (isLastStep &amp;&amp; onComplete) {\n      try {\n        setIsSubmitting(true);\n        await onComplete(state.formData);\n        toast({\n          title: \&quot;Form submitted\&quot;,\n          description: \&quot;Thank you! We received your information.\&quot;,\n        });\n      } catch (error) {\n        toast({\n          variant: \&quot;destructive\&quot;,\n          title: \&quot;Submission failed\&quot;,\n          description:\n            error instanceof Error\n              ? error.message\n              : \&quot;Something went wrong while submitting. Please try again.\&quot;,\n        });\n      } finally {\n        setIsSubmitting(false);\n      }\n      return;\n    }\n\n    const nextStep = state.currentStep + 1;\n    goToStep(nextStep);\n    onStepChange?.(nextStep);\n    void triggerSave(\&quot;step-change\&quot;);\n  }, [\n    focusFirstError,\n    goToStep,\n    isLastStep,\n    markStepComplete,\n    onComplete,\n    onStepChange,\n    setIsSubmitting,\n    state.currentStep,\n    state.formData,\n    state.isSubmitting,\n    toast,\n    triggerSave,\n    validateAndCommitStep,\n  ]);\n\n  const handlePrevious = useCallback(() =&gt; {\n    if (isFirstStep) {\n      return;\n    }\n    const prevStep = state.currentStep - 1;\n    goToStep(prevStep);\n    onStepChange?.(prevStep);\n  }, [goToStep, isFirstStep, onStepChange, state.currentStep]);\n\n  const handleStepClick = useCallback(\n    (stepIndex: number) =&gt; {\n      if (stepIndex === state.currentStep) {\n        return;\n      }\n\n      const validation = validateAndCommitStep(state.currentStep);\n      if (!validation.isValid) {\n        toast({\n          variant: \&quot;destructive\&quot;,\n          title: \&quot;Cannot leave step yet\&quot;,\n          description: \&quot;Fix validation errors before moving on.\&quot;,\n        });\n        focusFirstError(validation.firstErrorField);\n        return;\n      }\n\n      if (\n        state.completedSteps.has(stepIndex) ||\n        stepIndex === state.currentStep + 1\n      ) {\n        goToStep(stepIndex);\n        onStepChange?.(stepIndex);\n        void triggerSave(\&quot;step-change\&quot;);\n      }\n    },\n    [\n      focusFirstError,\n      goToStep,\n      onStepChange,\n      state.completedSteps,\n      state.currentStep,\n      toast,\n      triggerSave,\n      validateAndCommitStep,\n    ]\n  );\n\n  const handleManualSave = useCallback(() =&gt; {\n    void triggerSave(\&quot;manual\&quot;);\n  }, [triggerSave]);\n\n  useEffect(() =&gt; {\n    return () =&gt; {\n      Object.values(validationTimersRef.current).forEach((timer) =&gt; {\n        clearTimeout(timer);\n      });\n    };\n  }, []);\n\n  useEffect(() =&gt; {\n    const sectionLabel = currentSection?.label ?? &#96;Step ${state.currentStep + 1}&#96;;\n    setLiveMessage(\n      &#96;Now viewing ${sectionLabel} (${state.currentStep + 1} of ${totalSteps})&#96;\n    );\n  }, [currentSection, state.currentStep, totalSteps]);\n\n  const progress =\n    totalSteps &gt; 0 ? ((state.currentStep + 1) / totalSteps) * 100 : 0;\n\n  return (\n    &lt;div className=\&quot;flex flex-col gap-6 pb-32 sm:pb-12\&quot;&gt;\n      &lt;StepIndicator\n        steps={sortedSections.map((section) =&gt; ({\n          id: section.id,\n          label: section.label,\n          order: section.order,\n        }))}\n        currentStep={state.currentStep}\n        completedSteps={state.completedSteps}\n        onStepClick={handleStepClick}\n      /&gt;\n\n      &lt;div\n        className={cn(\n          \&quot;min-h-[400px] space-y-6 rounded-3xl border border-border/60 bg-background/70 p-4 shadow-lg sm:p-8\&quot;,\n          !prefersReducedMotion &amp;&amp; \&quot;transition-shadow duration-300\&quot;\n        )}\n      &gt;\n        {(() =&gt; {\n          const stepFieldKeys = getStepFieldKeys(state.currentStep, formConfig);\n          const stepErrors: Record&lt;string, string&gt; = {};\n          stepFieldKeys.forEach((key) =&gt; {\n            if (state.errors[key] &amp;&amp; touchedMap[key]) {\n              stepErrors[key] = state.errors[key];\n            }\n          });\n\n          if (Object.keys(stepErrors).length &gt; 0) {\n            return (\n              &lt;FormErrorSummary\n                errors={stepErrors}\n                onErrorClick={(fieldKey) =&gt; focusFirstError(fieldKey)}\n              /&gt;\n            );\n          }\n          return null;\n        })()}\n\n        {currentSection &amp;&amp; (\n          &lt;FormStep\n            section={currentSection}\n            formData={state.formData}\n            errors={state.errors}\n            touched={touchedMap}\n            onFieldChange={handleFieldChange}\n            onFieldBlur={handleFieldBlur}\n          /&gt;\n        )}\n      &lt;/div&gt;\n\n      &lt;FormNavigation\n        isFirstStep={isFirstStep}\n        isLastStep={isLastStep}\n        onNext={handleNext}\n        onPrevious={handlePrevious}\n        onSaveDraft={handleManualSave}\n        progress={progress}\n        isSubmitting={state.isSubmitting}\n        isSavingDraft={isSavingDraft}\n        draftStatus={draftStatus}\n        draftError={draftError}\n        lastSavedAt={lastSavedAt}\n      /&gt;\n      &lt;p role=\&quot;status\&quot; aria-live=\&quot;polite\&quot; className=\&quot;sr-only\&quot;&gt;\n        {liveMessage}\n      &lt;/p&gt;\n    &lt;/div&gt;\n  );\n}\n\&quot;use client\&quot;;\n\nimport { useCallback, useEffect, useMemo, useRef, useState } from \&quot;react\&quot;;\nimport type { FormConfigWithFields } from \&quot;@/lib/forms/types\&quot;;\nimport { getStepFieldKeys } from \&quot;@/lib/forms/form-validator\&quot;;\nimport { buildFormSchema } from \&quot;@/lib/form-schema\&quot;;\nimport { saveFormDraft, type DraftSaveResult } from \&quot;@/app/forms/actions\&quot;;\nimport { StepIndicator } from \&quot;./step-indicator\&quot;;\nimport { FormStep } from \&quot;./form-step\&quot;;\nimport { FormNavigation } from \&quot;./form-navigation\&quot;;\nimport { FormErrorSummary } from \&quot;./form-error-summary\&quot;;\nimport { useFormState } from \&quot;@/hooks/use-form-state\&quot;;\nimport { useAutosave } from \&quot;@/hooks/use-autosave\&quot;;\nimport { useToast } from \&quot;@/components/ui/use-toast\&quot;;\nimport { usePrefersReducedMotion } from \&quot;@/hooks/use-prefers-reduced-motion\&quot;;\nimport { cn } from \&quot;@/lib/utils\&quot;;\n\ninterface DynamicFormWizardProps {\n  formConfig: FormConfigWithFields;\n  initialData?: Record&lt;string, unknown&gt;;\n  initialStep?: number;\n  applicationId: string | null;\n  organizationId: string;\n  onApplicationIdChange?: (applicationId: string) =&gt; void;\n  onDraftSaved?: (result: DraftSaveResult) =&gt; void;\n  onStepChange?: (stepIndex: number) =&gt; void;\n  onComplete?: (formData: Record&lt;string, unknown&gt;) =&gt; Promise&lt;void&gt; | void;\n}\n\nexport function DynamicFormWizard({\n  formConfig,\n  initialData = {},\n  initialStep = 0,\n  applicationId,\n  organizationId,\n  onApplicationIdChange,\n  onDraftSaved,\n  onStepChange,\n  onComplete,\n}: DynamicFormWizardProps) {\n  const sortedSections = useMemo(\n    () =&gt; [...formConfig.sections].sort((a, b) =&gt; a.order - b.order),\n    [formConfig.sections]\n  );\n\n  const {\n    state,\n    touchedMap,\n    setFieldValue,\n    markFieldTouched,\n    markFieldsTouched,\n    setFieldError,\n    setStepErrors,\n    goToStep,\n    markStepComplete,\n    setIsSubmitting,\n    markClean,\n    validateAndCommitStep,\n  } = useFormState({\n    formConfig,\n    initialData,\n    initialStep,\n  });\n\n  const [liveMessage, setLiveMessage] = useState(\&quot;\&quot;);\n  const validationTimersRef = useRef&lt;Record&lt;string, NodeJS.Timeout&gt;&gt;({});\n  const formSchemaRef = useRef(buildFormSchema(formConfig));\n  const prefersReducedMotion = usePrefersReducedMotion();\n  const { toast } = useToast();\n\n  const totalSteps = sortedSections.length;\n  const currentSection = sortedSections[state.currentStep];\n  const isFirstStep = state.currentStep === 0;\n  const isLastStep = state.currentStep === totalSteps - 1;\n\n  useEffect(() =&gt; {\n    formSchemaRef.current = buildFormSchema(formConfig);\n  }, [formConfig]);\n\n  const focusFirstError = useCallback(\n    (fieldKey?: string) =&gt; {\n      if (!fieldKey || !currentSection) {\n        return;\n      }\n      const errorField = currentSection.fields.find((field) =&gt; field.key === fieldKey);\n      const fieldElement = errorField\n        ? document.getElementById(&#96;field-${errorField.id}&#96;)\n        : null;\n      fieldElement?.focus();\n      fieldElement?.scrollIntoView({ behavior: \&quot;smooth\&quot;, block: \&quot;center\&quot; });\n    },\n    [currentSection]\n  );\n\n  const validateField = useCallback(\n    (fieldKey: string, value: unknown, immediate = false) =&gt; {\n      if (validationTimersRef.current[fieldKey]) {\n        clearTimeout(validationTimersRef.current[fieldKey]);\n      }\n\n      const performValidation = () =&gt; {\n        const fieldSchema = formSchemaRef.current.shape[fieldKey];\n        if (!fieldSchema) {\n          return;\n        }\n\n        try {\n          fieldSchema.parse(value);\n          setFieldError(fieldKey);\n        } catch (error) {\n          if (error &amp;&amp; typeof error === \&quot;object\&quot; &amp;&amp; \&quot;issues\&quot; in error) {\n            const zodError = error as { issues: Array&lt;{ message: string }&gt; };\n            const firstIssue = zodError.issues[0];\n            if (firstIssue) {\n              setFieldError(fieldKey, firstIssue.message);\n            }\n          } else if (error instanceof Error) {\n            setFieldError(fieldKey, error.message);\n          }\n        }\n      };\n\n      if (immediate) {\n        performValidation();\n      } else {\n        validationTimersRef.current[fieldKey] = setTimeout(performValidation, 300);\n      }\n    },\n    [setFieldError]\n  );\n\n  const handleFieldChange = useCallback(\n    (fieldKey: string, value: unknown) =&gt; {\n      setFieldValue(fieldKey, value);\n      if (state.touched.has(fieldKey)) {\n        validateField(fieldKey, value, false);\n      }\n    },\n    [setFieldValue, state.touched, validateField]\n  );\n\n  const handleFieldBlur = useCallback(\n    (fieldKey: string) =&gt; {\n      markFieldTouched(fieldKey);\n      validateField(fieldKey, state.formData[fieldKey], true);\n    },\n    [markFieldTouched, state.formData, validateField]\n  );\n\n  const autosaveFingerprint = useMemo(\n    () =&gt; JSON.stringify({ data: state.formData, step: state.currentStep }),\n    [state.formData, state.currentStep]\n  );\n\n  const runDraftSave = useCallback(() =&gt; {\n    return saveFormDraft({\n      formConfigId: formConfig.id,\n      organizationId,\n      entityId: formConfig.entityId,\n      geographyId: formConfig.geographyId,\n      applicationId,\n      formData: state.formData,\n      currentStep: state.currentStep,\n    });\n  }, [\n    applicationId,\n    formConfig.entityId,\n    formConfig.geographyId,\n    formConfig.id,\n    organizationId,\n    state.currentStep,\n    state.formData,\n  ]);\n\n  const {\n    status: draftStatus,\n    isSaving: isSavingDraft,\n    lastSavedAt,\n    error: draftError,\n    triggerSave,\n  } = useAutosave&lt;DraftSaveResult&gt;({\n    shouldAutosave: state.isDirty,\n    dataFingerprint: autosaveFingerprint,\n    save: runDraftSave,\n    onSuccess: (result) =&gt; {\n      markClean();\n      if (result.applicationId &amp;&amp; result.applicationId !== applicationId) {\n        onApplicationIdChange?.(result.applicationId);\n      }\n      onDraftSaved?.(result);\n    },\n    onError: (error) =&gt; {\n      toast({\n        variant: \&quot;destructive\&quot;,\n        title: \&quot;Draft save failed\&quot;,\n        description: error.message,\n      });\n    },\n  });\n\n  const handleNext = useCallback(async () =&gt; {\n    if (state.isSubmitting) {\n      return;\n    }\n\n    const validation = validateAndCommitStep(state.currentStep);\n    if (!validation.isValid) {\n      toast({\n        variant: \&quot;destructive\&quot;,\n        title: \&quot;Please fix validation errors\&quot;,\n        description: \&quot;Resolve highlighted fields before continuing.\&quot;,\n      });\n      focusFirstError(validation.firstErrorField);\n      return;\n    }\n\n    markStepComplete(state.currentStep);\n\n    if (isLastStep &amp;&amp; onComplete) {\n      try {\n        setIsSubmitting(true);\n        await onComplete(state.formData);\n        toast({\n          title: \&quot;Form submitted\&quot;,\n          description: \&quot;Thank you! We received your information.\&quot;,\n        });\n      } catch (error) {\n        toast({\n          variant: \&quot;destructive\&quot;,\n          title: \&quot;Submission failed\&quot;,\n          description:\n            error instanceof Error\n              ? error.message\n              : \&quot;Something went wrong while submitting. Please try again.\&quot;,\n        });\n      } finally {\n        setIsSubmitting(false);\n      }\n      return;\n    }\n\n    const nextStep = state.currentStep + 1;\n    goToStep(nextStep);\n    onStepChange?.(nextStep);\n    void triggerSave(\&quot;step-change\&quot;);\n  }, [\n    focusFirstError,\n    goToStep,\n    isLastStep,\n    markStepComplete,\n    onComplete,\n    onStepChange,\n    setIsSubmitting,\n    state.currentStep,\n    state.formData,\n    state.isSubmitting,\n    toast,\n    triggerSave,\n    validateAndCommitStep,\n  ]);\n\n  const handlePrevious = useCallback(() =&gt; {\n    if (isFirstStep) {\n      return;\n    }\n    const prevStep = state.currentStep - 1;\n    goToStep(prevStep);\n    onStepChange?.(prevStep);\n  }, [goToStep, isFirstStep, onStepChange, state.currentStep]);\n\n  const handleStepClick = useCallback(\n    (stepIndex: number) =&gt; {\n      if (stepIndex === state.currentStep) {\n        return;\n      }\n\n      const validation = validateAndCommitStep(state.currentStep);\n      if (!validation.isValid) {\n        toast({\n          variant: \&quot;destructive\&quot;,\n          title: \&quot;Cannot leave step yet\&quot;,\n          description: \&quot;Fix validation errors before moving on.\&quot;,\n        });\n        focusFirstError(validation.firstErrorField);\n        return;\n      }\n\n      if (\n        state.completedSteps.has(stepIndex) ||\n        stepIndex === state.currentStep + 1\n      ) {\n        goToStep(stepIndex);\n        onStepChange?.(stepIndex);\n        void triggerSave(\&quot;step-change\&quot;);\n      }\n    },\n    [\n      focusFirstError,\n      goToStep,\n      onStepChange,\n      state.completedSteps,\n      state.currentStep,\n      toast,\n      triggerSave,\n      validateAndCommitStep,\n    ]\n  );\n\n  const handleManualSave = useCallback(() =&gt; {\n    void triggerSave(\&quot;manual\&quot;);\n  }, [triggerSave]);\n\n  useEffect(() =&gt; {\n    const timers = validationTimersRef.current;\n    return () =&gt; {\n      Object.values(timers).forEach((timer) =&gt; {\n        clearTimeout(timer);\n      });\n    };\n  }, []);\n\n  useEffect(() =&gt; {\n    const sectionLabel = currentSection?.label ?? &#96;Step ${state.currentStep + 1}&#96;;\n    setLiveMessage(\n      &#96;Now viewing ${sectionLabel} (${state.currentStep + 1} of ${totalSteps})&#96;\n    );\n  }, [currentSection, state.currentStep, totalSteps]);\n\n  const progress =\n    totalSteps &gt; 0 ? ((state.currentStep + 1) / totalSteps) * 100 : 0;\n\n  return (\n    &lt;div className=\&quot;flex flex-col gap-6 pb-32 sm:pb-12\&quot;&gt;\n      &lt;StepIndicator\n        steps={sortedSections.map((section) =&gt; ({\n          id: section.id,\n          label: section.label,\n          order: section.order,\n        }))}\n        currentStep={state.currentStep}\n        completedSteps={state.completedSteps}\n        onStepClick={handleStepClick}\n      /&gt;\n\n      &lt;div\n        className={cn(\n          \&quot;min-h-[400px] space-y-6 rounded-3xl border border-border/60 bg-background/70 p-4 shadow-lg sm:p-8\&quot;,\n          !prefersReducedMotion &amp;&amp; \&quot;transition-shadow duration-300\&quot;\n        )}\n      &gt;\n        {(() =&gt; {\n          const stepFieldKeys = getStepFieldKeys(state.currentStep, formConfig);\n          const stepErrors: Record&lt;string, string&gt; = {};\n          stepFieldKeys.forEach((key) =&gt; {\n            if (state.errors[key] &amp;&amp; touchedMap[key]) {\n              stepErrors[key] = state.errors[key];\n            }\n          });\n\n          if (Object.keys(stepErrors).length &gt; 0) {\n            return (\n              &lt;FormErrorSummary\n                errors={stepErrors}\n                onErrorClick={(fieldKey) =&gt; focusFirstError(fieldKey)}\n              /&gt;\n            );\n          }\n          return null;\n        })()}\n\n        {currentSection &amp;&amp; (\n          &lt;FormStep\n            section={currentSection}\n            formData={state.formData}\n            errors={state.errors}\n            touched={touchedMap}\n            onFieldChange={handleFieldChange}\n            onFieldBlur={handleFieldBlur}\n          /&gt;\n        )}\n      &lt;/div&gt;\n\n      &lt;FormNavigation\n        isFirstStep={isFirstStep}\n        isLastStep={isLastStep}\n        onNext={handleNext}\n        onPrevious={handlePrevious}\n        onSaveDraft={handleManualSave}\n        progress={progress}\n        isSubmitting={state.isSubmitting}\n        isSavingDraft={isSavingDraft}\n        draftStatus={draftStatus}\n        draftError={draftError}\n        lastSavedAt={lastSavedAt}\n      /&gt;\n      &lt;p role=\&quot;status\&quot; aria-live=\&quot;polite\&quot; className=\&quot;sr-only\&quot;&gt;\n        {liveMessage}\n      &lt;/p&gt;\n    &lt;/div&gt;\n  );\n}\n\&quot;use client\&quot;;\n\nimport { useState, useCallback, useRef, useEffect } from \&quot;react\&quot;;\nimport type { FormConfigWithFields } from \&quot;@/lib/forms/types\&quot;;\nimport { validateStep, getStepFieldKeys } from \&quot;@/lib/forms/form-validator\&quot;;\nimport { buildFormSchema } from \&quot;@/lib/form-schema\&quot;;\nimport { StepIndicator } from \&quot;./step-indicator\&quot;;\nimport { FormStep } from \&quot;./form-step\&quot;;\nimport { FormNavigation } from \&quot;./form-navigation\&quot;;\nimport { FormErrorSummary } from \&quot;./form-error-summary\&quot;;\nimport { usePrefersReducedMotion } from \&quot;@/hooks/use-prefers-reduced-motion\&quot;;\nimport { useToast } from \&quot;@/components/ui/use-toast\&quot;;\nimport { cn } from \&quot;@/lib/utils\&quot;;\nimport type { DraftStatus } from \&quot;./draft-save-indicator\&quot;;\n\ninterface DynamicFormWizardProps {\n  formConfig: FormConfigWithFields;\n  initialData?: Record&lt;string, unknown&gt;;\n  onStepChange?: (stepIndex: number) =&gt; void;\n  onComplete?: (formData: Record&lt;string, unknown&gt;) =&gt; void;\n  onSaveDraft?: (formData: Record&lt;string, unknown&gt;) =&gt; void;\n}\n\nexport function DynamicFormWizard({\n  formConfig,\n  initialData = {},\n  onStepChange,\n  onComplete,\n  onSaveDraft,\n}: DynamicFormWizardProps) {\n  const sortedSections = [...formConfig.sections].sort(\n    (a, b) =&gt; a.order - b.order\n  );\n\n  const [currentStep, setCurrentStep] = useState(0);\n  const [formData, setFormData] = useState&lt;Record&lt;string, unknown&gt;&gt;(\n    initialData\n  );\n  const [completedSteps, setCompletedSteps] = useState&lt;Set&lt;number&gt;&gt;(\n    new Set()\n  );\n  const [errors, setErrors] = useState&lt;Record&lt;string, string&gt;&gt;({});\n  const [touched, setTouched] = useState&lt;Record&lt;string, boolean&gt;&gt;({});\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  const [isSavingDraft, setIsSavingDraft] = useState(false);\n  const [draftStatus, setDraftStatus] = useState&lt;DraftStatus&gt;(\&quot;idle\&quot;);\n  const [draftError, setDraftError] = useState&lt;string | null&gt;(null);\n  const [lastSavedAt, setLastSavedAt] = useState&lt;Date | null&gt;(null);\n  const [liveMessage, setLiveMessage] = useState(\&quot;\&quot;);\n  const validationTimersRef = useRef&lt;Record&lt;string, NodeJS.Timeout&gt;&gt;({});\n  const formSchemaRef = useRef(buildFormSchema(formConfig));\n  const prefersReducedMotion = usePrefersReducedMotion();\n  const { toast } = useToast();\n\n  const totalSteps = sortedSections.length;\n  const currentSection = sortedSections[currentStep];\n  const isFirstStep = currentStep === 0;\n  const isLastStep = currentStep === totalSteps - 1;\n\n  // Rebuild schema if form config changes\n  useEffect(() =&gt; {\n    formSchemaRef.current = buildFormSchema(formConfig);\n  }, [formConfig]);\n\n  /**\n   * Validate a single field with debouncing\n   */\n  const validateField = useCallback(\n    (fieldKey: string, value: unknown, immediate = false) =&gt; {\n      // Clear existing timer for this field\n      if (validationTimersRef.current[fieldKey]) {\n        clearTimeout(validationTimersRef.current[fieldKey]);\n      }\n\n      const performValidation = () =&gt; {\n        const fieldSchema = formSchemaRef.current.shape[fieldKey];\n        if (!fieldSchema) {\n          return;\n        }\n\n        try {\n          fieldSchema.parse(value);\n          // Clear error if validation passes\n          setErrors((prev) =&gt; {\n            const next = { ...prev };\n            delete next[fieldKey];\n            return next;\n          });\n        } catch (error) {\n          if (error &amp;&amp; typeof error === \&quot;object\&quot; &amp;&amp; \&quot;issues\&quot; in error) {\n            const zodError = error as { issues: Array&lt;{ message: string }&gt; };\n            const firstIssue = zodError.issues[0];\n            if (firstIssue) {\n              setErrors((prev) =&gt; ({\n                ...prev,\n                [fieldKey]: firstIssue.message,\n              }));\n            }\n          } else if (error instanceof Error) {\n            setErrors((prev) =&gt; ({\n              ...prev,\n              [fieldKey]: error.message,\n            }));\n          }\n        }\n      };\n\n      if (immediate) {\n        performValidation();\n      } else {\n        // Debounce validation on change (300ms)\n        validationTimersRef.current[fieldKey] = setTimeout(performValidation, 300);\n      }\n    },\n    []\n  );\n\n  const handleFieldChange = useCallback(\n    (fieldKey: string, value: unknown) =&gt; {\n      setFormData((prev) =&gt; ({\n        ...prev,\n        [fieldKey]: value,\n      }));\n\n      // Validate on change with debounce (only if field has been touched)\n      if (touched[fieldKey]) {\n        validateField(fieldKey, value, false);\n      }\n    },\n    [touched, validateField]\n  );\n\n  const handleFieldBlur = useCallback(\n    (fieldKey: string) =&gt; {\n      setTouched((prev) =&gt; ({\n        ...prev,\n        [fieldKey]: true,\n      }));\n\n      // Validate immediately on blur\n      const value = formData[fieldKey];\n      validateField(fieldKey, value, true);\n    },\n    [formData, validateField]\n  );\n\n  /**\n   * Validate current step using the validation utilities\n   */\n  const validateCurrentStep = useCallback((): boolean =&gt; {\n    const stepResult = validateStep(currentStep, formData, formConfig);\n\n    if (!stepResult.isValid) {\n      // Update errors for current step fields only\n      const stepFieldKeys = getStepFieldKeys(currentStep, formConfig);\n      setErrors((prev) =&gt; {\n        const next = { ...prev };\n        // Clear errors for fields not in current step\n        stepFieldKeys.forEach((key) =&gt; {\n          if (stepResult.errors[key]) {\n            next[key] = stepResult.errors[key];\n          } else {\n            delete next[key];\n          }\n        });\n        return next;\n      });\n\n      // Mark all fields in step as touched\n      setTouched((prev) =&gt; {\n        const next = { ...prev };\n        stepFieldKeys.forEach((key) =&gt; {\n          next[key] = true;\n        });\n        return next;\n      });\n\n      // Focus first error field\n      if (stepResult.firstErrorField) {\n        // Find the field by key to get its ID\n        const errorField = currentSection.fields.find(\n          (f) =&gt; f.key === stepResult.firstErrorField\n        );\n        if (errorField) {\n          // Field components use &#96;field-${field.id}&#96; as the ID\n          const fieldElement = document.getElementById(&#96;field-${errorField.id}&#96;);\n          if (fieldElement) {\n            fieldElement.focus();\n            fieldElement.scrollIntoView({ behavior: \&quot;smooth\&quot;, block: \&quot;center\&quot; });\n          }\n        }\n      }\n    }\n\n    return stepResult.isValid;\n  }, [currentStep, formData, formConfig, currentSection]);\n\n  const handleNext = useCallback(async () =&gt; {\n    if (isSubmitting) {\n      return;\n    }\n\n    const isStepValid = validateCurrentStep();\n    if (!isStepValid) {\n      toast({\n        variant: \&quot;destructive\&quot;,\n        title: \&quot;Please fix validation errors\&quot;,\n        description: \&quot;Resolve highlighted fields before continuing.\&quot;,\n      });\n      return;\n    }\n\n    setCompletedSteps((prev) =&gt; new Set(prev).add(currentStep));\n\n    if (isLastStep) {\n      if (!onComplete) {\n        return;\n      }\n      try {\n        setIsSubmitting(true);\n        await onComplete(formData);\n        toast({\n          title: \&quot;Form submitted\&quot;,\n          description: \&quot;Thanks! We received your information.\&quot;,\n        });\n      } catch (error) {\n        toast({\n          variant: \&quot;destructive\&quot;,\n          title: \&quot;Submission failed\&quot;,\n          description:\n            error instanceof Error\n              ? error.message\n              : \&quot;Something went wrong while submitting. Please try again.\&quot;,\n        });\n      } finally {\n        setIsSubmitting(false);\n      }\n    } else {\n      const nextStep = currentStep + 1;\n      setCurrentStep(nextStep);\n      onStepChange?.(nextStep);\n    }\n  }, [\n    currentStep,\n    formData,\n    isLastStep,\n    isSubmitting,\n    onComplete,\n    onStepChange,\n    toast,\n    validateCurrentStep,\n  ]);\n\n  const handlePrevious = useCallback(() =&gt; {\n    if (!isFirstStep) {\n      const prevStep = currentStep - 1;\n      setCurrentStep(prevStep);\n      onStepChange?.(prevStep);\n    }\n  }, [currentStep, isFirstStep, onStepChange]);\n\n  const handleStepClick = useCallback(\n    (stepIndex: number) =&gt; {\n      // Validate current step before allowing navigation\n      if (stepIndex !== currentStep) {\n        if (!validateCurrentStep()) {\n          return; // Don&#39;t allow navigation if current step is invalid\n        }\n      }\n\n      // Allow navigation to completed steps or the next step\n      if (completedSteps.has(stepIndex) || stepIndex === currentStep + 1) {\n        setCurrentStep(stepIndex);\n        onStepChange?.(stepIndex);\n      }\n    },\n    [completedSteps, currentStep, onStepChange, validateCurrentStep]\n  );\n\n  const handleSaveDraft = useCallback(async () =&gt; {\n    if (!onSaveDraft || isSavingDraft) {\n      return;\n    }\n    try {\n      setIsSavingDraft(true);\n      setDraftStatus(\&quot;saving\&quot;);\n      setDraftError(null);\n      await onSaveDraft(formData);\n      setDraftStatus(\&quot;success\&quot;);\n      const savedAt = new Date();\n      setLastSavedAt(savedAt);\n      toast({\n        title: \&quot;Draft saved\&quot;,\n        description: &#96;Progress saved at ${savedAt.toLocaleTimeString([], {\n          hour: \&quot;numeric\&quot;,\n          minute: \&quot;2-digit\&quot;,\n        })}&#96;,\n      });\n    } catch (error) {\n      setDraftStatus(\&quot;error\&quot;);\n      const message =\n        error instanceof Error\n          ? error.message\n          : \&quot;Unable to save your draft right now.\&quot;;\n      setDraftError(message);\n      toast({\n        variant: \&quot;destructive\&quot;,\n        title: \&quot;Draft not saved\&quot;,\n        description: message,\n      });\n    } finally {\n      setIsSavingDraft(false);\n    }\n  }, [formData, isSavingDraft, onSaveDraft, toast]);\n\n  // Cleanup timers on unmount\n  useEffect(() =&gt; {\n    const timers = validationTimersRef.current;\n    return () =&gt; {\n      Object.values(timers).forEach((timer) =&gt; {\n        clearTimeout(timer);\n      });\n    };\n  }, []);\n\n  const progress = totalSteps &gt; 0 ? ((currentStep + 1) / totalSteps) * 100 : 0;\n\n  useEffect(() =&gt; {\n    const sectionLabel = currentSection?.label ?? &#96;Step ${currentStep + 1}&#96;;\n    setLiveMessage(&#96;Now viewing ${sectionLabel} (${currentStep + 1} of ${totalSteps})&#96;);\n  }, [currentSection, currentStep, totalSteps]);\n\n  return (\n    &lt;div className=\&quot;flex flex-col gap-6 pb-32 sm:pb-12\&quot;&gt;\n      &lt;StepIndicator\n        steps={sortedSections.map((section, index) =&gt; ({\n          id: section.id,\n          label: section.label,\n          order: section.order,\n        }))}\n        currentStep={currentStep}\n        completedSteps={completedSteps}\n        onStepClick={handleStepClick}\n      /&gt;\n\n      &lt;div\n        className={cn(\n          \&quot;min-h-[400px] space-y-6 rounded-3xl border border-border/60 bg-background/70 p-4 shadow-lg sm:p-8\&quot;,\n          !prefersReducedMotion &amp;&amp; \&quot;transition-shadow duration-300\&quot;\n        )}\n      &gt;\n        {/* Error summary for current step */}\n        {(() =&gt; {\n          const stepFieldKeys = getStepFieldKeys(currentStep, formConfig);\n          const stepErrors: Record&lt;string, string&gt; = {};\n          stepFieldKeys.forEach((key) =&gt; {\n            if (errors[key] &amp;&amp; touched[key]) {\n              stepErrors[key] = errors[key];\n            }\n          });\n\n          if (Object.keys(stepErrors).length &gt; 0) {\n            return (\n              &lt;FormErrorSummary\n                errors={stepErrors}\n                onErrorClick={(fieldKey) =&gt; {\n                  // Find the field by key to get its ID\n                  const errorField = currentSection.fields.find(\n                    (f) =&gt; f.key === fieldKey\n                  );\n                  if (errorField) {\n                    // Field components use &#96;field-${field.id}&#96; as the ID\n                    const fieldElement = document.getElementById(&#96;field-${errorField.id}&#96;);\n                    if (fieldElement) {\n                      fieldElement.focus();\n                      fieldElement.scrollIntoView({\n                        behavior: \&quot;smooth\&quot;,\n                        block: \&quot;center\&quot;,\n                      });\n                    }\n                  }\n                }}\n              /&gt;\n            );\n          }\n          return null;\n        })()}\n\n        &lt;FormStep\n          section={currentSection}\n          formData={formData}\n          errors={errors}\n          touched={touched}\n          onFieldChange={handleFieldChange}\n          onFieldBlur={handleFieldBlur}\n        /&gt;\n      &lt;/div&gt;\n\n      &lt;FormNavigation\n        isFirstStep={isFirstStep}\n        isLastStep={isLastStep}\n        onNext={handleNext}\n        onPrevious={handlePrevious}\n        onSaveDraft={handleSaveDraft}\n        progress={progress}\n        isSubmitting={isSubmitting}\n        isSavingDraft={isSavingDraft}\n        draftStatus={draftStatus}\n        draftError={draftError}\n        lastSavedAt={lastSavedAt}\n      /&gt;\n      &lt;p role=\&quot;status\&quot; aria-live=\&quot;polite\&quot; className=\&quot;sr-only\&quot;&gt;\n        {liveMessage}\n      &lt;/p&gt;\n    &lt;/div&gt;\n  );\n}\n\n&quot;
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Verifying unique files**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/sahilmehta/supplier-onboarding-simple/components/forms/dynamic-form-wizard.tsx</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Planning file replacement approach**</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  &quot;relativeWorkspacePath&quot;: &quot;/Users/sahilmehta/supplier-onboarding-simple/components/forms/dynamic-form-wizard.tsx&quot;
}
```
Additional data:

```json
{
  &quot;codeblockId&quot;: &quot;91d73f08-82f6-4931-95d8-c1bb9e64ff26&quot;,
  &quot;reviewData&quot;: {
    &quot;status&quot;: &quot;None&quot;,
    &quot;selectedOption&quot;: &quot;accept&quot;,
    &quot;isShowingInput&quot;: false,
    &quot;firstTimeReviewMode&quot;: false
  }
}
```
Result:

```json
{
  &quot;diff&quot;: {
    &quot;editor&quot;: &quot;EDITOR_AI&quot;
  },
  &quot;shouldAutoFixLints&quot;: true,
  &quot;resultForModel&quot;: &quot;Success. Updated the following files:\nM /Users/sahilmehta/supplier-onboarding-simple/components/forms/dynamic-form-wizard.tsx&quot;,
  &quot;contentsAfterEdit&quot;: &quot;\&quot;use client\&quot;;\n\nimport { useCallback, useEffect, useMemo, useRef, useState } from \&quot;react\&quot;;\nimport type { FormConfigWithFields } from \&quot;@/lib/forms/types\&quot;;\nimport { getStepFieldKeys } from \&quot;@/lib/forms/form-validator\&quot;;\nimport { buildFormSchema } from \&quot;@/lib/form-schema\&quot;;\nimport { saveFormDraft, type DraftSaveResult } from \&quot;@/app/forms/actions\&quot;;\nimport { StepIndicator } from \&quot;./step-indicator\&quot;;\nimport { FormStep } from \&quot;./form-step\&quot;;\nimport { FormNavigation } from \&quot;./form-navigation\&quot;;\nimport { FormErrorSummary } from \&quot;./form-error-summary\&quot;;\nimport { useFormState } from \&quot;@/hooks/use-form-state\&quot;;\nimport { useAutosave } from \&quot;@/hooks/use-autosave\&quot;;\nimport { useToast } from \&quot;@/components/ui/use-toast\&quot;;\nimport { usePrefersReducedMotion } from \&quot;@/hooks/use-prefers-reduced-motion\&quot;;\nimport { cn } from \&quot;@/lib/utils\&quot;;\n\ninterface DynamicFormWizardProps {\n  formConfig: FormConfigWithFields;\n  initialData?: Record&lt;string, unknown&gt;;\n  initialStep?: number;\n  applicationId: string | null;\n  organizationId: string;\n  onApplicationIdChange?: (applicationId: string) =&gt; void;\n  onDraftSaved?: (result: DraftSaveResult) =&gt; void;\n  onStepChange?: (stepIndex: number) =&gt; void;\n  onComplete?: (formData: Record&lt;string, unknown&gt;) =&gt; Promise&lt;void&gt; | void;\n}\n\nexport function DynamicFormWizard({\n  formConfig,\n  initialData = {},\n  initialStep = 0,\n  applicationId,\n  organizationId,\n  onApplicationIdChange,\n  onDraftSaved,\n  onStepChange,\n  onComplete,\n}: DynamicFormWizardProps) {\n  const sortedSections = useMemo(\n    () =&gt; [...formConfig.sections].sort((a, b) =&gt; a.order - b.order),\n    [formConfig.sections]\n  );\n\n  const {\n    state,\n    touchedMap,\n    setFieldValue,\n    markFieldTouched,\n    markFieldsTouched,\n    setFieldError,\n    setStepErrors,\n    goToStep,\n    markStepComplete,\n    setIsSubmitting,\n    markClean,\n    validateAndCommitStep,\n  } = useFormState({\n    formConfig,\n    initialData,\n    initialStep,\n  });\n\n  const [liveMessage, setLiveMessage] = useState(\&quot;\&quot;);\n  const validationTimersRef = useRef&lt;Record&lt;string, NodeJS.Timeout&gt;&gt;({});\n  const formSchemaRef = useRef(buildFormSchema(formConfig));\n  const prefersReducedMotion = usePrefersReducedMotion();\n  const { toast } = useToast();\n\n  const totalSteps = sortedSections.length;\n  const currentSection = sortedSections[state.currentStep];\n  const isFirstStep = state.currentStep === 0;\n  const isLastStep = state.currentStep === totalSteps - 1;\n\n  useEffect(() =&gt; {\n    formSchemaRef.current = buildFormSchema(formConfig);\n  }, [formConfig]);\n\n  const focusFirstError = useCallback(\n    (fieldKey?: string) =&gt; {\n      if (!fieldKey || !currentSection) {\n        return;\n      }\n      const errorField = currentSection.fields.find((field) =&gt; field.key === fieldKey);\n      const fieldElement = errorField\n        ? document.getElementById(&#96;field-${errorField.id}&#96;)\n        : null;\n      fieldElement?.focus();\n      fieldElement?.scrollIntoView({ behavior: \&quot;smooth\&quot;, block: \&quot;center\&quot; });\n    },\n    [currentSection]\n  );\n\n  const validateField = useCallback(\n    (fieldKey: string, value: unknown, immediate = false) =&gt; {\n      if (validationTimersRef.current[fieldKey]) {\n        clearTimeout(validationTimersRef.current[fieldKey]);\n      }\n\n      const performValidation = () =&gt; {\n        const fieldSchema = formSchemaRef.current.shape[fieldKey];\n        if (!fieldSchema) {\n          return;\n        }\n\n        try {\n          fieldSchema.parse(value);\n          setFieldError(fieldKey);\n        } catch (error) {\n          if (error &amp;&amp; typeof error === \&quot;object\&quot; &amp;&amp; \&quot;issues\&quot; in error) {\n            const zodError = error as { issues: Array&lt;{ message: string }&gt; };\n            const firstIssue = zodError.issues[0];\n            if (firstIssue) {\n              setFieldError(fieldKey, firstIssue.message);\n            }\n          } else if (error instanceof Error) {\n            setFieldError(fieldKey, error.message);\n          }\n        }\n      };\n\n      if (immediate) {\n        performValidation();\n      } else {\n        validationTimersRef.current[fieldKey] = setTimeout(performValidation, 300);\n      }\n    },\n    [setFieldError]\n  );\n\n  const handleFieldChange = useCallback(\n    (fieldKey: string, value: unknown) =&gt; {\n      setFieldValue(fieldKey, value);\n      if (state.touched.has(fieldKey)) {\n        validateField(fieldKey, value, false);\n      }\n    },\n    [setFieldValue, state.touched, validateField]\n  );\n\n  const handleFieldBlur = useCallback(\n    (fieldKey: string) =&gt; {\n      markFieldTouched(fieldKey);\n      validateField(fieldKey, state.formData[fieldKey], true);\n    },\n    [markFieldTouched, state.formData, validateField]\n  );\n\n  const autosaveFingerprint = useMemo(\n    () =&gt; JSON.stringify({ data: state.formData, step: state.currentStep }),\n    [state.formData, state.currentStep]\n  );\n\n  const runDraftSave = useCallback(() =&gt; {\n    return saveFormDraft({\n      formConfigId: formConfig.id,\n      organizationId,\n      entityId: formConfig.entityId,\n      geographyId: formConfig.geographyId,\n      applicationId,\n      formData: state.formData,\n      currentStep: state.currentStep,\n    });\n  }, [\n    applicationId,\n    formConfig.entityId,\n    formConfig.geographyId,\n    formConfig.id,\n    organizationId,\n    state.currentStep,\n    state.formData,\n  ]);\n\n  const {\n    status: draftStatus,\n    isSaving: isSavingDraft,\n    lastSavedAt,\n    error: draftError,\n    triggerSave,\n  } = useAutosave&lt;DraftSaveResult&gt;({\n    shouldAutosave: state.isDirty,\n    dataFingerprint: autosaveFingerprint,\n    save: runDraftSave,\n    onSuccess: (result) =&gt; {\n      markClean();\n      if (result.applicationId &amp;&amp; result.applicationId !== applicationId) {\n        onApplicationIdChange?.(result.applicationId);\n      }\n      onDraftSaved?.(result);\n    },\n    onError: (error) =&gt; {\n      toast({\n        variant: \&quot;destructive\&quot;,\n        title: \&quot;Draft save failed\&quot;,\n        description: error.message,\n      });\n    },\n  });\n\n  const handleNext = useCallback(async () =&gt; {\n    if (state.isSubmitting) {\n      return;\n    }\n\n    const validation = validateAndCommitStep(state.currentStep);\n    if (!validation.isValid) {\n      toast({\n        variant: \&quot;destructive\&quot;,\n        title: \&quot;Please fix validation errors\&quot;,\n        description: \&quot;Resolve highlighted fields before continuing.\&quot;,\n      });\n      focusFirstError(validation.firstErrorField);\n      return;\n    }\n\n    markStepComplete(state.currentStep);\n\n    if (isLastStep &amp;&amp; onComplete) {\n      try {\n        setIsSubmitting(true);\n        await onComplete(state.formData);\n        toast({\n          title: \&quot;Form submitted\&quot;,\n          description: \&quot;Thank you! We received your information.\&quot;,\n        });\n      } catch (error) {\n        toast({\n          variant: \&quot;destructive\&quot;,\n          title: \&quot;Submission failed\&quot;,\n          description:\n            error instanceof Error\n              ? error.message\n              : \&quot;Something went wrong while submitting. Please try again.\&quot;,\n        });\n      } finally {\n        setIsSubmitting(false);\n      }\n      return;\n    }\n\n    const nextStep = state.currentStep + 1;\n    goToStep(nextStep);\n    onStepChange?.(nextStep);\n    void triggerSave(\&quot;step-change\&quot;);\n  }, [\n    focusFirstError,\n    goToStep,\n    isLastStep,\n    markStepComplete,\n    onComplete,\n    onStepChange,\n    setIsSubmitting,\n    state.currentStep,\n    state.formData,\n    state.isSubmitting,\n    toast,\n    triggerSave,\n    validateAndCommitStep,\n  ]);\n\n  const handlePrevious = useCallback(() =&gt; {\n    if (isFirstStep) {\n      return;\n    }\n    const prevStep = state.currentStep - 1;\n    goToStep(prevStep);\n    onStepChange?.(prevStep);\n  }, [goToStep, isFirstStep, onStepChange, state.currentStep]);\n\n  const handleStepClick = useCallback(\n    (stepIndex: number) =&gt; {\n      if (stepIndex === state.currentStep) {\n        return;\n      }\n\n      const validation = validateAndCommitStep(state.currentStep);\n      if (!validation.isValid) {\n        toast({\n          variant: \&quot;destructive\&quot;,\n          title: \&quot;Cannot leave step yet\&quot;,\n          description: \&quot;Fix validation errors before moving on.\&quot;,\n        });\n        focusFirstError(validation.firstErrorField);\n        return;\n      }\n\n      if (\n        state.completedSteps.has(stepIndex) ||\n        stepIndex === state.currentStep + 1\n      ) {\n        goToStep(stepIndex);\n        onStepChange?.(stepIndex);\n        void triggerSave(\&quot;step-change\&quot;);\n      }\n    },\n    [\n      focusFirstError,\n      goToStep,\n      onStepChange,\n      state.completedSteps,\n      state.currentStep,\n      toast,\n      triggerSave,\n      validateAndCommitStep,\n    ]\n  );\n\n  const handleManualSave = useCallback(() =&gt; {\n    void triggerSave(\&quot;manual\&quot;);\n  }, [triggerSave]);\n\n  useEffect(() =&gt; {\n    return () =&gt; {\n      Object.values(validationTimersRef.current).forEach((timer) =&gt; {\n        clearTimeout(timer);\n      });\n    };\n  }, []);\n\n  useEffect(() =&gt; {\n    const sectionLabel = currentSection?.label ?? &#96;Step ${state.currentStep + 1}&#96;;\n    setLiveMessage(\n      &#96;Now viewing ${sectionLabel} (${state.currentStep + 1} of ${totalSteps})&#96;\n    );\n  }, [currentSection, state.currentStep, totalSteps]);\n\n  const progress =\n    totalSteps &gt; 0 ? ((state.currentStep + 1) / totalSteps) * 100 : 0;\n\n  return (\n    &lt;div className=\&quot;flex flex-col gap-6 pb-32 sm:pb-12\&quot;&gt;\n      &lt;StepIndicator\n        steps={sortedSections.map((section) =&gt; ({\n          id: section.id,\n          label: section.label,\n          order: section.order,\n        }))}\n        currentStep={state.currentStep}\n        completedSteps={state.completedSteps}\n        onStepClick={handleStepClick}\n      /&gt;\n\n      &lt;div\n        className={cn(\n          \&quot;min-h-[400px] space-y-6 rounded-3xl border border-border/60 bg-background/70 p-4 shadow-lg sm:p-8\&quot;,\n          !prefersReducedMotion &amp;&amp; \&quot;transition-shadow duration-300\&quot;\n        )}\n      &gt;\n        {(() =&gt; {\n          const stepFieldKeys = getStepFieldKeys(state.currentStep, formConfig);\n          const stepErrors: Record&lt;string, string&gt; = {};\n          stepFieldKeys.forEach((key) =&gt; {\n            if (state.errors[key] &amp;&amp; touchedMap[key]) {\n              stepErrors[key] = state.errors[key];\n            }\n          });\n\n          if (Object.keys(stepErrors).length &gt; 0) {\n            return (\n              &lt;FormErrorSummary\n                errors={stepErrors}\n                onErrorClick={(fieldKey) =&gt; focusFirstError(fieldKey)}\n              /&gt;\n            );\n          }\n          return null;\n        })()}\n\n        {currentSection &amp;&amp; (\n          &lt;FormStep\n            section={currentSection}\n            formData={state.formData}\n            errors={state.errors}\n            touched={touchedMap}\n            onFieldChange={handleFieldChange}\n            onFieldBlur={handleFieldBlur}\n          /&gt;\n        )}\n      &lt;/div&gt;\n\n      &lt;FormNavigation\n        isFirstStep={isFirstStep}\n        isLastStep={isLastStep}\n        onNext={handleNext}\n        onPrevious={handlePrevious}\n        onSaveDraft={handleManualSave}\n        progress={progress}\n        isSubmitting={state.isSubmitting}\n        isSavingDraft={isSavingDraft}\n        draftStatus={draftStatus}\n        draftError={draftError}\n        lastSavedAt={lastSavedAt}\n      /&gt;\n      &lt;p role=\&quot;status\&quot; aria-live=\&quot;polite\&quot; className=\&quot;sr-only\&quot;&gt;\n        {liveMessage}\n      &lt;/p&gt;\n    &lt;/div&gt;\n  );\n}\n\&quot;use client\&quot;;\n\nimport { useCallback, useEffect, useMemo, useRef, useState } from \&quot;react\&quot;;\nimport type { FormConfigWithFields } from \&quot;@/lib/forms/types\&quot;;\nimport { getStepFieldKeys } from \&quot;@/lib/forms/form-validator\&quot;;\nimport { buildFormSchema } from \&quot;@/lib/form-schema\&quot;;\nimport { saveFormDraft, type DraftSaveResult } from \&quot;@/app/forms/actions\&quot;;\nimport { StepIndicator } from \&quot;./step-indicator\&quot;;\nimport { FormStep } from \&quot;./form-step\&quot;;\nimport { FormNavigation } from \&quot;./form-navigation\&quot;;\nimport { FormErrorSummary } from \&quot;./form-error-summary\&quot;;\nimport { useFormState } from \&quot;@/hooks/use-form-state\&quot;;\nimport { useAutosave } from \&quot;@/hooks/use-autosave\&quot;;\nimport { useToast } from \&quot;@/components/ui/use-toast\&quot;;\nimport { usePrefersReducedMotion } from \&quot;@/hooks/use-prefers-reduced-motion\&quot;;\nimport { cn } from \&quot;@/lib/utils\&quot;;\n\ninterface DynamicFormWizardProps {\n  formConfig: FormConfigWithFields;\n  initialData?: Record&lt;string, unknown&gt;;\n  initialStep?: number;\n  applicationId: string | null;\n  organizationId: string;\n  onApplicationIdChange?: (applicationId: string) =&gt; void;\n  onDraftSaved?: (result: DraftSaveResult) =&gt; void;\n  onStepChange?: (stepIndex: number) =&gt; void;\n  onComplete?: (formData: Record&lt;string, unknown&gt;) =&gt; Promise&lt;void&gt; | void;\n}\n\nexport function DynamicFormWizard({\n  formConfig,\n  initialData = {},\n  initialStep = 0,\n  applicationId,\n  organizationId,\n  onApplicationIdChange,\n  onDraftSaved,\n  onStepChange,\n  onComplete,\n}: DynamicFormWizardProps) {\n  const sortedSections = useMemo(\n    () =&gt; [...formConfig.sections].sort((a, b) =&gt; a.order - b.order),\n    [formConfig.sections]\n  );\n\n  const {\n    state,\n    touchedMap,\n    setFieldValue,\n    markFieldTouched,\n    markFieldsTouched,\n    setFieldError,\n    setStepErrors,\n    goToStep,\n    markStepComplete,\n    setIsSubmitting,\n    markClean,\n    validateAndCommitStep,\n  } = useFormState({\n    formConfig,\n    initialData,\n    initialStep,\n  });\n\n  const [liveMessage, setLiveMessage] = useState(\&quot;\&quot;);\n  const validationTimersRef = useRef&lt;Record&lt;string, NodeJS.Timeout&gt;&gt;({});\n  const formSchemaRef = useRef(buildFormSchema(formConfig));\n  const prefersReducedMotion = usePrefersReducedMotion();\n  const { toast } = useToast();\n\n  const totalSteps = sortedSections.length;\n  const currentSection = sortedSections[state.currentStep];\n  const isFirstStep = state.currentStep === 0;\n  const isLastStep = state.currentStep === totalSteps - 1;\n\n  useEffect(() =&gt; {\n    formSchemaRef.current = buildFormSchema(formConfig);\n  }, [formConfig]);\n\n  const focusFirstError = useCallback(\n    (fieldKey?: string) =&gt; {\n      if (!fieldKey || !currentSection) {\n        return;\n      }\n      const errorField = currentSection.fields.find((field) =&gt; field.key === fieldKey);\n      const fieldElement = errorField\n        ? document.getElementById(&#96;field-${errorField.id}&#96;)\n        : null;\n      fieldElement?.focus();\n      fieldElement?.scrollIntoView({ behavior: \&quot;smooth\&quot;, block: \&quot;center\&quot; });\n    },\n    [currentSection]\n  );\n\n  const validateField = useCallback(\n    (fieldKey: string, value: unknown, immediate = false) =&gt; {\n      if (validationTimersRef.current[fieldKey]) {\n        clearTimeout(validationTimersRef.current[fieldKey]);\n      }\n\n      const performValidation = () =&gt; {\n        const fieldSchema = formSchemaRef.current.shape[fieldKey];\n        if (!fieldSchema) {\n          return;\n        }\n\n        try {\n          fieldSchema.parse(value);\n          setFieldError(fieldKey);\n        } catch (error) {\n          if (error &amp;&amp; typeof error === \&quot;object\&quot; &amp;&amp; \&quot;issues\&quot; in error) {\n            const zodError = error as { issues: Array&lt;{ message: string }&gt; };\n            const firstIssue = zodError.issues[0];\n            if (firstIssue) {\n              setFieldError(fieldKey, firstIssue.message);\n            }\n          } else if (error instanceof Error) {\n            setFieldError(fieldKey, error.message);\n          }\n        }\n      };\n\n      if (immediate) {\n        performValidation();\n      } else {\n        validationTimersRef.current[fieldKey] = setTimeout(performValidation, 300);\n      }\n    },\n    [setFieldError]\n  );\n\n  const handleFieldChange = useCallback(\n    (fieldKey: string, value: unknown) =&gt; {\n      setFieldValue(fieldKey, value);\n      if (state.touched.has(fieldKey)) {\n        validateField(fieldKey, value, false);\n      }\n    },\n    [setFieldValue, state.touched, validateField]\n  );\n\n  const handleFieldBlur = useCallback(\n    (fieldKey: string) =&gt; {\n      markFieldTouched(fieldKey);\n      validateField(fieldKey, state.formData[fieldKey], true);\n    },\n    [markFieldTouched, state.formData, validateField]\n  );\n\n  const autosaveFingerprint = useMemo(\n    () =&gt; JSON.stringify({ data: state.formData, step: state.currentStep }),\n    [state.formData, state.currentStep]\n  );\n\n  const runDraftSave = useCallback(() =&gt; {\n    return saveFormDraft({\n      formConfigId: formConfig.id,\n      organizationId,\n      entityId: formConfig.entityId,\n      geographyId: formConfig.geographyId,\n      applicationId,\n      formData: state.formData,\n      currentStep: state.currentStep,\n    });\n  }, [\n    applicationId,\n    formConfig.entityId,\n    formConfig.geographyId,\n    formConfig.id,\n    organizationId,\n    state.currentStep,\n    state.formData,\n  ]);\n\n  const {\n    status: draftStatus,\n    isSaving: isSavingDraft,\n    lastSavedAt,\n    error: draftError,\n    triggerSave,\n  } = useAutosave&lt;DraftSaveResult&gt;({\n    shouldAutosave: state.isDirty,\n    dataFingerprint: autosaveFingerprint,\n    save: runDraftSave,\n    onSuccess: (result) =&gt; {\n      markClean();\n      if (result.applicationId &amp;&amp; result.applicationId !== applicationId) {\n        onApplicationIdChange?.(result.applicationId);\n      }\n      onDraftSaved?.(result);\n    },\n    onError: (error) =&gt; {\n      toast({\n        variant: \&quot;destructive\&quot;,\n        title: \&quot;Draft save failed\&quot;,\n        description: error.message,\n      });\n    },\n  });\n\n  const handleNext = useCallback(async () =&gt; {\n    if (state.isSubmitting) {\n      return;\n    }\n\n    const validation = validateAndCommitStep(state.currentStep);\n    if (!validation.isValid) {\n      toast({\n        variant: \&quot;destructive\&quot;,\n        title: \&quot;Please fix validation errors\&quot;,\n        description: \&quot;Resolve highlighted fields before continuing.\&quot;,\n      });\n      focusFirstError(validation.firstErrorField);\n      return;\n    }\n\n    markStepComplete(state.currentStep);\n\n    if (isLastStep &amp;&amp; onComplete) {\n      try {\n        setIsSubmitting(true);\n        await onComplete(state.formData);\n        toast({\n          title: \&quot;Form submitted\&quot;,\n          description: \&quot;Thank you! We received your information.\&quot;,\n        });\n      } catch (error) {\n        toast({\n          variant: \&quot;destructive\&quot;,\n          title: \&quot;Submission failed\&quot;,\n          description:\n            error instanceof Error\n              ? error.message\n              : \&quot;Something went wrong while submitting. Please try again.\&quot;,\n        });\n      } finally {\n        setIsSubmitting(false);\n      }\n      return;\n    }\n\n    const nextStep = state.currentStep + 1;\n    goToStep(nextStep);\n    onStepChange?.(nextStep);\n    void triggerSave(\&quot;step-change\&quot;);\n  }, [\n    focusFirstError,\n    goToStep,\n    isLastStep,\n    markStepComplete,\n    onComplete,\n    onStepChange,\n    setIsSubmitting,\n    state.currentStep,\n    state.formData,\n    state.isSubmitting,\n    toast,\n    triggerSave,\n    validateAndCommitStep,\n  ]);\n\n  const handlePrevious = useCallback(() =&gt; {\n    if (isFirstStep) {\n      return;\n    }\n    const prevStep = state.currentStep - 1;\n    goToStep(prevStep);\n    onStepChange?.(prevStep);\n  }, [goToStep, isFirstStep, onStepChange, state.currentStep]);\n\n  const handleStepClick = useCallback(\n    (stepIndex: number) =&gt; {\n      if (stepIndex === state.currentStep) {\n        return;\n      }\n\n      const validation = validateAndCommitStep(state.currentStep);\n      if (!validation.isValid) {\n        toast({\n          variant: \&quot;destructive\&quot;,\n          title: \&quot;Cannot leave step yet\&quot;,\n          description: \&quot;Fix validation errors before moving on.\&quot;,\n        });\n        focusFirstError(validation.firstErrorField);\n        return;\n      }\n\n      if (\n        state.completedSteps.has(stepIndex) ||\n        stepIndex === state.currentStep + 1\n      ) {\n        goToStep(stepIndex);\n        onStepChange?.(stepIndex);\n        void triggerSave(\&quot;step-change\&quot;);\n      }\n    },\n    [\n      focusFirstError,\n      goToStep,\n      onStepChange,\n      state.completedSteps,\n      state.currentStep,\n      toast,\n      triggerSave,\n      validateAndCommitStep,\n    ]\n  );\n\n  const handleManualSave = useCallback(() =&gt; {\n    void triggerSave(\&quot;manual\&quot;);\n  }, [triggerSave]);\n\n  useEffect(() =&gt; {\n    const timers = validationTimersRef.current;\n    return () =&gt; {\n      Object.values(timers).forEach((timer) =&gt; {\n        clearTimeout(timer);\n      });\n    };\n  }, []);\n\n  useEffect(() =&gt; {\n    const sectionLabel = currentSection?.label ?? &#96;Step ${state.currentStep + 1}&#96;;\n    setLiveMessage(\n      &#96;Now viewing ${sectionLabel} (${state.currentStep + 1} of ${totalSteps})&#96;\n    );\n  }, [currentSection, state.currentStep, totalSteps]);\n\n  const progress =\n    totalSteps &gt; 0 ? ((state.currentStep + 1) / totalSteps) * 100 : 0;\n\n  return (\n    &lt;div className=\&quot;flex flex-col gap-6 pb-32 sm:pb-12\&quot;&gt;\n      &lt;StepIndicator\n        steps={sortedSections.map((section) =&gt; ({\n          id: section.id,\n          label: section.label,\n          order: section.order,\n        }))}\n        currentStep={state.currentStep}\n        completedSteps={state.completedSteps}\n        onStepClick={handleStepClick}\n      /&gt;\n\n      &lt;div\n        className={cn(\n          \&quot;min-h-[400px] space-y-6 rounded-3xl border border-border/60 bg-background/70 p-4 shadow-lg sm:p-8\&quot;,\n          !prefersReducedMotion &amp;&amp; \&quot;transition-shadow duration-300\&quot;\n        )}\n      &gt;\n        {(() =&gt; {\n          const stepFieldKeys = getStepFieldKeys(state.currentStep, formConfig);\n          const stepErrors: Record&lt;string, string&gt; = {};\n          stepFieldKeys.forEach((key) =&gt; {\n            if (state.errors[key] &amp;&amp; touchedMap[key]) {\n              stepErrors[key] = state.errors[key];\n            }\n          });\n\n          if (Object.keys(stepErrors).length &gt; 0) {\n            return (\n              &lt;FormErrorSummary\n                errors={stepErrors}\n                onErrorClick={(fieldKey) =&gt; focusFirstError(fieldKey)}\n              /&gt;\n            );\n          }\n          return null;\n        })()}\n\n        {currentSection &amp;&amp; (\n          &lt;FormStep\n            section={currentSection}\n            formData={state.formData}\n            errors={state.errors}\n            touched={touchedMap}\n            onFieldChange={handleFieldChange}\n            onFieldBlur={handleFieldBlur}\n          /&gt;\n        )}\n      &lt;/div&gt;\n\n      &lt;FormNavigation\n        isFirstStep={isFirstStep}\n        isLastStep={isLastStep}\n        onNext={handleNext}\n        onPrevious={handlePrevious}\n        onSaveDraft={handleManualSave}\n        progress={progress}\n        isSubmitting={state.isSubmitting}\n        isSavingDraft={isSavingDraft}\n        draftStatus={draftStatus}\n        draftError={draftError}\n        lastSavedAt={lastSavedAt}\n      /&gt;\n      &lt;p role=\&quot;status\&quot; aria-live=\&quot;polite\&quot; className=\&quot;sr-only\&quot;&gt;\n        {liveMessage}\n      &lt;/p&gt;\n    &lt;/div&gt;\n  );\n}\n\&quot;use client\&quot;;\n\nimport { useState, useCallback, useRef, useEffect } from \&quot;react\&quot;;\nimport type { FormConfigWithFields } from \&quot;@/lib/forms/types\&quot;;\nimport { validateStep, getStepFieldKeys } from \&quot;@/lib/forms/form-validator\&quot;;\nimport { buildFormSchema } from \&quot;@/lib/form-schema\&quot;;\nimport { StepIndicator } from \&quot;./step-indicator\&quot;;\nimport { FormStep } from \&quot;./form-step\&quot;;\nimport { FormNavigation } from \&quot;./form-navigation\&quot;;\nimport { FormErrorSummary } from \&quot;./form-error-summary\&quot;;\nimport { usePrefersReducedMotion } from \&quot;@/hooks/use-prefers-reduced-motion\&quot;;\nimport { useToast } from \&quot;@/components/ui/use-toast\&quot;;\nimport { cn } from \&quot;@/lib/utils\&quot;;\nimport type { DraftStatus } from \&quot;./draft-save-indicator\&quot;;\n\ninterface DynamicFormWizardProps {\n  formConfig: FormConfigWithFields;\n  initialData?: Record&lt;string, unknown&gt;;\n  onStepChange?: (stepIndex: number) =&gt; void;\n  onComplete?: (formData: Record&lt;string, unknown&gt;) =&gt; void;\n  onSaveDraft?: (formData: Record&lt;string, unknown&gt;) =&gt; void;\n}\n\nexport function DynamicFormWizard({\n  formConfig,\n  initialData = {},\n  onStepChange,\n  onComplete,\n  onSaveDraft,\n}: DynamicFormWizardProps) {\n  const sortedSections = [...formConfig.sections].sort(\n    (a, b) =&gt; a.order - b.order\n  );\n\n  const [currentStep, setCurrentStep] = useState(0);\n  const [formData, setFormData] = useState&lt;Record&lt;string, unknown&gt;&gt;(\n    initialData\n  );\n  const [completedSteps, setCompletedSteps] = useState&lt;Set&lt;number&gt;&gt;(\n    new Set()\n  );\n  const [errors, setErrors] = useState&lt;Record&lt;string, string&gt;&gt;({});\n  const [touched, setTouched] = useState&lt;Record&lt;string, boolean&gt;&gt;({});\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  const [isSavingDraft, setIsSavingDraft] = useState(false);\n  const [draftStatus, setDraftStatus] = useState&lt;DraftStatus&gt;(\&quot;idle\&quot;);\n  const [draftError, setDraftError] = useState&lt;string | null&gt;(null);\n  const [lastSavedAt, setLastSavedAt] = useState&lt;Date | null&gt;(null);\n  const [liveMessage, setLiveMessage] = useState(\&quot;\&quot;);\n  const validationTimersRef = useRef&lt;Record&lt;string, NodeJS.Timeout&gt;&gt;({});\n  const formSchemaRef = useRef(buildFormSchema(formConfig));\n  const prefersReducedMotion = usePrefersReducedMotion();\n  const { toast } = useToast();\n\n  const totalSteps = sortedSections.length;\n  const currentSection = sortedSections[currentStep];\n  const isFirstStep = currentStep === 0;\n  const isLastStep = currentStep === totalSteps - 1;\n\n  // Rebuild schema if form config changes\n  useEffect(() =&gt; {\n    formSchemaRef.current = buildFormSchema(formConfig);\n  }, [formConfig]);\n\n  /**\n   * Validate a single field with debouncing\n   */\n  const validateField = useCallback(\n    (fieldKey: string, value: unknown, immediate = false) =&gt; {\n      // Clear existing timer for this field\n      if (validationTimersRef.current[fieldKey]) {\n        clearTimeout(validationTimersRef.current[fieldKey]);\n      }\n\n      const performValidation = () =&gt; {\n        const fieldSchema = formSchemaRef.current.shape[fieldKey];\n        if (!fieldSchema) {\n          return;\n        }\n\n        try {\n          fieldSchema.parse(value);\n          // Clear error if validation passes\n          setErrors((prev) =&gt; {\n            const next = { ...prev };\n            delete next[fieldKey];\n            return next;\n          });\n        } catch (error) {\n          if (error &amp;&amp; typeof error === \&quot;object\&quot; &amp;&amp; \&quot;issues\&quot; in error) {\n            const zodError = error as { issues: Array&lt;{ message: string }&gt; };\n            const firstIssue = zodError.issues[0];\n            if (firstIssue) {\n              setErrors((prev) =&gt; ({\n                ...prev,\n                [fieldKey]: firstIssue.message,\n              }));\n            }\n          } else if (error instanceof Error) {\n            setErrors((prev) =&gt; ({\n              ...prev,\n              [fieldKey]: error.message,\n            }));\n          }\n        }\n      };\n\n      if (immediate) {\n        performValidation();\n      } else {\n        // Debounce validation on change (300ms)\n        validationTimersRef.current[fieldKey] = setTimeout(performValidation, 300);\n      }\n    },\n    []\n  );\n\n  const handleFieldChange = useCallback(\n    (fieldKey: string, value: unknown) =&gt; {\n      setFormData((prev) =&gt; ({\n        ...prev,\n        [fieldKey]: value,\n      }));\n\n      // Validate on change with debounce (only if field has been touched)\n      if (touched[fieldKey]) {\n        validateField(fieldKey, value, false);\n      }\n    },\n    [touched, validateField]\n  );\n\n  const handleFieldBlur = useCallback(\n    (fieldKey: string) =&gt; {\n      setTouched((prev) =&gt; ({\n        ...prev,\n        [fieldKey]: true,\n      }));\n\n      // Validate immediately on blur\n      const value = formData[fieldKey];\n      validateField(fieldKey, value, true);\n    },\n    [formData, validateField]\n  );\n\n  /**\n   * Validate current step using the validation utilities\n   */\n  const validateCurrentStep = useCallback((): boolean =&gt; {\n    const stepResult = validateStep(currentStep, formData, formConfig);\n\n    if (!stepResult.isValid) {\n      // Update errors for current step fields only\n      const stepFieldKeys = getStepFieldKeys(currentStep, formConfig);\n      setErrors((prev) =&gt; {\n        const next = { ...prev };\n        // Clear errors for fields not in current step\n        stepFieldKeys.forEach((key) =&gt; {\n          if (stepResult.errors[key]) {\n            next[key] = stepResult.errors[key];\n          } else {\n            delete next[key];\n          }\n        });\n        return next;\n      });\n\n      // Mark all fields in step as touched\n      setTouched((prev) =&gt; {\n        const next = { ...prev };\n        stepFieldKeys.forEach((key) =&gt; {\n          next[key] = true;\n        });\n        return next;\n      });\n\n      // Focus first error field\n      if (stepResult.firstErrorField) {\n        // Find the field by key to get its ID\n        const errorField = currentSection.fields.find(\n          (f) =&gt; f.key === stepResult.firstErrorField\n        );\n        if (errorField) {\n          // Field components use &#96;field-${field.id}&#96; as the ID\n          const fieldElement = document.getElementById(&#96;field-${errorField.id}&#96;);\n          if (fieldElement) {\n            fieldElement.focus();\n            fieldElement.scrollIntoView({ behavior: \&quot;smooth\&quot;, block: \&quot;center\&quot; });\n          }\n        }\n      }\n    }\n\n    return stepResult.isValid;\n  }, [currentStep, formData, formConfig, currentSection]);\n\n  const handleNext = useCallback(async () =&gt; {\n    if (isSubmitting) {\n      return;\n    }\n\n    const isStepValid = validateCurrentStep();\n    if (!isStepValid) {\n      toast({\n        variant: \&quot;destructive\&quot;,\n        title: \&quot;Please fix validation errors\&quot;,\n        description: \&quot;Resolve highlighted fields before continuing.\&quot;,\n      });\n      return;\n    }\n\n    setCompletedSteps((prev) =&gt; new Set(prev).add(currentStep));\n\n    if (isLastStep) {\n      if (!onComplete) {\n        return;\n      }\n      try {\n        setIsSubmitting(true);\n        await onComplete(formData);\n        toast({\n          title: \&quot;Form submitted\&quot;,\n          description: \&quot;Thanks! We received your information.\&quot;,\n        });\n      } catch (error) {\n        toast({\n          variant: \&quot;destructive\&quot;,\n          title: \&quot;Submission failed\&quot;,\n          description:\n            error instanceof Error\n              ? error.message\n              : \&quot;Something went wrong while submitting. Please try again.\&quot;,\n        });\n      } finally {\n        setIsSubmitting(false);\n      }\n    } else {\n      const nextStep = currentStep + 1;\n      setCurrentStep(nextStep);\n      onStepChange?.(nextStep);\n    }\n  }, [\n    currentStep,\n    formData,\n    isLastStep,\n    isSubmitting,\n    onComplete,\n    onStepChange,\n    toast,\n    validateCurrentStep,\n  ]);\n\n  const handlePrevious = useCallback(() =&gt; {\n    if (!isFirstStep) {\n      const prevStep = currentStep - 1;\n      setCurrentStep(prevStep);\n      onStepChange?.(prevStep);\n    }\n  }, [currentStep, isFirstStep, onStepChange]);\n\n  const handleStepClick = useCallback(\n    (stepIndex: number) =&gt; {\n      // Validate current step before allowing navigation\n      if (stepIndex !== currentStep) {\n        if (!validateCurrentStep()) {\n          return; // Don&#39;t allow navigation if current step is invalid\n        }\n      }\n\n      // Allow navigation to completed steps or the next step\n      if (completedSteps.has(stepIndex) || stepIndex === currentStep + 1) {\n        setCurrentStep(stepIndex);\n        onStepChange?.(stepIndex);\n      }\n    },\n    [completedSteps, currentStep, onStepChange, validateCurrentStep]\n  );\n\n  const handleSaveDraft = useCallback(async () =&gt; {\n    if (!onSaveDraft || isSavingDraft) {\n      return;\n    }\n    try {\n      setIsSavingDraft(true);\n      setDraftStatus(\&quot;saving\&quot;);\n      setDraftError(null);\n      await onSaveDraft(formData);\n      setDraftStatus(\&quot;success\&quot;);\n      const savedAt = new Date();\n      setLastSavedAt(savedAt);\n      toast({\n        title: \&quot;Draft saved\&quot;,\n        description: &#96;Progress saved at ${savedAt.toLocaleTimeString([], {\n          hour: \&quot;numeric\&quot;,\n          minute: \&quot;2-digit\&quot;,\n        })}&#96;,\n      });\n    } catch (error) {\n      setDraftStatus(\&quot;error\&quot;);\n      const message =\n        error instanceof Error\n          ? error.message\n          : \&quot;Unable to save your draft right now.\&quot;;\n      setDraftError(message);\n      toast({\n        variant: \&quot;destructive\&quot;,\n        title: \&quot;Draft not saved\&quot;,\n        description: message,\n      });\n    } finally {\n      setIsSavingDraft(false);\n    }\n  }, [formData, isSavingDraft, onSaveDraft, toast]);\n\n  // Cleanup timers on unmount\n  useEffect(() =&gt; {\n    const timers = validationTimersRef.current;\n    return () =&gt; {\n      Object.values(timers).forEach((timer) =&gt; {\n        clearTimeout(timer);\n      });\n    };\n  }, []);\n\n  const progress = totalSteps &gt; 0 ? ((currentStep + 1) / totalSteps) * 100 : 0;\n\n  useEffect(() =&gt; {\n    const sectionLabel = currentSection?.label ?? &#96;Step ${currentStep + 1}&#96;;\n    setLiveMessage(&#96;Now viewing ${sectionLabel} (${currentStep + 1} of ${totalSteps})&#96;);\n  }, [currentSection, currentStep, totalSteps]);\n\n  return (\n    &lt;div className=\&quot;flex flex-col gap-6 pb-32 sm:pb-12\&quot;&gt;\n      &lt;StepIndicator\n        steps={sortedSections.map((section, index) =&gt; ({\n          id: section.id,\n          label: section.label,\n          order: section.order,\n        }))}\n        currentStep={currentStep}\n        completedSteps={completedSteps}\n        onStepClick={handleStepClick}\n      /&gt;\n\n      &lt;div\n        className={cn(\n          \&quot;min-h-[400px] space-y-6 rounded-3xl border border-border/60 bg-background/70 p-4 shadow-lg sm:p-8\&quot;,\n          !prefersReducedMotion &amp;&amp; \&quot;transition-shadow duration-300\&quot;\n        )}\n      &gt;\n        {/* Error summary for current step */}\n        {(() =&gt; {\n          const stepFieldKeys = getStepFieldKeys(currentStep, formConfig);\n          const stepErrors: Record&lt;string, string&gt; = {};\n          stepFieldKeys.forEach((key) =&gt; {\n            if (errors[key] &amp;&amp; touched[key]) {\n              stepErrors[key] = errors[key];\n            }\n          });\n\n          if (Object.keys(stepErrors).length &gt; 0) {\n            return (\n              &lt;FormErrorSummary\n                errors={stepErrors}\n                onErrorClick={(fieldKey) =&gt; {\n                  // Find the field by key to get its ID\n                  const errorField = currentSection.fields.find(\n                    (f) =&gt; f.key === fieldKey\n                  );\n                  if (errorField) {\n                    // Field components use &#96;field-${field.id}&#96; as the ID\n                    const fieldElement = document.getElementById(&#96;field-${errorField.id}&#96;);\n                    if (fieldElement) {\n                      fieldElement.focus();\n                      fieldElement.scrollIntoView({\n                        behavior: \&quot;smooth\&quot;,\n                        block: \&quot;center\&quot;,\n                      });\n                    }\n                  }\n                }}\n              /&gt;\n            );\n          }\n          return null;\n        })()}\n\n        &lt;FormStep\n          section={currentSection}\n          formData={formData}\n          errors={errors}\n          touched={touched}\n          onFieldChange={handleFieldChange}\n          onFieldBlur={handleFieldBlur}\n        /&gt;\n      &lt;/div&gt;\n\n      &lt;FormNavigation\n        isFirstStep={isFirstStep}\n        isLastStep={isLastStep}\n        onNext={handleNext}\n        onPrevious={handlePrevious}\n        onSaveDraft={handleSaveDraft}\n        progress={progress}\n        isSubmitting={isSubmitting}\n        isSavingDraft={isSavingDraft}\n        draftStatus={draftStatus}\n        draftError={draftError}\n        lastSavedAt={lastSavedAt}\n      /&gt;\n      &lt;p role=\&quot;status\&quot; aria-live=\&quot;polite\&quot; className=\&quot;sr-only\&quot;&gt;\n        {liveMessage}\n      &lt;/p&gt;\n    &lt;/div&gt;\n  );\n}\n\n&quot;
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Checking if file is empty**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/sahilmehta/supplier-onboarding-simple/components/forms/dynamic-form-wizard.tsx</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Checking file deletion command usage**</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  &quot;relativeWorkspacePath&quot;: &quot;/Users/sahilmehta/supplier-onboarding-simple/components/forms/dynamic-form-wizard.tsx&quot;
}
```
Additional data:

```json
{
  &quot;codeblockId&quot;: &quot;2ea84a43-3613-42b6-9317-bd3bbbc25f38&quot;,
  &quot;reviewData&quot;: {
    &quot;status&quot;: &quot;None&quot;,
    &quot;selectedOption&quot;: &quot;accept&quot;,
    &quot;isShowingInput&quot;: false,
    &quot;firstTimeReviewMode&quot;: false
  }
}
```
Result:

```json
{
  &quot;diff&quot;: {
    &quot;chunks&quot;: [
      {
        &quot;diffString&quot;: &quot;      validateAndCommitStep,\n    ]);\n+ \n+   const handlePrevious = useCallback(() =&gt; {\n+     if (isFirstStep) {\n+       return;\n+     }\n+     const prevStep = state.currentStep - 1;\n+     goToStep(prevStep);\n+     onStepChange?.(prevStep);\n+   }, [goToStep, isFirstStep, onStepChange, state.currentStep]);\n+ \n+   const handleStepClick = useCallback(\n+     (stepIndex: number) =&gt; {\n+       if (stepIndex === state.currentStep) {\n+         return;\n+       }\n+ \n+       const validation = validateAndCommitStep(state.currentStep);\n+       if (!validation.isValid) {\n+         toast({\n+           variant: \&quot;destructive\&quot;,\n+           title: \&quot;Cannot leave step yet\&quot;,\n+           description: \&quot;Fix validation errors before moving on.\&quot;,\n+         });\n+         focusFirstError(validation.firstErrorField);\n+         return;\n+       }\n+ \n+       if (\n+         state.completedSteps.has(stepIndex) ||\n+         stepIndex === state.currentStep + 1\n+       ) {\n+         goToStep(stepIndex);\n+         onStepChange?.(stepIndex);\n+         void triggerSave(\&quot;step-change\&quot;);\n+       }\n+     },\n+     [\n+       focusFirstError,\n+       goToStep,\n+       onStepChange,\n+       state.completedSteps,\n+       state.currentStep,\n+       toast,\n+       triggerSave,\n+       validateAndCommitStep,\n+     ]\n+   );\n+ \n+   const handleManualSave = useCallback(() =&gt; {\n+     void triggerSave(\&quot;manual\&quot;);\n+   }, [triggerSave]);\n+ \n+   useEffect(() =&gt; {\n+     return () =&gt; {\n+       Object.values(validationTimersRef.current).forEach((timer) =&gt; {\n+         clearTimeout(timer);\n+       });\n+     };\n+   }, []);\n+ \n+   useEffect(() =&gt; {\n+     const sectionLabel = currentSection?.label ?? &#96;Step ${state.currentStep + 1}&#96;;\n+     setLiveMessage(\n+       &#96;Now viewing ${sectionLabel} (${state.currentStep + 1} of ${totalSteps})&#96;\n+     );\n+   }, [currentSection, state.currentStep, totalSteps]);\n+ \n+   const progress =\n+     totalSteps &gt; 0 ? ((state.currentStep + 1) / totalSteps) * 100 : 0;\n+ \n+   return (\n+     &lt;div className=\&quot;flex flex-col gap-6 pb-32 sm:pb-12\&quot;&gt;\n+       &lt;StepIndicator\n+         steps={sortedSections.map((section) =&gt; ({\n+           id: section.id,\n+           label: section.label,\n+           order: section.order,\n+         }))}\n+         currentStep={state.currentStep}\n+         completedSteps={state.completedSteps}\n+         onStepClick={handleStepClick}\n+       /&gt;\n+ \n+       &lt;div\n+         className={cn(\n+           \&quot;min-h-[400px] space-y-6 rounded-3xl border border-border/60 bg-background/70 p-4 shadow-lg sm:p-8\&quot;,\n+           !prefersReducedMotion &amp;&amp; \&quot;transition-shadow duration-300\&quot;\n+         )}\n+       &gt;\n+         {(() =&gt; {\n+           const stepFieldKeys = getStepFieldKeys(state.currentStep, formConfig);\n+           const stepErrors: Record&lt;string, string&gt; = {};\n+           stepFieldKeys.forEach((key) =&gt; {\n+             if (state.errors[key] &amp;&amp; touchedMap[key]) {\n+               stepErrors[key] = state.errors[key];\n+             }\n+           });\n+ \n+           if (Object.keys(stepErrors).length &gt; 0) {\n+             return (\n+               &lt;FormErrorSummary\n+                 errors={stepErrors}\n+                 onErrorClick={(fieldKey) =&gt; focusFirstError(fieldKey)}\n+               /&gt;\n+             );\n+           }\n+           return null;\n+         })()}\n+ \n+         {currentSection &amp;&amp; (\n+           &lt;FormStep\n+             section={currentSection}\n+             formData={state.formData}\n+             errors={state.errors}\n+             touched={touchedMap}\n+             onFieldChange={handleFieldChange}\n+             onFieldBlur={handleFieldBlur}\n+           /&gt;\n+         )}\n+       &lt;/div&gt;\n+ \n+       &lt;FormNavigation\n+         isFirstStep={isFirstStep}\n+         isLastStep={isLastStep}\n+         onNext={handleNext}\n+         onPrevious={handlePrevious}\n+         onSaveDraft={handleManualSave}\n+         progress={progress}\n+         isSubmitting={state.isSubmitting}\n+         isSavingDraft={isSavingDraft}\n+         draftStatus={draftStatus}\n+         draftError={draftError}\n+         lastSavedAt={lastSavedAt}\n+       /&gt;\n+       &lt;p role=\&quot;status\&quot; aria-live=\&quot;polite\&quot; className=\&quot;sr-only\&quot;&gt;\n+         {liveMessage}\n+       &lt;/p&gt;\n+     &lt;/div&gt;\n+   );\n+ }\n+ \&quot;use client\&quot;;\n+ \n+ import { useCallback, useEffect, useMemo, useRef, useState } from \&quot;react\&quot;;\n+ import type { FormConfigWithFields } from \&quot;@/lib/forms/types\&quot;;\n+ import { getStepFieldKeys } from \&quot;@/lib/forms/form-validator\&quot;;\n+ import { buildFormSchema } from \&quot;@/lib/form-schema\&quot;;\n+ import { saveFormDraft, type DraftSaveResult } from \&quot;@/app/forms/actions\&quot;;\n+ import { StepIndicator } from \&quot;./step-indicator\&quot;;\n+ import { FormStep } from \&quot;./form-step\&quot;;\n+ import { FormNavigation } from \&quot;./form-navigation\&quot;;\n+ import { FormErrorSummary } from \&quot;./form-error-summary\&quot;;\n+ import { useFormState } from \&quot;@/hooks/use-form-state\&quot;;\n+ import { useAutosave } from \&quot;@/hooks/use-autosave\&quot;;\n+ import { useToast } from \&quot;@/components/ui/use-toast\&quot;;\n+ import { usePrefersReducedMotion } from \&quot;@/hooks/use-prefers-reduced-motion\&quot;;\n+ import { cn } from \&quot;@/lib/utils\&quot;;\n+ \n+ interface DynamicFormWizardProps {\n+   formConfig: FormConfigWithFields;\n+   initialData?: Record&lt;string, unknown&gt;;\n+   initialStep?: number;\n+   applicationId: string | null;\n+   organizationId: string;\n+   onApplicationIdChange?: (applicationId: string) =&gt; void;\n+   onDraftSaved?: (result: DraftSaveResult) =&gt; void;\n+   onStepChange?: (stepIndex: number) =&gt; void;\n+   onComplete?: (formData: Record&lt;string, unknown&gt;) =&gt; Promise&lt;void&gt; | void;\n+ }\n+ \n+ export function DynamicFormWizard({\n+   formConfig,\n+   initialData = {},\n+   initialStep = 0,\n+   applicationId,\n+   organizationId,\n+   onApplicationIdChange,\n+   onDraftSaved,\n+   onStepChange,\n+   onComplete,\n+ }: DynamicFormWizardProps) {\n+   const sortedSections = useMemo(\n+     () =&gt; [...formConfig.sections].sort((a, b) =&gt; a.order - b.order),\n+     [formConfig.sections]\n+   );\n+ \n+   const {\n+     state,\n+     touchedMap,\n+     setFieldValue,\n+     markFieldTouched,\n+     markFieldsTouched,\n+     setFieldError,\n+     setStepErrors,\n+     goToStep,\n+     markStepComplete,\n+     setIsSubmitting,\n+     markClean,\n+     validateAndCommitStep,\n+   } = useFormState({\n+     formConfig,\n+     initialData,\n+     initialStep,\n+   });\n+ \n+   const [liveMessage, setLiveMessage] = useState(\&quot;\&quot;);\n+   const validationTimersRef = useRef&lt;Record&lt;string, NodeJS.Timeout&gt;&gt;({});\n+   const formSchemaRef = useRef(buildFormSchema(formConfig));\n+   const prefersReducedMotion = usePrefersReducedMotion();\n+   const { toast } = useToast();\n+ \n+   const totalSteps = sortedSections.length;\n+   const currentSection = sortedSections[state.currentStep];\n+   const isFirstStep = state.currentStep === 0;\n+   const isLastStep = state.currentStep === totalSteps - 1;\n+ \n+   useEffect(() =&gt; {\n+     formSchemaRef.current = buildFormSchema(formConfig);\n+   }, [formConfig]);\n+ \n+   const focusFirstError = useCallback(\n+     (fieldKey?: string) =&gt; {\n+       if (!fieldKey || !currentSection) {\n+         return;\n+       }\n+       const errorField = currentSection.fields.find((field) =&gt; field.key === fieldKey);\n+       const fieldElement = errorField\n+         ? document.getElementById(&#96;field-${errorField.id}&#96;)\n+         : null;\n+       fieldElement?.focus();\n+       fieldElement?.scrollIntoView({ behavior: \&quot;smooth\&quot;, block: \&quot;center\&quot; });\n+     },\n+     [currentSection]\n+   );\n+ \n+   const validateField = useCallback(\n+     (fieldKey: string, value: unknown, immediate = false) =&gt; {\n+       if (validationTimersRef.current[fieldKey]) {\n+         clearTimeout(validationTimersRef.current[fieldKey]);\n+       }\n+ \n+       const performValidation = () =&gt; {\n+         const fieldSchema = formSchemaRef.current.shape[fieldKey];\n+         if (!fieldSchema) {\n+           return;\n+         }\n+ \n+         try {\n+           fieldSchema.parse(value);\n+           setFieldError(fieldKey);\n+         } catch (error) {\n+           if (error &amp;&amp; typeof error === \&quot;object\&quot; &amp;&amp; \&quot;issues\&quot; in error) {\n+             const zodError = error as { issues: Array&lt;{ message: string }&gt; };\n+             const firstIssue = zodError.issues[0];\n+             if (firstIssue) {\n+               setFieldError(fieldKey, firstIssue.message);\n+             }\n+           } else if (error instanceof Error) {\n+             setFieldError(fieldKey, error.message);\n+           }\n+         }\n+       };\n+ \n+       if (immediate) {\n+         performValidation();\n+       } else {\n+         validationTimersRef.current[fieldKey] = setTimeout(performValidation, 300);\n+       }\n+     },\n+     [setFieldError]\n+   );\n+ \n+   const handleFieldChange = useCallback(\n+     (fieldKey: string, value: unknown) =&gt; {\n+       setFieldValue(fieldKey, value);\n+       if (state.touched.has(fieldKey)) {\n+         validateField(fieldKey, value, false);\n+       }\n+     },\n+     [setFieldValue, state.touched, validateField]\n+   );\n+ \n+   const handleFieldBlur = useCallback(\n+     (fieldKey: string) =&gt; {\n+       markFieldTouched(fieldKey);\n+       validateField(fieldKey, state.formData[fieldKey], true);\n+     },\n+     [markFieldTouched, state.formData, validateField]\n+   );\n+ \n+   const autosaveFingerprint = useMemo(\n+     () =&gt; JSON.stringify({ data: state.formData, step: state.currentStep }),\n+     [state.formData, state.currentStep]\n+   );\n+ \n+   const runDraftSave = useCallback(() =&gt; {\n+     return saveFormDraft({\n+       formConfigId: formConfig.id,\n+       organizationId,\n+       entityId: formConfig.entityId,\n+       geographyId: formConfig.geographyId,\n+       applicationId,\n+       formData: state.formData,\n+       currentStep: state.currentStep,\n+     });\n+   }, [\n+     applicationId,\n+     formConfig.entityId,\n+     formConfig.geographyId,\n+     formConfig.id,\n+     organizationId,\n+     state.currentStep,\n+     state.formData,\n+   ]);\n+ \n+   const {\n+     status: draftStatus,\n+     isSaving: isSavingDraft,\n+     lastSavedAt,\n+     error: draftError,\n+     triggerSave,\n+   } = useAutosave&lt;DraftSaveResult&gt;({\n+     shouldAutosave: state.isDirty,\n+     dataFingerprint: autosaveFingerprint,\n+     save: runDraftSave,\n+     onSuccess: (result) =&gt; {\n+       markClean();\n+       if (result.applicationId &amp;&amp; result.applicationId !== applicationId) {\n+         onApplicationIdChange?.(result.applicationId);\n+       }\n+       onDraftSaved?.(result);\n+     },\n+     onError: (error) =&gt; {\n+       toast({\n+         variant: \&quot;destructive\&quot;,\n+         title: \&quot;Draft save failed\&quot;,\n+         description: error.message,\n+       });\n+     },\n+   });\n+ \n+   const handleNext = useCallback(async () =&gt; {\n+     if (state.isSubmitting) {\n+       return;\n+     }\n+ \n+     const validation = validateAndCommitStep(state.currentStep);\n+     if (!validation.isValid) {\n+       toast({\n+         variant: \&quot;destructive\&quot;,\n+         title: \&quot;Please fix validation errors\&quot;,\n+         description: \&quot;Resolve highlighted fields before continuing.\&quot;,\n+       });\n+       focusFirstError(validation.firstErrorField);\n+       return;\n+     }\n+ \n+     markStepComplete(state.currentStep);\n+ \n+     if (isLastStep &amp;&amp; onComplete) {\n+       try {\n+         setIsSubmitting(true);\n+         await onComplete(state.formData);\n+         toast({\n+           title: \&quot;Form submitted\&quot;,\n+           description: \&quot;Thank you! We received your information.\&quot;,\n+         });\n+       } catch (error) {\n+         toast({\n+           variant: \&quot;destructive\&quot;,\n+           title: \&quot;Submission failed\&quot;,\n+           description:\n+             error instanceof Error\n+               ? error.message\n+               : \&quot;Something went wrong while submitting. Please try again.\&quot;,\n+         });\n+       } finally {\n+         setIsSubmitting(false);\n+       }\n+       return;\n+     }\n+ \n+     const nextStep = state.currentStep + 1;\n+     goToStep(nextStep);\n+     onStepChange?.(nextStep);\n+     void triggerSave(\&quot;step-change\&quot;);\n+   }, [\n+     focusFirstError,\n+     goToStep,\n+     isLastStep,\n+     markStepComplete,\n+     onComplete,\n+     onStepChange,\n+     setIsSubmitting,\n+     state.currentStep,\n+     state.formData,\n+     state.isSubmitting,\n+     toast,\n+     triggerSave,\n+     validateAndCommitStep,\n+   ]);\n  \n    const handlePrevious = useCallback(() =&gt; {&quot;,
        &quot;oldStart&quot;: 659,
        &quot;newStart&quot;: 659,
        &quot;oldLines&quot;: 4,
        &quot;newLines&quot;: 404,
        &quot;linesAdded&quot;: 400
      }
    ],
    &quot;editor&quot;: &quot;EDITOR_AI&quot;
  },
  &quot;shouldAutoFixLints&quot;: true,
  &quot;resultForModel&quot;: &quot;Success. Updated the following files:\nM /Users/sahilmehta/supplier-onboarding-simple/components/forms/dynamic-form-wizard.tsx&quot;,
  &quot;contentsAfterEdit&quot;: &quot;\&quot;use client\&quot;;\n\nimport { useCallback, useEffect, useMemo, useRef, useState } from \&quot;react\&quot;;\nimport type { FormConfigWithFields } from \&quot;@/lib/forms/types\&quot;;\nimport { getStepFieldKeys } from \&quot;@/lib/forms/form-validator\&quot;;\nimport { buildFormSchema } from \&quot;@/lib/form-schema\&quot;;\nimport { saveFormDraft, type DraftSaveResult } from \&quot;@/app/forms/actions\&quot;;\nimport { StepIndicator } from \&quot;./step-indicator\&quot;;\nimport { FormStep } from \&quot;./form-step\&quot;;\nimport { FormNavigation } from \&quot;./form-navigation\&quot;;\nimport { FormErrorSummary } from \&quot;./form-error-summary\&quot;;\nimport { useFormState } from \&quot;@/hooks/use-form-state\&quot;;\nimport { useAutosave } from \&quot;@/hooks/use-autosave\&quot;;\nimport { useToast } from \&quot;@/components/ui/use-toast\&quot;;\nimport { usePrefersReducedMotion } from \&quot;@/hooks/use-prefers-reduced-motion\&quot;;\nimport { cn } from \&quot;@/lib/utils\&quot;;\n\ninterface DynamicFormWizardProps {\n  formConfig: FormConfigWithFields;\n  initialData?: Record&lt;string, unknown&gt;;\n  initialStep?: number;\n  applicationId: string | null;\n  organizationId: string;\n  onApplicationIdChange?: (applicationId: string) =&gt; void;\n  onDraftSaved?: (result: DraftSaveResult) =&gt; void;\n  onStepChange?: (stepIndex: number) =&gt; void;\n  onComplete?: (formData: Record&lt;string, unknown&gt;) =&gt; Promise&lt;void&gt; | void;\n}\n\nexport function DynamicFormWizard({\n  formConfig,\n  initialData = {},\n  initialStep = 0,\n  applicationId,\n  organizationId,\n  onApplicationIdChange,\n  onDraftSaved,\n  onStepChange,\n  onComplete,\n}: DynamicFormWizardProps) {\n  const sortedSections = useMemo(\n    () =&gt; [...formConfig.sections].sort((a, b) =&gt; a.order - b.order),\n    [formConfig.sections]\n  );\n\n  const {\n    state,\n    touchedMap,\n    setFieldValue,\n    markFieldTouched,\n    markFieldsTouched,\n    setFieldError,\n    setStepErrors,\n    goToStep,\n    markStepComplete,\n    setIsSubmitting,\n    markClean,\n    validateAndCommitStep,\n  } = useFormState({\n    formConfig,\n    initialData,\n    initialStep,\n  });\n\n  const [liveMessage, setLiveMessage] = useState(\&quot;\&quot;);\n  const validationTimersRef = useRef&lt;Record&lt;string, NodeJS.Timeout&gt;&gt;({});\n  const formSchemaRef = useRef(buildFormSchema(formConfig));\n  const prefersReducedMotion = usePrefersReducedMotion();\n  const { toast } = useToast();\n\n  const totalSteps = sortedSections.length;\n  const currentSection = sortedSections[state.currentStep];\n  const isFirstStep = state.currentStep === 0;\n  const isLastStep = state.currentStep === totalSteps - 1;\n\n  useEffect(() =&gt; {\n    formSchemaRef.current = buildFormSchema(formConfig);\n  }, [formConfig]);\n\n  const focusFirstError = useCallback(\n    (fieldKey?: string) =&gt; {\n      if (!fieldKey || !currentSection) {\n        return;\n      }\n      const errorField = currentSection.fields.find((field) =&gt; field.key === fieldKey);\n      const fieldElement = errorField\n        ? document.getElementById(&#96;field-${errorField.id}&#96;)\n        : null;\n      fieldElement?.focus();\n      fieldElement?.scrollIntoView({ behavior: \&quot;smooth\&quot;, block: \&quot;center\&quot; });\n    },\n    [currentSection]\n  );\n\n  const validateField = useCallback(\n    (fieldKey: string, value: unknown, immediate = false) =&gt; {\n      if (validationTimersRef.current[fieldKey]) {\n        clearTimeout(validationTimersRef.current[fieldKey]);\n      }\n\n      const performValidation = () =&gt; {\n        const fieldSchema = formSchemaRef.current.shape[fieldKey];\n        if (!fieldSchema) {\n          return;\n        }\n\n        try {\n          fieldSchema.parse(value);\n          setFieldError(fieldKey);\n        } catch (error) {\n          if (error &amp;&amp; typeof error === \&quot;object\&quot; &amp;&amp; \&quot;issues\&quot; in error) {\n            const zodError = error as { issues: Array&lt;{ message: string }&gt; };\n            const firstIssue = zodError.issues[0];\n            if (firstIssue) {\n              setFieldError(fieldKey, firstIssue.message);\n            }\n          } else if (error instanceof Error) {\n            setFieldError(fieldKey, error.message);\n          }\n        }\n      };\n\n      if (immediate) {\n        performValidation();\n      } else {\n        validationTimersRef.current[fieldKey] = setTimeout(performValidation, 300);\n      }\n    },\n    [setFieldError]\n  );\n\n  const handleFieldChange = useCallback(\n    (fieldKey: string, value: unknown) =&gt; {\n      setFieldValue(fieldKey, value);\n      if (state.touched.has(fieldKey)) {\n        validateField(fieldKey, value, false);\n      }\n    },\n    [setFieldValue, state.touched, validateField]\n  );\n\n  const handleFieldBlur = useCallback(\n    (fieldKey: string) =&gt; {\n      markFieldTouched(fieldKey);\n      validateField(fieldKey, state.formData[fieldKey], true);\n    },\n    [markFieldTouched, state.formData, validateField]\n  );\n\n  const autosaveFingerprint = useMemo(\n    () =&gt; JSON.stringify({ data: state.formData, step: state.currentStep }),\n    [state.formData, state.currentStep]\n  );\n\n  const runDraftSave = useCallback(() =&gt; {\n    return saveFormDraft({\n      formConfigId: formConfig.id,\n      organizationId,\n      entityId: formConfig.entityId,\n      geographyId: formConfig.geographyId,\n      applicationId,\n      formData: state.formData,\n      currentStep: state.currentStep,\n    });\n  }, [\n    applicationId,\n    formConfig.entityId,\n    formConfig.geographyId,\n    formConfig.id,\n    organizationId,\n    state.currentStep,\n    state.formData,\n  ]);\n\n  const {\n    status: draftStatus,\n    isSaving: isSavingDraft,\n    lastSavedAt,\n    error: draftError,\n    triggerSave,\n  } = useAutosave&lt;DraftSaveResult&gt;({\n    shouldAutosave: state.isDirty,\n    dataFingerprint: autosaveFingerprint,\n    save: runDraftSave,\n    onSuccess: (result) =&gt; {\n      markClean();\n      if (result.applicationId &amp;&amp; result.applicationId !== applicationId) {\n        onApplicationIdChange?.(result.applicationId);\n      }\n      onDraftSaved?.(result);\n    },\n    onError: (error) =&gt; {\n      toast({\n        variant: \&quot;destructive\&quot;,\n        title: \&quot;Draft save failed\&quot;,\n        description: error.message,\n      });\n    },\n  });\n\n  const handleNext = useCallback(async () =&gt; {\n    if (state.isSubmitting) {\n      return;\n    }\n\n    const validation = validateAndCommitStep(state.currentStep);\n    if (!validation.isValid) {\n      toast({\n        variant: \&quot;destructive\&quot;,\n        title: \&quot;Please fix validation errors\&quot;,\n        description: \&quot;Resolve highlighted fields before continuing.\&quot;,\n      });\n      focusFirstError(validation.firstErrorField);\n      return;\n    }\n\n    markStepComplete(state.currentStep);\n\n    if (isLastStep &amp;&amp; onComplete) {\n      try {\n        setIsSubmitting(true);\n        await onComplete(state.formData);\n        toast({\n          title: \&quot;Form submitted\&quot;,\n          description: \&quot;Thank you! We received your information.\&quot;,\n        });\n      } catch (error) {\n        toast({\n          variant: \&quot;destructive\&quot;,\n          title: \&quot;Submission failed\&quot;,\n          description:\n            error instanceof Error\n              ? error.message\n              : \&quot;Something went wrong while submitting. Please try again.\&quot;,\n        });\n      } finally {\n        setIsSubmitting(false);\n      }\n      return;\n    }\n\n    const nextStep = state.currentStep + 1;\n    goToStep(nextStep);\n    onStepChange?.(nextStep);\n    void triggerSave(\&quot;step-change\&quot;);\n  }, [\n    focusFirstError,\n    goToStep,\n    isLastStep,\n    markStepComplete,\n    onComplete,\n    onStepChange,\n    setIsSubmitting,\n    state.currentStep,\n    state.formData,\n    state.isSubmitting,\n    toast,\n    triggerSave,\n    validateAndCommitStep,\n  ]);\n\n  const handlePrevious = useCallback(() =&gt; {\n    if (isFirstStep) {\n      return;\n    }\n    const prevStep = state.currentStep - 1;\n    goToStep(prevStep);\n    onStepChange?.(prevStep);\n  }, [goToStep, isFirstStep, onStepChange, state.currentStep]);\n\n  const handleStepClick = useCallback(\n    (stepIndex: number) =&gt; {\n      if (stepIndex === state.currentStep) {\n        return;\n      }\n\n      const validation = validateAndCommitStep(state.currentStep);\n      if (!validation.isValid) {\n        toast({\n          variant: \&quot;destructive\&quot;,\n          title: \&quot;Cannot leave step yet\&quot;,\n          description: \&quot;Fix validation errors before moving on.\&quot;,\n        });\n        focusFirstError(validation.firstErrorField);\n        return;\n      }\n\n      if (\n        state.completedSteps.has(stepIndex) ||\n        stepIndex === state.currentStep + 1\n      ) {\n        goToStep(stepIndex);\n        onStepChange?.(stepIndex);\n        void triggerSave(\&quot;step-change\&quot;);\n      }\n    },\n    [\n      focusFirstError,\n      goToStep,\n      onStepChange,\n      state.completedSteps,\n      state.currentStep,\n      toast,\n      triggerSave,\n      validateAndCommitStep,\n    ]\n  );\n\n  const handleManualSave = useCallback(() =&gt; {\n    void triggerSave(\&quot;manual\&quot;);\n  }, [triggerSave]);\n\n  useEffect(() =&gt; {\n    return () =&gt; {\n      Object.values(validationTimersRef.current).forEach((timer) =&gt; {\n        clearTimeout(timer);\n      });\n    };\n  }, []);\n\n  useEffect(() =&gt; {\n    const sectionLabel = currentSection?.label ?? &#96;Step ${state.currentStep + 1}&#96;;\n    setLiveMessage(\n      &#96;Now viewing ${sectionLabel} (${state.currentStep + 1} of ${totalSteps})&#96;\n    );\n  }, [currentSection, state.currentStep, totalSteps]);\n\n  const progress =\n    totalSteps &gt; 0 ? ((state.currentStep + 1) / totalSteps) * 100 : 0;\n\n  return (\n    &lt;div className=\&quot;flex flex-col gap-6 pb-32 sm:pb-12\&quot;&gt;\n      &lt;StepIndicator\n        steps={sortedSections.map((section) =&gt; ({\n          id: section.id,\n          label: section.label,\n          order: section.order,\n        }))}\n        currentStep={state.currentStep}\n        completedSteps={state.completedSteps}\n        onStepClick={handleStepClick}\n      /&gt;\n\n      &lt;div\n        className={cn(\n          \&quot;min-h-[400px] space-y-6 rounded-3xl border border-border/60 bg-background/70 p-4 shadow-lg sm:p-8\&quot;,\n          !prefersReducedMotion &amp;&amp; \&quot;transition-shadow duration-300\&quot;\n        )}\n      &gt;\n        {(() =&gt; {\n          const stepFieldKeys = getStepFieldKeys(state.currentStep, formConfig);\n          const stepErrors: Record&lt;string, string&gt; = {};\n          stepFieldKeys.forEach((key) =&gt; {\n            if (state.errors[key] &amp;&amp; touchedMap[key]) {\n              stepErrors[key] = state.errors[key];\n            }\n          });\n\n          if (Object.keys(stepErrors).length &gt; 0) {\n            return (\n              &lt;FormErrorSummary\n                errors={stepErrors}\n                onErrorClick={(fieldKey) =&gt; focusFirstError(fieldKey)}\n              /&gt;\n            );\n          }\n          return null;\n        })()}\n\n        {currentSection &amp;&amp; (\n          &lt;FormStep\n            section={currentSection}\n            formData={state.formData}\n            errors={state.errors}\n            touched={touchedMap}\n            onFieldChange={handleFieldChange}\n            onFieldBlur={handleFieldBlur}\n          /&gt;\n        )}\n      &lt;/div&gt;\n\n      &lt;FormNavigation\n        isFirstStep={isFirstStep}\n        isLastStep={isLastStep}\n        onNext={handleNext}\n        onPrevious={handlePrevious}\n        onSaveDraft={handleManualSave}\n        progress={progress}\n        isSubmitting={state.isSubmitting}\n        isSavingDraft={isSavingDraft}\n        draftStatus={draftStatus}\n        draftError={draftError}\n        lastSavedAt={lastSavedAt}\n      /&gt;\n      &lt;p role=\&quot;status\&quot; aria-live=\&quot;polite\&quot; className=\&quot;sr-only\&quot;&gt;\n        {liveMessage}\n      &lt;/p&gt;\n    &lt;/div&gt;\n  );\n}\n\&quot;use client\&quot;;\n\nimport { useCallback, useEffect, useMemo, useRef, useState } from \&quot;react\&quot;;\nimport type { FormConfigWithFields } from \&quot;@/lib/forms/types\&quot;;\nimport { getStepFieldKeys } from \&quot;@/lib/forms/form-validator\&quot;;\nimport { buildFormSchema } from \&quot;@/lib/form-schema\&quot;;\nimport { saveFormDraft, type DraftSaveResult } from \&quot;@/app/forms/actions\&quot;;\nimport { StepIndicator } from \&quot;./step-indicator\&quot;;\nimport { FormStep } from \&quot;./form-step\&quot;;\nimport { FormNavigation } from \&quot;./form-navigation\&quot;;\nimport { FormErrorSummary } from \&quot;./form-error-summary\&quot;;\nimport { useFormState } from \&quot;@/hooks/use-form-state\&quot;;\nimport { useAutosave } from \&quot;@/hooks/use-autosave\&quot;;\nimport { useToast } from \&quot;@/components/ui/use-toast\&quot;;\nimport { usePrefersReducedMotion } from \&quot;@/hooks/use-prefers-reduced-motion\&quot;;\nimport { cn } from \&quot;@/lib/utils\&quot;;\n\ninterface DynamicFormWizardProps {\n  formConfig: FormConfigWithFields;\n  initialData?: Record&lt;string, unknown&gt;;\n  initialStep?: number;\n  applicationId: string | null;\n  organizationId: string;\n  onApplicationIdChange?: (applicationId: string) =&gt; void;\n  onDraftSaved?: (result: DraftSaveResult) =&gt; void;\n  onStepChange?: (stepIndex: number) =&gt; void;\n  onComplete?: (formData: Record&lt;string, unknown&gt;) =&gt; Promise&lt;void&gt; | void;\n}\n\nexport function DynamicFormWizard({\n  formConfig,\n  initialData = {},\n  initialStep = 0,\n  applicationId,\n  organizationId,\n  onApplicationIdChange,\n  onDraftSaved,\n  onStepChange,\n  onComplete,\n}: DynamicFormWizardProps) {\n  const sortedSections = useMemo(\n    () =&gt; [...formConfig.sections].sort((a, b) =&gt; a.order - b.order),\n    [formConfig.sections]\n  );\n\n  const {\n    state,\n    touchedMap,\n    setFieldValue,\n    markFieldTouched,\n    markFieldsTouched,\n    setFieldError,\n    setStepErrors,\n    goToStep,\n    markStepComplete,\n    setIsSubmitting,\n    markClean,\n    validateAndCommitStep,\n  } = useFormState({\n    formConfig,\n    initialData,\n    initialStep,\n  });\n\n  const [liveMessage, setLiveMessage] = useState(\&quot;\&quot;);\n  const validationTimersRef = useRef&lt;Record&lt;string, NodeJS.Timeout&gt;&gt;({});\n  const formSchemaRef = useRef(buildFormSchema(formConfig));\n  const prefersReducedMotion = usePrefersReducedMotion();\n  const { toast } = useToast();\n\n  const totalSteps = sortedSections.length;\n  const currentSection = sortedSections[state.currentStep];\n  const isFirstStep = state.currentStep === 0;\n  const isLastStep = state.currentStep === totalSteps - 1;\n\n  useEffect(() =&gt; {\n    formSchemaRef.current = buildFormSchema(formConfig);\n  }, [formConfig]);\n\n  const focusFirstError = useCallback(\n    (fieldKey?: string) =&gt; {\n      if (!fieldKey || !currentSection) {\n        return;\n      }\n      const errorField = currentSection.fields.find((field) =&gt; field.key === fieldKey);\n      const fieldElement = errorField\n        ? document.getElementById(&#96;field-${errorField.id}&#96;)\n        : null;\n      fieldElement?.focus();\n      fieldElement?.scrollIntoView({ behavior: \&quot;smooth\&quot;, block: \&quot;center\&quot; });\n    },\n    [currentSection]\n  );\n\n  const validateField = useCallback(\n    (fieldKey: string, value: unknown, immediate = false) =&gt; {\n      if (validationTimersRef.current[fieldKey]) {\n        clearTimeout(validationTimersRef.current[fieldKey]);\n      }\n\n      const performValidation = () =&gt; {\n        const fieldSchema = formSchemaRef.current.shape[fieldKey];\n        if (!fieldSchema) {\n          return;\n        }\n\n        try {\n          fieldSchema.parse(value);\n          setFieldError(fieldKey);\n        } catch (error) {\n          if (error &amp;&amp; typeof error === \&quot;object\&quot; &amp;&amp; \&quot;issues\&quot; in error) {\n            const zodError = error as { issues: Array&lt;{ message: string }&gt; };\n            const firstIssue = zodError.issues[0];\n            if (firstIssue) {\n              setFieldError(fieldKey, firstIssue.message);\n            }\n          } else if (error instanceof Error) {\n            setFieldError(fieldKey, error.message);\n          }\n        }\n      };\n\n      if (immediate) {\n        performValidation();\n      } else {\n        validationTimersRef.current[fieldKey] = setTimeout(performValidation, 300);\n      }\n    },\n    [setFieldError]\n  );\n\n  const handleFieldChange = useCallback(\n    (fieldKey: string, value: unknown) =&gt; {\n      setFieldValue(fieldKey, value);\n      if (state.touched.has(fieldKey)) {\n        validateField(fieldKey, value, false);\n      }\n    },\n    [setFieldValue, state.touched, validateField]\n  );\n\n  const handleFieldBlur = useCallback(\n    (fieldKey: string) =&gt; {\n      markFieldTouched(fieldKey);\n      validateField(fieldKey, state.formData[fieldKey], true);\n    },\n    [markFieldTouched, state.formData, validateField]\n  );\n\n  const autosaveFingerprint = useMemo(\n    () =&gt; JSON.stringify({ data: state.formData, step: state.currentStep }),\n    [state.formData, state.currentStep]\n  );\n\n  const runDraftSave = useCallback(() =&gt; {\n    return saveFormDraft({\n      formConfigId: formConfig.id,\n      organizationId,\n      entityId: formConfig.entityId,\n      geographyId: formConfig.geographyId,\n      applicationId,\n      formData: state.formData,\n      currentStep: state.currentStep,\n    });\n  }, [\n    applicationId,\n    formConfig.entityId,\n    formConfig.geographyId,\n    formConfig.id,\n    organizationId,\n    state.currentStep,\n    state.formData,\n  ]);\n\n  const {\n    status: draftStatus,\n    isSaving: isSavingDraft,\n    lastSavedAt,\n    error: draftError,\n    triggerSave,\n  } = useAutosave&lt;DraftSaveResult&gt;({\n    shouldAutosave: state.isDirty,\n    dataFingerprint: autosaveFingerprint,\n    save: runDraftSave,\n    onSuccess: (result) =&gt; {\n      markClean();\n      if (result.applicationId &amp;&amp; result.applicationId !== applicationId) {\n        onApplicationIdChange?.(result.applicationId);\n      }\n      onDraftSaved?.(result);\n    },\n    onError: (error) =&gt; {\n      toast({\n        variant: \&quot;destructive\&quot;,\n        title: \&quot;Draft save failed\&quot;,\n        description: error.message,\n      });\n    },\n  });\n\n  const handleNext = useCallback(async () =&gt; {\n    if (state.isSubmitting) {\n      return;\n    }\n\n    const validation = validateAndCommitStep(state.currentStep);\n    if (!validation.isValid) {\n      toast({\n        variant: \&quot;destructive\&quot;,\n        title: \&quot;Please fix validation errors\&quot;,\n        description: \&quot;Resolve highlighted fields before continuing.\&quot;,\n      });\n      focusFirstError(validation.firstErrorField);\n      return;\n    }\n\n    markStepComplete(state.currentStep);\n\n    if (isLastStep &amp;&amp; onComplete) {\n      try {\n        setIsSubmitting(true);\n        await onComplete(state.formData);\n        toast({\n          title: \&quot;Form submitted\&quot;,\n          description: \&quot;Thank you! We received your information.\&quot;,\n        });\n      } catch (error) {\n        toast({\n          variant: \&quot;destructive\&quot;,\n          title: \&quot;Submission failed\&quot;,\n          description:\n            error instanceof Error\n              ? error.message\n              : \&quot;Something went wrong while submitting. Please try again.\&quot;,\n        });\n      } finally {\n        setIsSubmitting(false);\n      }\n      return;\n    }\n\n    const nextStep = state.currentStep + 1;\n    goToStep(nextStep);\n    onStepChange?.(nextStep);\n    void triggerSave(\&quot;step-change\&quot;);\n  }, [\n    focusFirstError,\n    goToStep,\n    isLastStep,\n    markStepComplete,\n    onComplete,\n    onStepChange,\n    setIsSubmitting,\n    state.currentStep,\n    state.formData,\n    state.isSubmitting,\n    toast,\n    triggerSave,\n    validateAndCommitStep,\n  ]);\n\n  const handlePrevious = useCallback(() =&gt; {\n    if (isFirstStep) {\n      return;\n    }\n    const prevStep = state.currentStep - 1;\n    goToStep(prevStep);\n    onStepChange?.(prevStep);\n  }, [goToStep, isFirstStep, onStepChange, state.currentStep]);\n\n  const handleStepClick = useCallback(\n    (stepIndex: number) =&gt; {\n      if (stepIndex === state.currentStep) {\n        return;\n      }\n\n      const validation = validateAndCommitStep(state.currentStep);\n      if (!validation.isValid) {\n        toast({\n          variant: \&quot;destructive\&quot;,\n          title: \&quot;Cannot leave step yet\&quot;,\n          description: \&quot;Fix validation errors before moving on.\&quot;,\n        });\n        focusFirstError(validation.firstErrorField);\n        return;\n      }\n\n      if (\n        state.completedSteps.has(stepIndex) ||\n        stepIndex === state.currentStep + 1\n      ) {\n        goToStep(stepIndex);\n        onStepChange?.(stepIndex);\n        void triggerSave(\&quot;step-change\&quot;);\n      }\n    },\n    [\n      focusFirstError,\n      goToStep,\n      onStepChange,\n      state.completedSteps,\n      state.currentStep,\n      toast,\n      triggerSave,\n      validateAndCommitStep,\n    ]\n  );\n\n  const handleManualSave = useCallback(() =&gt; {\n    void triggerSave(\&quot;manual\&quot;);\n  }, [triggerSave]);\n\n  useEffect(() =&gt; {\n    return () =&gt; {\n      Object.values(validationTimersRef.current).forEach((timer) =&gt; {\n        clearTimeout(timer);\n      });\n    };\n  }, []);\n\n  useEffect(() =&gt; {\n    const sectionLabel = currentSection?.label ?? &#96;Step ${state.currentStep + 1}&#96;;\n    setLiveMessage(\n      &#96;Now viewing ${sectionLabel} (${state.currentStep + 1} of ${totalSteps})&#96;\n    );\n  }, [currentSection, state.currentStep, totalSteps]);\n\n  const progress =\n    totalSteps &gt; 0 ? ((state.currentStep + 1) / totalSteps) * 100 : 0;\n\n  return (\n    &lt;div className=\&quot;flex flex-col gap-6 pb-32 sm:pb-12\&quot;&gt;\n      &lt;StepIndicator\n        steps={sortedSections.map((section) =&gt; ({\n          id: section.id,\n          label: section.label,\n          order: section.order,\n        }))}\n        currentStep={state.currentStep}\n        completedSteps={state.completedSteps}\n        onStepClick={handleStepClick}\n      /&gt;\n\n      &lt;div\n        className={cn(\n          \&quot;min-h-[400px] space-y-6 rounded-3xl border border-border/60 bg-background/70 p-4 shadow-lg sm:p-8\&quot;,\n          !prefersReducedMotion &amp;&amp; \&quot;transition-shadow duration-300\&quot;\n        )}\n      &gt;\n        {(() =&gt; {\n          const stepFieldKeys = getStepFieldKeys(state.currentStep, formConfig);\n          const stepErrors: Record&lt;string, string&gt; = {};\n          stepFieldKeys.forEach((key) =&gt; {\n            if (state.errors[key] &amp;&amp; touchedMap[key]) {\n              stepErrors[key] = state.errors[key];\n            }\n          });\n\n          if (Object.keys(stepErrors).length &gt; 0) {\n            return (\n              &lt;FormErrorSummary\n                errors={stepErrors}\n                onErrorClick={(fieldKey) =&gt; focusFirstError(fieldKey)}\n              /&gt;\n            );\n          }\n          return null;\n        })()}\n\n        {currentSection &amp;&amp; (\n          &lt;FormStep\n            section={currentSection}\n            formData={state.formData}\n            errors={state.errors}\n            touched={touchedMap}\n            onFieldChange={handleFieldChange}\n            onFieldBlur={handleFieldBlur}\n          /&gt;\n        )}\n      &lt;/div&gt;\n\n      &lt;FormNavigation\n        isFirstStep={isFirstStep}\n        isLastStep={isLastStep}\n        onNext={handleNext}\n        onPrevious={handlePrevious}\n        onSaveDraft={handleManualSave}\n        progress={progress}\n        isSubmitting={state.isSubmitting}\n        isSavingDraft={isSavingDraft}\n        draftStatus={draftStatus}\n        draftError={draftError}\n        lastSavedAt={lastSavedAt}\n      /&gt;\n      &lt;p role=\&quot;status\&quot; aria-live=\&quot;polite\&quot; className=\&quot;sr-only\&quot;&gt;\n        {liveMessage}\n      &lt;/p&gt;\n    &lt;/div&gt;\n  );\n}\n\&quot;use client\&quot;;\n\nimport { useCallback, useEffect, useMemo, useRef, useState } from \&quot;react\&quot;;\nimport type { FormConfigWithFields } from \&quot;@/lib/forms/types\&quot;;\nimport { getStepFieldKeys } from \&quot;@/lib/forms/form-validator\&quot;;\nimport { buildFormSchema } from \&quot;@/lib/form-schema\&quot;;\nimport { saveFormDraft, type DraftSaveResult } from \&quot;@/app/forms/actions\&quot;;\nimport { StepIndicator } from \&quot;./step-indicator\&quot;;\nimport { FormStep } from \&quot;./form-step\&quot;;\nimport { FormNavigation } from \&quot;./form-navigation\&quot;;\nimport { FormErrorSummary } from \&quot;./form-error-summary\&quot;;\nimport { useFormState } from \&quot;@/hooks/use-form-state\&quot;;\nimport { useAutosave } from \&quot;@/hooks/use-autosave\&quot;;\nimport { useToast } from \&quot;@/components/ui/use-toast\&quot;;\nimport { usePrefersReducedMotion } from \&quot;@/hooks/use-prefers-reduced-motion\&quot;;\nimport { cn } from \&quot;@/lib/utils\&quot;;\n\ninterface DynamicFormWizardProps {\n  formConfig: FormConfigWithFields;\n  initialData?: Record&lt;string, unknown&gt;;\n  initialStep?: number;\n  applicationId: string | null;\n  organizationId: string;\n  onApplicationIdChange?: (applicationId: string) =&gt; void;\n  onDraftSaved?: (result: DraftSaveResult) =&gt; void;\n  onStepChange?: (stepIndex: number) =&gt; void;\n  onComplete?: (formData: Record&lt;string, unknown&gt;) =&gt; Promise&lt;void&gt; | void;\n}\n\nexport function DynamicFormWizard({\n  formConfig,\n  initialData = {},\n  initialStep = 0,\n  applicationId,\n  organizationId,\n  onApplicationIdChange,\n  onDraftSaved,\n  onStepChange,\n  onComplete,\n}: DynamicFormWizardProps) {\n  const sortedSections = useMemo(\n    () =&gt; [...formConfig.sections].sort((a, b) =&gt; a.order - b.order),\n    [formConfig.sections]\n  );\n\n  const {\n    state,\n    touchedMap,\n    setFieldValue,\n    markFieldTouched,\n    markFieldsTouched,\n    setFieldError,\n    setStepErrors,\n    goToStep,\n    markStepComplete,\n    setIsSubmitting,\n    markClean,\n    validateAndCommitStep,\n  } = useFormState({\n    formConfig,\n    initialData,\n    initialStep,\n  });\n\n  const [liveMessage, setLiveMessage] = useState(\&quot;\&quot;);\n  const validationTimersRef = useRef&lt;Record&lt;string, NodeJS.Timeout&gt;&gt;({});\n  const formSchemaRef = useRef(buildFormSchema(formConfig));\n  const prefersReducedMotion = usePrefersReducedMotion();\n  const { toast } = useToast();\n\n  const totalSteps = sortedSections.length;\n  const currentSection = sortedSections[state.currentStep];\n  const isFirstStep = state.currentStep === 0;\n  const isLastStep = state.currentStep === totalSteps - 1;\n\n  useEffect(() =&gt; {\n    formSchemaRef.current = buildFormSchema(formConfig);\n  }, [formConfig]);\n\n  const focusFirstError = useCallback(\n    (fieldKey?: string) =&gt; {\n      if (!fieldKey || !currentSection) {\n        return;\n      }\n      const errorField = currentSection.fields.find((field) =&gt; field.key === fieldKey);\n      const fieldElement = errorField\n        ? document.getElementById(&#96;field-${errorField.id}&#96;)\n        : null;\n      fieldElement?.focus();\n      fieldElement?.scrollIntoView({ behavior: \&quot;smooth\&quot;, block: \&quot;center\&quot; });\n    },\n    [currentSection]\n  );\n\n  const validateField = useCallback(\n    (fieldKey: string, value: unknown, immediate = false) =&gt; {\n      if (validationTimersRef.current[fieldKey]) {\n        clearTimeout(validationTimersRef.current[fieldKey]);\n      }\n\n      const performValidation = () =&gt; {\n        const fieldSchema = formSchemaRef.current.shape[fieldKey];\n        if (!fieldSchema) {\n          return;\n        }\n\n        try {\n          fieldSchema.parse(value);\n          setFieldError(fieldKey);\n        } catch (error) {\n          if (error &amp;&amp; typeof error === \&quot;object\&quot; &amp;&amp; \&quot;issues\&quot; in error) {\n            const zodError = error as { issues: Array&lt;{ message: string }&gt; };\n            const firstIssue = zodError.issues[0];\n            if (firstIssue) {\n              setFieldError(fieldKey, firstIssue.message);\n            }\n          } else if (error instanceof Error) {\n            setFieldError(fieldKey, error.message);\n          }\n        }\n      };\n\n      if (immediate) {\n        performValidation();\n      } else {\n        validationTimersRef.current[fieldKey] = setTimeout(performValidation, 300);\n      }\n    },\n    [setFieldError]\n  );\n\n  const handleFieldChange = useCallback(\n    (fieldKey: string, value: unknown) =&gt; {\n      setFieldValue(fieldKey, value);\n      if (state.touched.has(fieldKey)) {\n        validateField(fieldKey, value, false);\n      }\n    },\n    [setFieldValue, state.touched, validateField]\n  );\n\n  const handleFieldBlur = useCallback(\n    (fieldKey: string) =&gt; {\n      markFieldTouched(fieldKey);\n      validateField(fieldKey, state.formData[fieldKey], true);\n    },\n    [markFieldTouched, state.formData, validateField]\n  );\n\n  const autosaveFingerprint = useMemo(\n    () =&gt; JSON.stringify({ data: state.formData, step: state.currentStep }),\n    [state.formData, state.currentStep]\n  );\n\n  const runDraftSave = useCallback(() =&gt; {\n    return saveFormDraft({\n      formConfigId: formConfig.id,\n      organizationId,\n      entityId: formConfig.entityId,\n      geographyId: formConfig.geographyId,\n      applicationId,\n      formData: state.formData,\n      currentStep: state.currentStep,\n    });\n  }, [\n    applicationId,\n    formConfig.entityId,\n    formConfig.geographyId,\n    formConfig.id,\n    organizationId,\n    state.currentStep,\n    state.formData,\n  ]);\n\n  const {\n    status: draftStatus,\n    isSaving: isSavingDraft,\n    lastSavedAt,\n    error: draftError,\n    triggerSave,\n  } = useAutosave&lt;DraftSaveResult&gt;({\n    shouldAutosave: state.isDirty,\n    dataFingerprint: autosaveFingerprint,\n    save: runDraftSave,\n    onSuccess: (result) =&gt; {\n      markClean();\n      if (result.applicationId &amp;&amp; result.applicationId !== applicationId) {\n        onApplicationIdChange?.(result.applicationId);\n      }\n      onDraftSaved?.(result);\n    },\n    onError: (error) =&gt; {\n      toast({\n        variant: \&quot;destructive\&quot;,\n        title: \&quot;Draft save failed\&quot;,\n        description: error.message,\n      });\n    },\n  });\n\n  const handleNext = useCallback(async () =&gt; {\n    if (state.isSubmitting) {\n      return;\n    }\n\n    const validation = validateAndCommitStep(state.currentStep);\n    if (!validation.isValid) {\n      toast({\n        variant: \&quot;destructive\&quot;,\n        title: \&quot;Please fix validation errors\&quot;,\n        description: \&quot;Resolve highlighted fields before continuing.\&quot;,\n      });\n      focusFirstError(validation.firstErrorField);\n      return;\n    }\n\n    markStepComplete(state.currentStep);\n\n    if (isLastStep &amp;&amp; onComplete) {\n      try {\n        setIsSubmitting(true);\n        await onComplete(state.formData);\n        toast({\n          title: \&quot;Form submitted\&quot;,\n          description: \&quot;Thank you! We received your information.\&quot;,\n        });\n      } catch (error) {\n        toast({\n          variant: \&quot;destructive\&quot;,\n          title: \&quot;Submission failed\&quot;,\n          description:\n            error instanceof Error\n              ? error.message\n              : \&quot;Something went wrong while submitting. Please try again.\&quot;,\n        });\n      } finally {\n        setIsSubmitting(false);\n      }\n      return;\n    }\n\n    const nextStep = state.currentStep + 1;\n    goToStep(nextStep);\n    onStepChange?.(nextStep);\n    void triggerSave(\&quot;step-change\&quot;);\n  }, [\n    focusFirstError,\n    goToStep,\n    isLastStep,\n    markStepComplete,\n    onComplete,\n    onStepChange,\n    setIsSubmitting,\n    state.currentStep,\n    state.formData,\n    state.isSubmitting,\n    toast,\n    triggerSave,\n    validateAndCommitStep,\n  ]);\n\n  const handlePrevious = useCallback(() =&gt; {\n    if (isFirstStep) {\n      return;\n    }\n    const prevStep = state.currentStep - 1;\n    goToStep(prevStep);\n    onStepChange?.(prevStep);\n  }, [goToStep, isFirstStep, onStepChange, state.currentStep]);\n\n  const handleStepClick = useCallback(\n    (stepIndex: number) =&gt; {\n      if (stepIndex === state.currentStep) {\n        return;\n      }\n\n      const validation = validateAndCommitStep(state.currentStep);\n      if (!validation.isValid) {\n        toast({\n          variant: \&quot;destructive\&quot;,\n          title: \&quot;Cannot leave step yet\&quot;,\n          description: \&quot;Fix validation errors before moving on.\&quot;,\n        });\n        focusFirstError(validation.firstErrorField);\n        return;\n      }\n\n      if (\n        state.completedSteps.has(stepIndex) ||\n        stepIndex === state.currentStep + 1\n      ) {\n        goToStep(stepIndex);\n        onStepChange?.(stepIndex);\n        void triggerSave(\&quot;step-change\&quot;);\n      }\n    },\n    [\n      focusFirstError,\n      goToStep,\n      onStepChange,\n      state.completedSteps,\n      state.currentStep,\n      toast,\n      triggerSave,\n      validateAndCommitStep,\n    ]\n  );\n\n  const handleManualSave = useCallback(() =&gt; {\n    void triggerSave(\&quot;manual\&quot;);\n  }, [triggerSave]);\n\n  useEffect(() =&gt; {\n    const timers = validationTimersRef.current;\n    return () =&gt; {\n      Object.values(timers).forEach((timer) =&gt; {\n        clearTimeout(timer);\n      });\n    };\n  }, []);\n\n  useEffect(() =&gt; {\n    const sectionLabel = currentSection?.label ?? &#96;Step ${state.currentStep + 1}&#96;;\n    setLiveMessage(\n      &#96;Now viewing ${sectionLabel} (${state.currentStep + 1} of ${totalSteps})&#96;\n    );\n  }, [currentSection, state.currentStep, totalSteps]);\n\n  const progress =\n    totalSteps &gt; 0 ? ((state.currentStep + 1) / totalSteps) * 100 : 0;\n\n  return (\n    &lt;div className=\&quot;flex flex-col gap-6 pb-32 sm:pb-12\&quot;&gt;\n      &lt;StepIndicator\n        steps={sortedSections.map((section) =&gt; ({\n          id: section.id,\n          label: section.label,\n          order: section.order,\n        }))}\n        currentStep={state.currentStep}\n        completedSteps={state.completedSteps}\n        onStepClick={handleStepClick}\n      /&gt;\n\n      &lt;div\n        className={cn(\n          \&quot;min-h-[400px] space-y-6 rounded-3xl border border-border/60 bg-background/70 p-4 shadow-lg sm:p-8\&quot;,\n          !prefersReducedMotion &amp;&amp; \&quot;transition-shadow duration-300\&quot;\n        )}\n      &gt;\n        {(() =&gt; {\n          const stepFieldKeys = getStepFieldKeys(state.currentStep, formConfig);\n          const stepErrors: Record&lt;string, string&gt; = {};\n          stepFieldKeys.forEach((key) =&gt; {\n            if (state.errors[key] &amp;&amp; touchedMap[key]) {\n              stepErrors[key] = state.errors[key];\n            }\n          });\n\n          if (Object.keys(stepErrors).length &gt; 0) {\n            return (\n              &lt;FormErrorSummary\n                errors={stepErrors}\n                onErrorClick={(fieldKey) =&gt; focusFirstError(fieldKey)}\n              /&gt;\n            );\n          }\n          return null;\n        })()}\n\n        {currentSection &amp;&amp; (\n          &lt;FormStep\n            section={currentSection}\n            formData={state.formData}\n            errors={state.errors}\n            touched={touchedMap}\n            onFieldChange={handleFieldChange}\n            onFieldBlur={handleFieldBlur}\n          /&gt;\n        )}\n      &lt;/div&gt;\n\n      &lt;FormNavigation\n        isFirstStep={isFirstStep}\n        isLastStep={isLastStep}\n        onNext={handleNext}\n        onPrevious={handlePrevious}\n        onSaveDraft={handleManualSave}\n        progress={progress}\n        isSubmitting={state.isSubmitting}\n        isSavingDraft={isSavingDraft}\n        draftStatus={draftStatus}\n        draftError={draftError}\n        lastSavedAt={lastSavedAt}\n      /&gt;\n      &lt;p role=\&quot;status\&quot; aria-live=\&quot;polite\&quot; className=\&quot;sr-only\&quot;&gt;\n        {liveMessage}\n      &lt;/p&gt;\n    &lt;/div&gt;\n  );\n}\n\&quot;use client\&quot;;\n\nimport { useState, useCallback, useRef, useEffect } from \&quot;react\&quot;;\nimport type { FormConfigWithFields } from \&quot;@/lib/forms/types\&quot;;\nimport { validateStep, getStepFieldKeys } from \&quot;@/lib/forms/form-validator\&quot;;\nimport { buildFormSchema } from \&quot;@/lib/form-schema\&quot;;\nimport { StepIndicator } from \&quot;./step-indicator\&quot;;\nimport { FormStep } from \&quot;./form-step\&quot;;\nimport { FormNavigation } from \&quot;./form-navigation\&quot;;\nimport { FormErrorSummary } from \&quot;./form-error-summary\&quot;;\nimport { usePrefersReducedMotion } from \&quot;@/hooks/use-prefers-reduced-motion\&quot;;\nimport { useToast } from \&quot;@/components/ui/use-toast\&quot;;\nimport { cn } from \&quot;@/lib/utils\&quot;;\nimport type { DraftStatus } from \&quot;./draft-save-indicator\&quot;;\n\ninterface DynamicFormWizardProps {\n  formConfig: FormConfigWithFields;\n  initialData?: Record&lt;string, unknown&gt;;\n  onStepChange?: (stepIndex: number) =&gt; void;\n  onComplete?: (formData: Record&lt;string, unknown&gt;) =&gt; void;\n  onSaveDraft?: (formData: Record&lt;string, unknown&gt;) =&gt; void;\n}\n\nexport function DynamicFormWizard({\n  formConfig,\n  initialData = {},\n  onStepChange,\n  onComplete,\n  onSaveDraft,\n}: DynamicFormWizardProps) {\n  const sortedSections = [...formConfig.sections].sort(\n    (a, b) =&gt; a.order - b.order\n  );\n\n  const [currentStep, setCurrentStep] = useState(0);\n  const [formData, setFormData] = useState&lt;Record&lt;string, unknown&gt;&gt;(\n    initialData\n  );\n  const [completedSteps, setCompletedSteps] = useState&lt;Set&lt;number&gt;&gt;(\n    new Set()\n  );\n  const [errors, setErrors] = useState&lt;Record&lt;string, string&gt;&gt;({});\n  const [touched, setTouched] = useState&lt;Record&lt;string, boolean&gt;&gt;({});\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  const [isSavingDraft, setIsSavingDraft] = useState(false);\n  const [draftStatus, setDraftStatus] = useState&lt;DraftStatus&gt;(\&quot;idle\&quot;);\n  const [draftError, setDraftError] = useState&lt;string | null&gt;(null);\n  const [lastSavedAt, setLastSavedAt] = useState&lt;Date | null&gt;(null);\n  const [liveMessage, setLiveMessage] = useState(\&quot;\&quot;);\n  const validationTimersRef = useRef&lt;Record&lt;string, NodeJS.Timeout&gt;&gt;({});\n  const formSchemaRef = useRef(buildFormSchema(formConfig));\n  const prefersReducedMotion = usePrefersReducedMotion();\n  const { toast } = useToast();\n\n  const totalSteps = sortedSections.length;\n  const currentSection = sortedSections[currentStep];\n  const isFirstStep = currentStep === 0;\n  const isLastStep = currentStep === totalSteps - 1;\n\n  // Rebuild schema if form config changes\n  useEffect(() =&gt; {\n    formSchemaRef.current = buildFormSchema(formConfig);\n  }, [formConfig]);\n\n  /**\n   * Validate a single field with debouncing\n   */\n  const validateField = useCallback(\n    (fieldKey: string, value: unknown, immediate = false) =&gt; {\n      // Clear existing timer for this field\n      if (validationTimersRef.current[fieldKey]) {\n        clearTimeout(validationTimersRef.current[fieldKey]);\n      }\n\n      const performValidation = () =&gt; {\n        const fieldSchema = formSchemaRef.current.shape[fieldKey];\n        if (!fieldSchema) {\n          return;\n        }\n\n        try {\n          fieldSchema.parse(value);\n          // Clear error if validation passes\n          setErrors((prev) =&gt; {\n            const next = { ...prev };\n            delete next[fieldKey];\n            return next;\n          });\n        } catch (error) {\n          if (error &amp;&amp; typeof error === \&quot;object\&quot; &amp;&amp; \&quot;issues\&quot; in error) {\n            const zodError = error as { issues: Array&lt;{ message: string }&gt; };\n            const firstIssue = zodError.issues[0];\n            if (firstIssue) {\n              setErrors((prev) =&gt; ({\n                ...prev,\n                [fieldKey]: firstIssue.message,\n              }));\n            }\n          } else if (error instanceof Error) {\n            setErrors((prev) =&gt; ({\n              ...prev,\n              [fieldKey]: error.message,\n            }));\n          }\n        }\n      };\n\n      if (immediate) {\n        performValidation();\n      } else {\n        // Debounce validation on change (300ms)\n        validationTimersRef.current[fieldKey] = setTimeout(performValidation, 300);\n      }\n    },\n    []\n  );\n\n  const handleFieldChange = useCallback(\n    (fieldKey: string, value: unknown) =&gt; {\n      setFormData((prev) =&gt; ({\n        ...prev,\n        [fieldKey]: value,\n      }));\n\n      // Validate on change with debounce (only if field has been touched)\n      if (touched[fieldKey]) {\n        validateField(fieldKey, value, false);\n      }\n    },\n    [touched, validateField]\n  );\n\n  const handleFieldBlur = useCallback(\n    (fieldKey: string) =&gt; {\n      setTouched((prev) =&gt; ({\n        ...prev,\n        [fieldKey]: true,\n      }));\n\n      // Validate immediately on blur\n      const value = formData[fieldKey];\n      validateField(fieldKey, value, true);\n    },\n    [formData, validateField]\n  );\n\n  /**\n   * Validate current step using the validation utilities\n   */\n  const validateCurrentStep = useCallback((): boolean =&gt; {\n    const stepResult = validateStep(currentStep, formData, formConfig);\n\n    if (!stepResult.isValid) {\n      // Update errors for current step fields only\n      const stepFieldKeys = getStepFieldKeys(currentStep, formConfig);\n      setErrors((prev) =&gt; {\n        const next = { ...prev };\n        // Clear errors for fields not in current step\n        stepFieldKeys.forEach((key) =&gt; {\n          if (stepResult.errors[key]) {\n            next[key] = stepResult.errors[key];\n          } else {\n            delete next[key];\n          }\n        });\n        return next;\n      });\n\n      // Mark all fields in step as touched\n      setTouched((prev) =&gt; {\n        const next = { ...prev };\n        stepFieldKeys.forEach((key) =&gt; {\n          next[key] = true;\n        });\n        return next;\n      });\n\n      // Focus first error field\n      if (stepResult.firstErrorField) {\n        // Find the field by key to get its ID\n        const errorField = currentSection.fields.find(\n          (f) =&gt; f.key === stepResult.firstErrorField\n        );\n        if (errorField) {\n          // Field components use &#96;field-${field.id}&#96; as the ID\n          const fieldElement = document.getElementById(&#96;field-${errorField.id}&#96;);\n          if (fieldElement) {\n            fieldElement.focus();\n            fieldElement.scrollIntoView({ behavior: \&quot;smooth\&quot;, block: \&quot;center\&quot; });\n          }\n        }\n      }\n    }\n\n    return stepResult.isValid;\n  }, [currentStep, formData, formConfig, currentSection]);\n\n  const handleNext = useCallback(async () =&gt; {\n    if (isSubmitting) {\n      return;\n    }\n\n    const isStepValid = validateCurrentStep();\n    if (!isStepValid) {\n      toast({\n        variant: \&quot;destructive\&quot;,\n        title: \&quot;Please fix validation errors\&quot;,\n        description: \&quot;Resolve highlighted fields before continuing.\&quot;,\n      });\n      return;\n    }\n\n    setCompletedSteps((prev) =&gt; new Set(prev).add(currentStep));\n\n    if (isLastStep) {\n      if (!onComplete) {\n        return;\n      }\n      try {\n        setIsSubmitting(true);\n        await onComplete(formData);\n        toast({\n          title: \&quot;Form submitted\&quot;,\n          description: \&quot;Thanks! We received your information.\&quot;,\n        });\n      } catch (error) {\n        toast({\n          variant: \&quot;destructive\&quot;,\n          title: \&quot;Submission failed\&quot;,\n          description:\n            error instanceof Error\n              ? error.message\n              : \&quot;Something went wrong while submitting. Please try again.\&quot;,\n        });\n      } finally {\n        setIsSubmitting(false);\n      }\n    } else {\n      const nextStep = currentStep + 1;\n      setCurrentStep(nextStep);\n      onStepChange?.(nextStep);\n    }\n  }, [\n    currentStep,\n    formData,\n    isLastStep,\n    isSubmitting,\n    onComplete,\n    onStepChange,\n    toast,\n    validateCurrentStep,\n  ]);\n\n  const handlePrevious = useCallback(() =&gt; {\n    if (!isFirstStep) {\n      const prevStep = currentStep - 1;\n      setCurrentStep(prevStep);\n      onStepChange?.(prevStep);\n    }\n  }, [currentStep, isFirstStep, onStepChange]);\n\n  const handleStepClick = useCallback(\n    (stepIndex: number) =&gt; {\n      // Validate current step before allowing navigation\n      if (stepIndex !== currentStep) {\n        if (!validateCurrentStep()) {\n          return; // Don&#39;t allow navigation if current step is invalid\n        }\n      }\n\n      // Allow navigation to completed steps or the next step\n      if (completedSteps.has(stepIndex) || stepIndex === currentStep + 1) {\n        setCurrentStep(stepIndex);\n        onStepChange?.(stepIndex);\n      }\n    },\n    [completedSteps, currentStep, onStepChange, validateCurrentStep]\n  );\n\n  const handleSaveDraft = useCallback(async () =&gt; {\n    if (!onSaveDraft || isSavingDraft) {\n      return;\n    }\n    try {\n      setIsSavingDraft(true);\n      setDraftStatus(\&quot;saving\&quot;);\n      setDraftError(null);\n      await onSaveDraft(formData);\n      setDraftStatus(\&quot;success\&quot;);\n      const savedAt = new Date();\n      setLastSavedAt(savedAt);\n      toast({\n        title: \&quot;Draft saved\&quot;,\n        description: &#96;Progress saved at ${savedAt.toLocaleTimeString([], {\n          hour: \&quot;numeric\&quot;,\n          minute: \&quot;2-digit\&quot;,\n        })}&#96;,\n      });\n    } catch (error) {\n      setDraftStatus(\&quot;error\&quot;);\n      const message =\n        error instanceof Error\n          ? error.message\n          : \&quot;Unable to save your draft right now.\&quot;;\n      setDraftError(message);\n      toast({\n        variant: \&quot;destructive\&quot;,\n        title: \&quot;Draft not saved\&quot;,\n        description: message,\n      });\n    } finally {\n      setIsSavingDraft(false);\n    }\n  }, [formData, isSavingDraft, onSaveDraft, toast]);\n\n  // Cleanup timers on unmount\n  useEffect(() =&gt; {\n    const timers = validationTimersRef.current;\n    return () =&gt; {\n      Object.values(timers).forEach((timer) =&gt; {\n        clearTimeout(timer);\n      });\n    };\n  }, []);\n\n  const progress = totalSteps &gt; 0 ? ((currentStep + 1) / totalSteps) * 100 : 0;\n\n  useEffect(() =&gt; {\n    const sectionLabel = currentSection?.label ?? &#96;Step ${currentStep + 1}&#96;;\n    setLiveMessage(&#96;Now viewing ${sectionLabel} (${currentStep + 1} of ${totalSteps})&#96;);\n  }, [currentSection, currentStep, totalSteps]);\n\n  return (\n    &lt;div className=\&quot;flex flex-col gap-6 pb-32 sm:pb-12\&quot;&gt;\n      &lt;StepIndicator\n        steps={sortedSections.map((section, index) =&gt; ({\n          id: section.id,\n          label: section.label,\n          order: section.order,\n        }))}\n        currentStep={currentStep}\n        completedSteps={completedSteps}\n        onStepClick={handleStepClick}\n      /&gt;\n\n      &lt;div\n        className={cn(\n          \&quot;min-h-[400px] space-y-6 rounded-3xl border border-border/60 bg-background/70 p-4 shadow-lg sm:p-8\&quot;,\n          !prefersReducedMotion &amp;&amp; \&quot;transition-shadow duration-300\&quot;\n        )}\n      &gt;\n        {/* Error summary for current step */}\n        {(() =&gt; {\n          const stepFieldKeys = getStepFieldKeys(currentStep, formConfig);\n          const stepErrors: Record&lt;string, string&gt; = {};\n          stepFieldKeys.forEach((key) =&gt; {\n            if (errors[key] &amp;&amp; touched[key]) {\n              stepErrors[key] = errors[key];\n            }\n          });\n\n          if (Object.keys(stepErrors).length &gt; 0) {\n            return (\n              &lt;FormErrorSummary\n                errors={stepErrors}\n                onErrorClick={(fieldKey) =&gt; {\n                  // Find the field by key to get its ID\n                  const errorField = currentSection.fields.find(\n                    (f) =&gt; f.key === fieldKey\n                  );\n                  if (errorField) {\n                    // Field components use &#96;field-${field.id}&#96; as the ID\n                    const fieldElement = document.getElementById(&#96;field-${errorField.id}&#96;);\n                    if (fieldElement) {\n                      fieldElement.focus();\n                      fieldElement.scrollIntoView({\n                        behavior: \&quot;smooth\&quot;,\n                        block: \&quot;center\&quot;,\n                      });\n                    }\n                  }\n                }}\n              /&gt;\n            );\n          }\n          return null;\n        })()}\n\n        &lt;FormStep\n          section={currentSection}\n          formData={formData}\n          errors={errors}\n          touched={touched}\n          onFieldChange={handleFieldChange}\n          onFieldBlur={handleFieldBlur}\n        /&gt;\n      &lt;/div&gt;\n\n      &lt;FormNavigation\n        isFirstStep={isFirstStep}\n        isLastStep={isLastStep}\n        onNext={handleNext}\n        onPrevious={handlePrevious}\n        onSaveDraft={handleSaveDraft}\n        progress={progress}\n        isSubmitting={isSubmitting}\n        isSavingDraft={isSavingDraft}\n        draftStatus={draftStatus}\n        draftError={draftError}\n        lastSavedAt={lastSavedAt}\n      /&gt;\n      &lt;p role=\&quot;status\&quot; aria-live=\&quot;polite\&quot; className=\&quot;sr-only\&quot;&gt;\n        {liveMessage}\n      &lt;/p&gt;\n    &lt;/div&gt;\n  );\n}\n\n&quot;
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Considering alternative patch methods**</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  &quot;relativeWorkspacePath&quot;: &quot;/Users/sahilmehta/supplier-onboarding-simple/components/forms/dynamic-form-wizard.tsx&quot;
}
```
Additional data:

```json
{
  &quot;codeblockId&quot;: &quot;c4b87c13-f594-4408-b7ff-defec49c1e5d&quot;,
  &quot;reviewData&quot;: {
    &quot;status&quot;: &quot;None&quot;,
    &quot;selectedOption&quot;: &quot;accept&quot;,
    &quot;isShowingInput&quot;: false,
    &quot;firstTimeReviewMode&quot;: false
  }
}
```
Result:

```json
{
  &quot;diff&quot;: {
    &quot;chunks&quot;: [
      {
        &quot;diffString&quot;: &quot;      validateAndCommitStep,\n    ]);\n- \n-   const handlePrevious = useCallback(() =&gt; {\n-     if (isFirstStep) {\n-       return;\n-     }\n-     const prevStep = state.currentStep - 1;\n-     goToStep(prevStep);\n-     onStepChange?.(prevStep);\n-   }, [goToStep, isFirstStep, onStepChange, state.currentStep]);\n- \n-   const handleStepClick = useCallback(\n-     (stepIndex: number) =&gt; {\n-       if (stepIndex === state.currentStep) {\n-         return;\n-       }\n- \n-       const validation = validateAndCommitStep(state.currentStep);\n-       if (!validation.isValid) {\n-         toast({\n-           variant: \&quot;destructive\&quot;,\n-           title: \&quot;Cannot leave step yet\&quot;,\n-           description: \&quot;Fix validation errors before moving on.\&quot;,\n-         });\n-         focusFirstError(validation.firstErrorField);\n-         return;\n-       }\n- \n-       if (\n-         state.completedSteps.has(stepIndex) ||\n-         stepIndex === state.currentStep + 1\n-       ) {\n-         goToStep(stepIndex);\n-         onStepChange?.(stepIndex);\n-         void triggerSave(\&quot;step-change\&quot;);\n-       }\n-     },\n-     [\n-       focusFirstError,\n-       goToStep,\n-       onStepChange,\n-       state.completedSteps,\n-       state.currentStep,\n-       toast,\n-       triggerSave,\n-       validateAndCommitStep,\n-     ]\n-   );\n- \n-   const handleManualSave = useCallback(() =&gt; {\n-     void triggerSave(\&quot;manual\&quot;);\n-   }, [triggerSave]);\n- \n-   useEffect(() =&gt; {\n-     return () =&gt; {\n-       Object.values(validationTimersRef.current).forEach((timer) =&gt; {\n-         clearTimeout(timer);\n-       });\n-     };\n-   }, []);\n- \n-   useEffect(() =&gt; {\n-     const sectionLabel = currentSection?.label ?? &#96;Step ${state.currentStep + 1}&#96;;\n-     setLiveMessage(\n-       &#96;Now viewing ${sectionLabel} (${state.currentStep + 1} of ${totalSteps})&#96;\n-     );\n-   }, [currentSection, state.currentStep, totalSteps]);\n- \n-   const progress =\n-     totalSteps &gt; 0 ? ((state.currentStep + 1) / totalSteps) * 100 : 0;\n- \n-   return (\n-     &lt;div className=\&quot;flex flex-col gap-6 pb-32 sm:pb-12\&quot;&gt;\n-       &lt;StepIndicator\n-         steps={sortedSections.map((section) =&gt; ({\n-           id: section.id,\n-           label: section.label,\n-           order: section.order,\n-         }))}\n-         currentStep={state.currentStep}\n-         completedSteps={state.completedSteps}\n-         onStepClick={handleStepClick}\n-       /&gt;\n- \n-       &lt;div\n-         className={cn(\n-           \&quot;min-h-[400px] space-y-6 rounded-3xl border border-border/60 bg-background/70 p-4 shadow-lg sm:p-8\&quot;,\n-           !prefersReducedMotion &amp;&amp; \&quot;transition-shadow duration-300\&quot;\n-         )}\n-       &gt;\n-         {(() =&gt; {\n-           const stepFieldKeys = getStepFieldKeys(state.currentStep, formConfig);\n-           const stepErrors: Record&lt;string, string&gt; = {};\n-           stepFieldKeys.forEach((key) =&gt; {\n-             if (state.errors[key] &amp;&amp; touchedMap[key]) {\n-               stepErrors[key] = state.errors[key];\n-             }\n-           });\n- \n-           if (Object.keys(stepErrors).length &gt; 0) {\n-             return (\n-               &lt;FormErrorSummary\n-                 errors={stepErrors}\n-                 onErrorClick={(fieldKey) =&gt; focusFirstError(fieldKey)}\n-               /&gt;\n-             );\n-           }\n-           return null;\n-         })()}\n- \n-         {currentSection &amp;&amp; (\n-           &lt;FormStep\n-             section={currentSection}\n-             formData={state.formData}\n-             errors={state.errors}\n-             touched={touchedMap}\n-             onFieldChange={handleFieldChange}\n-             onFieldBlur={handleFieldBlur}\n-           /&gt;\n-         )}\n-       &lt;/div&gt;\n- \n-       &lt;FormNavigation\n-         isFirstStep={isFirstStep}\n-         isLastStep={isLastStep}\n-         onNext={handleNext}\n-         onPrevious={handlePrevious}\n-         onSaveDraft={handleManualSave}\n-         progress={progress}\n-         isSubmitting={state.isSubmitting}\n-         isSavingDraft={isSavingDraft}\n-         draftStatus={draftStatus}\n-         draftError={draftError}\n-         lastSavedAt={lastSavedAt}\n-       /&gt;\n-       &lt;p role=\&quot;status\&quot; aria-live=\&quot;polite\&quot; className=\&quot;sr-only\&quot;&gt;\n-         {liveMessage}\n-       &lt;/p&gt;\n-     &lt;/div&gt;\n-   );\n- }\n- \&quot;use client\&quot;;\n- \n- import { useCallback, useEffect, useMemo, useRef, useState } from \&quot;react\&quot;;\n- import type { FormConfigWithFields } from \&quot;@/lib/forms/types\&quot;;\n- import { getStepFieldKeys } from \&quot;@/lib/forms/form-validator\&quot;;\n- import { buildFormSchema } from \&quot;@/lib/form-schema\&quot;;\n- import { saveFormDraft, type DraftSaveResult } from \&quot;@/app/forms/actions\&quot;;\n- import { StepIndicator } from \&quot;./step-indicator\&quot;;\n- import { FormStep } from \&quot;./form-step\&quot;;\n- import { FormNavigation } from \&quot;./form-navigation\&quot;;\n- import { FormErrorSummary } from \&quot;./form-error-summary\&quot;;\n- import { useFormState } from \&quot;@/hooks/use-form-state\&quot;;\n- import { useAutosave } from \&quot;@/hooks/use-autosave\&quot;;\n- import { useToast } from \&quot;@/components/ui/use-toast\&quot;;\n- import { usePrefersReducedMotion } from \&quot;@/hooks/use-prefers-reduced-motion\&quot;;\n- import { cn } from \&quot;@/lib/utils\&quot;;\n- \n- interface DynamicFormWizardProps {\n-   formConfig: FormConfigWithFields;\n-   initialData?: Record&lt;string, unknown&gt;;\n-   initialStep?: number;\n-   applicationId: string | null;\n-   organizationId: string;\n-   onApplicationIdChange?: (applicationId: string) =&gt; void;\n-   onDraftSaved?: (result: DraftSaveResult) =&gt; void;\n-   onStepChange?: (stepIndex: number) =&gt; void;\n-   onComplete?: (formData: Record&lt;string, unknown&gt;) =&gt; Promise&lt;void&gt; | void;\n- }\n- \n- export function DynamicFormWizard({\n-   formConfig,\n-   initialData = {},\n-   initialStep = 0,\n-   applicationId,\n-   organizationId,\n-   onApplicationIdChange,\n-   onDraftSaved,\n-   onStepChange,\n-   onComplete,\n- }: DynamicFormWizardProps) {\n-   const sortedSections = useMemo(\n-     () =&gt; [...formConfig.sections].sort((a, b) =&gt; a.order - b.order),\n-     [formConfig.sections]\n-   );\n- \n-   const {\n-     state,\n-     touchedMap,\n-     setFieldValue,\n-     markFieldTouched,\n-     markFieldsTouched,\n-     setFieldError,\n-     setStepErrors,\n-     goToStep,\n-     markStepComplete,\n-     setIsSubmitting,\n-     markClean,\n-     validateAndCommitStep,\n-   } = useFormState({\n-     formConfig,\n-     initialData,\n-     initialStep,\n-   });\n- \n-   const [liveMessage, setLiveMessage] = useState(\&quot;\&quot;);\n-   const validationTimersRef = useRef&lt;Record&lt;string, NodeJS.Timeout&gt;&gt;({});\n-   const formSchemaRef = useRef(buildFormSchema(formConfig));\n-   const prefersReducedMotion = usePrefersReducedMotion();\n-   const { toast } = useToast();\n- \n-   const totalSteps = sortedSections.length;\n-   const currentSection = sortedSections[state.currentStep];\n-   const isFirstStep = state.currentStep === 0;\n-   const isLastStep = state.currentStep === totalSteps - 1;\n- \n-   useEffect(() =&gt; {\n-     formSchemaRef.current = buildFormSchema(formConfig);\n-   }, [formConfig]);\n- \n-   const focusFirstError = useCallback(\n-     (fieldKey?: string) =&gt; {\n-       if (!fieldKey || !currentSection) {\n-         return;\n-       }\n-       const errorField = currentSection.fields.find((field) =&gt; field.key === fieldKey);\n-       const fieldElement = errorField\n-         ? document.getElementById(&#96;field-${errorField.id}&#96;)\n-         : null;\n-       fieldElement?.focus();\n-       fieldElement?.scrollIntoView({ behavior: \&quot;smooth\&quot;, block: \&quot;center\&quot; });\n-     },\n-     [currentSection]\n-   );\n- \n-   const validateField = useCallback(\n-     (fieldKey: string, value: unknown, immediate = false) =&gt; {\n-       if (validationTimersRef.current[fieldKey]) {\n-         clearTimeout(validationTimersRef.current[fieldKey]);\n-       }\n- \n-       const performValidation = () =&gt; {\n-         const fieldSchema = formSchemaRef.current.shape[fieldKey];\n-         if (!fieldSchema) {\n-           return;\n-         }\n- \n-         try {\n-           fieldSchema.parse(value);\n-           setFieldError(fieldKey);\n-         } catch (error) {\n-           if (error &amp;&amp; typeof error === \&quot;object\&quot; &amp;&amp; \&quot;issues\&quot; in error) {\n-             const zodError = error as { issues: Array&lt;{ message: string }&gt; };\n-             const firstIssue = zodError.issues[0];\n-             if (firstIssue) {\n-               setFieldError(fieldKey, firstIssue.message);\n-             }\n-           } else if (error instanceof Error) {\n-             setFieldError(fieldKey, error.message);\n-           }\n-         }\n-       };\n- \n-       if (immediate) {\n-         performValidation();\n-       } else {\n-         validationTimersRef.current[fieldKey] = setTimeout(performValidation, 300);\n-       }\n-     },\n-     [setFieldError]\n-   );\n- \n-   const handleFieldChange = useCallback(\n-     (fieldKey: string, value: unknown) =&gt; {\n-       setFieldValue(fieldKey, value);\n-       if (state.touched.has(fieldKey)) {\n-         validateField(fieldKey, value, false);\n-       }\n-     },\n-     [setFieldValue, state.touched, validateField]\n-   );\n- \n-   const handleFieldBlur = useCallback(\n-     (fieldKey: string) =&gt; {\n-       markFieldTouched(fieldKey);\n-       validateField(fieldKey, state.formData[fieldKey], true);\n-     },\n-     [markFieldTouched, state.formData, validateField]\n-   );\n- \n-   const autosaveFingerprint = useMemo(\n-     () =&gt; JSON.stringify({ data: state.formData, step: state.currentStep }),\n-     [state.formData, state.currentStep]\n-   );\n- \n-   const runDraftSave = useCallback(() =&gt; {\n-     return saveFormDraft({\n-       formConfigId: formConfig.id,\n-       organizationId,\n-       entityId: formConfig.entityId,\n-       geographyId: formConfig.geographyId,\n-       applicationId,\n-       formData: state.formData,\n-       currentStep: state.currentStep,\n-     });\n-   }, [\n-     applicationId,\n-     formConfig.entityId,\n-     formConfig.geographyId,\n-     formConfig.id,\n-     organizationId,\n-     state.currentStep,\n-     state.formData,\n-   ]);\n- \n-   const {\n-     status: draftStatus,\n-     isSaving: isSavingDraft,\n-     lastSavedAt,\n-     error: draftError,\n-     triggerSave,\n-   } = useAutosave&lt;DraftSaveResult&gt;({\n-     shouldAutosave: state.isDirty,\n-     dataFingerprint: autosaveFingerprint,\n-     save: runDraftSave,\n-     onSuccess: (result) =&gt; {\n-       markClean();\n-       if (result.applicationId &amp;&amp; result.applicationId !== applicationId) {\n-         onApplicationIdChange?.(result.applicationId);\n-       }\n-       onDraftSaved?.(result);\n-     },\n-     onError: (error) =&gt; {\n-       toast({\n-         variant: \&quot;destructive\&quot;,\n-         title: \&quot;Draft save failed\&quot;,\n-         description: error.message,\n-       });\n-     },\n-   });\n- \n-   const handleNext = useCallback(async () =&gt; {\n-     if (state.isSubmitting) {\n-       return;\n-     }\n- \n-     const validation = validateAndCommitStep(state.currentStep);\n-     if (!validation.isValid) {\n-       toast({\n-         variant: \&quot;destructive\&quot;,\n-         title: \&quot;Please fix validation errors\&quot;,\n-         description: \&quot;Resolve highlighted fields before continuing.\&quot;,\n-       });\n-       focusFirstError(validation.firstErrorField);\n-       return;\n-     }\n- \n-     markStepComplete(state.currentStep);\n- \n-     if (isLastStep &amp;&amp; onComplete) {\n-       try {\n-         setIsSubmitting(true);\n-         await onComplete(state.formData);\n-         toast({\n-           title: \&quot;Form submitted\&quot;,\n-           description: \&quot;Thank you! We received your information.\&quot;,\n-         });\n-       } catch (error) {\n-         toast({\n-           variant: \&quot;destructive\&quot;,\n-           title: \&quot;Submission failed\&quot;,\n-           description:\n-             error instanceof Error\n-               ? error.message\n-               : \&quot;Something went wrong while submitting. Please try again.\&quot;,\n-         });\n-       } finally {\n-         setIsSubmitting(false);\n-       }\n-       return;\n-     }\n- \n-     const nextStep = state.currentStep + 1;\n-     goToStep(nextStep);\n-     onStepChange?.(nextStep);\n-     void triggerSave(\&quot;step-change\&quot;);\n-   }, [\n-     focusFirstError,\n-     goToStep,\n-     isLastStep,\n-     markStepComplete,\n-     onComplete,\n-     onStepChange,\n-     setIsSubmitting,\n-     state.currentStep,\n-     state.formData,\n-     state.isSubmitting,\n-     toast,\n-     triggerSave,\n-     validateAndCommitStep,\n-   ]);\n  \n    const handlePrevious = useCallback(() =&gt; {&quot;,
        &quot;oldStart&quot;: 659,
        &quot;newStart&quot;: 659,
        &quot;oldLines&quot;: 404,
        &quot;newLines&quot;: 4,
        &quot;linesRemoved&quot;: 400
      }
    ],
    &quot;editor&quot;: &quot;EDITOR_AI&quot;
  },
  &quot;shouldAutoFixLints&quot;: true,
  &quot;resultForModel&quot;: &quot;Success. Updated the following files:\nM /Users/sahilmehta/supplier-onboarding-simple/components/forms/dynamic-form-wizard.tsx&quot;,
  &quot;contentsAfterEdit&quot;: &quot;\&quot;use client\&quot;;\n\nimport { useCallback, useEffect, useMemo, useRef, useState } from \&quot;react\&quot;;\nimport type { FormConfigWithFields } from \&quot;@/lib/forms/types\&quot;;\nimport { getStepFieldKeys } from \&quot;@/lib/forms/form-validator\&quot;;\nimport { buildFormSchema } from \&quot;@/lib/form-schema\&quot;;\nimport { saveFormDraft, type DraftSaveResult } from \&quot;@/app/forms/actions\&quot;;\nimport { StepIndicator } from \&quot;./step-indicator\&quot;;\nimport { FormStep } from \&quot;./form-step\&quot;;\nimport { FormNavigation } from \&quot;./form-navigation\&quot;;\nimport { FormErrorSummary } from \&quot;./form-error-summary\&quot;;\nimport { useFormState } from \&quot;@/hooks/use-form-state\&quot;;\nimport { useAutosave } from \&quot;@/hooks/use-autosave\&quot;;\nimport { useToast } from \&quot;@/components/ui/use-toast\&quot;;\nimport { usePrefersReducedMotion } from \&quot;@/hooks/use-prefers-reduced-motion\&quot;;\nimport { cn } from \&quot;@/lib/utils\&quot;;\n\ninterface DynamicFormWizardProps {\n  formConfig: FormConfigWithFields;\n  initialData?: Record&lt;string, unknown&gt;;\n  initialStep?: number;\n  applicationId: string | null;\n  organizationId: string;\n  onApplicationIdChange?: (applicationId: string) =&gt; void;\n  onDraftSaved?: (result: DraftSaveResult) =&gt; void;\n  onStepChange?: (stepIndex: number) =&gt; void;\n  onComplete?: (formData: Record&lt;string, unknown&gt;) =&gt; Promise&lt;void&gt; | void;\n}\n\nexport function DynamicFormWizard({\n  formConfig,\n  initialData = {},\n  initialStep = 0,\n  applicationId,\n  organizationId,\n  onApplicationIdChange,\n  onDraftSaved,\n  onStepChange,\n  onComplete,\n}: DynamicFormWizardProps) {\n  const sortedSections = useMemo(\n    () =&gt; [...formConfig.sections].sort((a, b) =&gt; a.order - b.order),\n    [formConfig.sections]\n  );\n\n  const {\n    state,\n    touchedMap,\n    setFieldValue,\n    markFieldTouched,\n    markFieldsTouched,\n    setFieldError,\n    setStepErrors,\n    goToStep,\n    markStepComplete,\n    setIsSubmitting,\n    markClean,\n    validateAndCommitStep,\n  } = useFormState({\n    formConfig,\n    initialData,\n    initialStep,\n  });\n\n  const [liveMessage, setLiveMessage] = useState(\&quot;\&quot;);\n  const validationTimersRef = useRef&lt;Record&lt;string, NodeJS.Timeout&gt;&gt;({});\n  const formSchemaRef = useRef(buildFormSchema(formConfig));\n  const prefersReducedMotion = usePrefersReducedMotion();\n  const { toast } = useToast();\n\n  const totalSteps = sortedSections.length;\n  const currentSection = sortedSections[state.currentStep];\n  const isFirstStep = state.currentStep === 0;\n  const isLastStep = state.currentStep === totalSteps - 1;\n\n  useEffect(() =&gt; {\n    formSchemaRef.current = buildFormSchema(formConfig);\n  }, [formConfig]);\n\n  const focusFirstError = useCallback(\n    (fieldKey?: string) =&gt; {\n      if (!fieldKey || !currentSection) {\n        return;\n      }\n      const errorField = currentSection.fields.find((field) =&gt; field.key === fieldKey);\n      const fieldElement = errorField\n        ? document.getElementById(&#96;field-${errorField.id}&#96;)\n        : null;\n      fieldElement?.focus();\n      fieldElement?.scrollIntoView({ behavior: \&quot;smooth\&quot;, block: \&quot;center\&quot; });\n    },\n    [currentSection]\n  );\n\n  const validateField = useCallback(\n    (fieldKey: string, value: unknown, immediate = false) =&gt; {\n      if (validationTimersRef.current[fieldKey]) {\n        clearTimeout(validationTimersRef.current[fieldKey]);\n      }\n\n      const performValidation = () =&gt; {\n        const fieldSchema = formSchemaRef.current.shape[fieldKey];\n        if (!fieldSchema) {\n          return;\n        }\n\n        try {\n          fieldSchema.parse(value);\n          setFieldError(fieldKey);\n        } catch (error) {\n          if (error &amp;&amp; typeof error === \&quot;object\&quot; &amp;&amp; \&quot;issues\&quot; in error) {\n            const zodError = error as { issues: Array&lt;{ message: string }&gt; };\n            const firstIssue = zodError.issues[0];\n            if (firstIssue) {\n              setFieldError(fieldKey, firstIssue.message);\n            }\n          } else if (error instanceof Error) {\n            setFieldError(fieldKey, error.message);\n          }\n        }\n      };\n\n      if (immediate) {\n        performValidation();\n      } else {\n        validationTimersRef.current[fieldKey] = setTimeout(performValidation, 300);\n      }\n    },\n    [setFieldError]\n  );\n\n  const handleFieldChange = useCallback(\n    (fieldKey: string, value: unknown) =&gt; {\n      setFieldValue(fieldKey, value);\n      if (state.touched.has(fieldKey)) {\n        validateField(fieldKey, value, false);\n      }\n    },\n    [setFieldValue, state.touched, validateField]\n  );\n\n  const handleFieldBlur = useCallback(\n    (fieldKey: string) =&gt; {\n      markFieldTouched(fieldKey);\n      validateField(fieldKey, state.formData[fieldKey], true);\n    },\n    [markFieldTouched, state.formData, validateField]\n  );\n\n  const autosaveFingerprint = useMemo(\n    () =&gt; JSON.stringify({ data: state.formData, step: state.currentStep }),\n    [state.formData, state.currentStep]\n  );\n\n  const runDraftSave = useCallback(() =&gt; {\n    return saveFormDraft({\n      formConfigId: formConfig.id,\n      organizationId,\n      entityId: formConfig.entityId,\n      geographyId: formConfig.geographyId,\n      applicationId,\n      formData: state.formData,\n      currentStep: state.currentStep,\n    });\n  }, [\n    applicationId,\n    formConfig.entityId,\n    formConfig.geographyId,\n    formConfig.id,\n    organizationId,\n    state.currentStep,\n    state.formData,\n  ]);\n\n  const {\n    status: draftStatus,\n    isSaving: isSavingDraft,\n    lastSavedAt,\n    error: draftError,\n    triggerSave,\n  } = useAutosave&lt;DraftSaveResult&gt;({\n    shouldAutosave: state.isDirty,\n    dataFingerprint: autosaveFingerprint,\n    save: runDraftSave,\n    onSuccess: (result) =&gt; {\n      markClean();\n      if (result.applicationId &amp;&amp; result.applicationId !== applicationId) {\n        onApplicationIdChange?.(result.applicationId);\n      }\n      onDraftSaved?.(result);\n    },\n    onError: (error) =&gt; {\n      toast({\n        variant: \&quot;destructive\&quot;,\n        title: \&quot;Draft save failed\&quot;,\n        description: error.message,\n      });\n    },\n  });\n\n  const handleNext = useCallback(async () =&gt; {\n    if (state.isSubmitting) {\n      return;\n    }\n\n    const validation = validateAndCommitStep(state.currentStep);\n    if (!validation.isValid) {\n      toast({\n        variant: \&quot;destructive\&quot;,\n        title: \&quot;Please fix validation errors\&quot;,\n        description: \&quot;Resolve highlighted fields before continuing.\&quot;,\n      });\n      focusFirstError(validation.firstErrorField);\n      return;\n    }\n\n    markStepComplete(state.currentStep);\n\n    if (isLastStep &amp;&amp; onComplete) {\n      try {\n        setIsSubmitting(true);\n        await onComplete(state.formData);\n        toast({\n          title: \&quot;Form submitted\&quot;,\n          description: \&quot;Thank you! We received your information.\&quot;,\n        });\n      } catch (error) {\n        toast({\n          variant: \&quot;destructive\&quot;,\n          title: \&quot;Submission failed\&quot;,\n          description:\n            error instanceof Error\n              ? error.message\n              : \&quot;Something went wrong while submitting. Please try again.\&quot;,\n        });\n      } finally {\n        setIsSubmitting(false);\n      }\n      return;\n    }\n\n    const nextStep = state.currentStep + 1;\n    goToStep(nextStep);\n    onStepChange?.(nextStep);\n    void triggerSave(\&quot;step-change\&quot;);\n  }, [\n    focusFirstError,\n    goToStep,\n    isLastStep,\n    markStepComplete,\n    onComplete,\n    onStepChange,\n    setIsSubmitting,\n    state.currentStep,\n    state.formData,\n    state.isSubmitting,\n    toast,\n    triggerSave,\n    validateAndCommitStep,\n  ]);\n\n  const handlePrevious = useCallback(() =&gt; {\n    if (isFirstStep) {\n      return;\n    }\n    const prevStep = state.currentStep - 1;\n    goToStep(prevStep);\n    onStepChange?.(prevStep);\n  }, [goToStep, isFirstStep, onStepChange, state.currentStep]);\n\n  const handleStepClick = useCallback(\n    (stepIndex: number) =&gt; {\n      if (stepIndex === state.currentStep) {\n        return;\n      }\n\n      const validation = validateAndCommitStep(state.currentStep);\n      if (!validation.isValid) {\n        toast({\n          variant: \&quot;destructive\&quot;,\n          title: \&quot;Cannot leave step yet\&quot;,\n          description: \&quot;Fix validation errors before moving on.\&quot;,\n        });\n        focusFirstError(validation.firstErrorField);\n        return;\n      }\n\n      if (\n        state.completedSteps.has(stepIndex) ||\n        stepIndex === state.currentStep + 1\n      ) {\n        goToStep(stepIndex);\n        onStepChange?.(stepIndex);\n        void triggerSave(\&quot;step-change\&quot;);\n      }\n    },\n    [\n      focusFirstError,\n      goToStep,\n      onStepChange,\n      state.completedSteps,\n      state.currentStep,\n      toast,\n      triggerSave,\n      validateAndCommitStep,\n    ]\n  );\n\n  const handleManualSave = useCallback(() =&gt; {\n    void triggerSave(\&quot;manual\&quot;);\n  }, [triggerSave]);\n\n  useEffect(() =&gt; {\n    return () =&gt; {\n      Object.values(validationTimersRef.current).forEach((timer) =&gt; {\n        clearTimeout(timer);\n      });\n    };\n  }, []);\n\n  useEffect(() =&gt; {\n    const sectionLabel = currentSection?.label ?? &#96;Step ${state.currentStep + 1}&#96;;\n    setLiveMessage(\n      &#96;Now viewing ${sectionLabel} (${state.currentStep + 1} of ${totalSteps})&#96;\n    );\n  }, [currentSection, state.currentStep, totalSteps]);\n\n  const progress =\n    totalSteps &gt; 0 ? ((state.currentStep + 1) / totalSteps) * 100 : 0;\n\n  return (\n    &lt;div className=\&quot;flex flex-col gap-6 pb-32 sm:pb-12\&quot;&gt;\n      &lt;StepIndicator\n        steps={sortedSections.map((section) =&gt; ({\n          id: section.id,\n          label: section.label,\n          order: section.order,\n        }))}\n        currentStep={state.currentStep}\n        completedSteps={state.completedSteps}\n        onStepClick={handleStepClick}\n      /&gt;\n\n      &lt;div\n        className={cn(\n          \&quot;min-h-[400px] space-y-6 rounded-3xl border border-border/60 bg-background/70 p-4 shadow-lg sm:p-8\&quot;,\n          !prefersReducedMotion &amp;&amp; \&quot;transition-shadow duration-300\&quot;\n        )}\n      &gt;\n        {(() =&gt; {\n          const stepFieldKeys = getStepFieldKeys(state.currentStep, formConfig);\n          const stepErrors: Record&lt;string, string&gt; = {};\n          stepFieldKeys.forEach((key) =&gt; {\n            if (state.errors[key] &amp;&amp; touchedMap[key]) {\n              stepErrors[key] = state.errors[key];\n            }\n          });\n\n          if (Object.keys(stepErrors).length &gt; 0) {\n            return (\n              &lt;FormErrorSummary\n                errors={stepErrors}\n                onErrorClick={(fieldKey) =&gt; focusFirstError(fieldKey)}\n              /&gt;\n            );\n          }\n          return null;\n        })()}\n\n        {currentSection &amp;&amp; (\n          &lt;FormStep\n            section={currentSection}\n            formData={state.formData}\n            errors={state.errors}\n            touched={touchedMap}\n            onFieldChange={handleFieldChange}\n            onFieldBlur={handleFieldBlur}\n          /&gt;\n        )}\n      &lt;/div&gt;\n\n      &lt;FormNavigation\n        isFirstStep={isFirstStep}\n        isLastStep={isLastStep}\n        onNext={handleNext}\n        onPrevious={handlePrevious}\n        onSaveDraft={handleManualSave}\n        progress={progress}\n        isSubmitting={state.isSubmitting}\n        isSavingDraft={isSavingDraft}\n        draftStatus={draftStatus}\n        draftError={draftError}\n        lastSavedAt={lastSavedAt}\n      /&gt;\n      &lt;p role=\&quot;status\&quot; aria-live=\&quot;polite\&quot; className=\&quot;sr-only\&quot;&gt;\n        {liveMessage}\n      &lt;/p&gt;\n    &lt;/div&gt;\n  );\n}\n\&quot;use client\&quot;;\n\nimport { useCallback, useEffect, useMemo, useRef, useState } from \&quot;react\&quot;;\nimport type { FormConfigWithFields } from \&quot;@/lib/forms/types\&quot;;\nimport { getStepFieldKeys } from \&quot;@/lib/forms/form-validator\&quot;;\nimport { buildFormSchema } from \&quot;@/lib/form-schema\&quot;;\nimport { saveFormDraft, type DraftSaveResult } from \&quot;@/app/forms/actions\&quot;;\nimport { StepIndicator } from \&quot;./step-indicator\&quot;;\nimport { FormStep } from \&quot;./form-step\&quot;;\nimport { FormNavigation } from \&quot;./form-navigation\&quot;;\nimport { FormErrorSummary } from \&quot;./form-error-summary\&quot;;\nimport { useFormState } from \&quot;@/hooks/use-form-state\&quot;;\nimport { useAutosave } from \&quot;@/hooks/use-autosave\&quot;;\nimport { useToast } from \&quot;@/components/ui/use-toast\&quot;;\nimport { usePrefersReducedMotion } from \&quot;@/hooks/use-prefers-reduced-motion\&quot;;\nimport { cn } from \&quot;@/lib/utils\&quot;;\n\ninterface DynamicFormWizardProps {\n  formConfig: FormConfigWithFields;\n  initialData?: Record&lt;string, unknown&gt;;\n  initialStep?: number;\n  applicationId: string | null;\n  organizationId: string;\n  onApplicationIdChange?: (applicationId: string) =&gt; void;\n  onDraftSaved?: (result: DraftSaveResult) =&gt; void;\n  onStepChange?: (stepIndex: number) =&gt; void;\n  onComplete?: (formData: Record&lt;string, unknown&gt;) =&gt; Promise&lt;void&gt; | void;\n}\n\nexport function DynamicFormWizard({\n  formConfig,\n  initialData = {},\n  initialStep = 0,\n  applicationId,\n  organizationId,\n  onApplicationIdChange,\n  onDraftSaved,\n  onStepChange,\n  onComplete,\n}: DynamicFormWizardProps) {\n  const sortedSections = useMemo(\n    () =&gt; [...formConfig.sections].sort((a, b) =&gt; a.order - b.order),\n    [formConfig.sections]\n  );\n\n  const {\n    state,\n    touchedMap,\n    setFieldValue,\n    markFieldTouched,\n    markFieldsTouched,\n    setFieldError,\n    setStepErrors,\n    goToStep,\n    markStepComplete,\n    setIsSubmitting,\n    markClean,\n    validateAndCommitStep,\n  } = useFormState({\n    formConfig,\n    initialData,\n    initialStep,\n  });\n\n  const [liveMessage, setLiveMessage] = useState(\&quot;\&quot;);\n  const validationTimersRef = useRef&lt;Record&lt;string, NodeJS.Timeout&gt;&gt;({});\n  const formSchemaRef = useRef(buildFormSchema(formConfig));\n  const prefersReducedMotion = usePrefersReducedMotion();\n  const { toast } = useToast();\n\n  const totalSteps = sortedSections.length;\n  const currentSection = sortedSections[state.currentStep];\n  const isFirstStep = state.currentStep === 0;\n  const isLastStep = state.currentStep === totalSteps - 1;\n\n  useEffect(() =&gt; {\n    formSchemaRef.current = buildFormSchema(formConfig);\n  }, [formConfig]);\n\n  const focusFirstError = useCallback(\n    (fieldKey?: string) =&gt; {\n      if (!fieldKey || !currentSection) {\n        return;\n      }\n      const errorField = currentSection.fields.find((field) =&gt; field.key === fieldKey);\n      const fieldElement = errorField\n        ? document.getElementById(&#96;field-${errorField.id}&#96;)\n        : null;\n      fieldElement?.focus();\n      fieldElement?.scrollIntoView({ behavior: \&quot;smooth\&quot;, block: \&quot;center\&quot; });\n    },\n    [currentSection]\n  );\n\n  const validateField = useCallback(\n    (fieldKey: string, value: unknown, immediate = false) =&gt; {\n      if (validationTimersRef.current[fieldKey]) {\n        clearTimeout(validationTimersRef.current[fieldKey]);\n      }\n\n      const performValidation = () =&gt; {\n        const fieldSchema = formSchemaRef.current.shape[fieldKey];\n        if (!fieldSchema) {\n          return;\n        }\n\n        try {\n          fieldSchema.parse(value);\n          setFieldError(fieldKey);\n        } catch (error) {\n          if (error &amp;&amp; typeof error === \&quot;object\&quot; &amp;&amp; \&quot;issues\&quot; in error) {\n            const zodError = error as { issues: Array&lt;{ message: string }&gt; };\n            const firstIssue = zodError.issues[0];\n            if (firstIssue) {\n              setFieldError(fieldKey, firstIssue.message);\n            }\n          } else if (error instanceof Error) {\n            setFieldError(fieldKey, error.message);\n          }\n        }\n      };\n\n      if (immediate) {\n        performValidation();\n      } else {\n        validationTimersRef.current[fieldKey] = setTimeout(performValidation, 300);\n      }\n    },\n    [setFieldError]\n  );\n\n  const handleFieldChange = useCallback(\n    (fieldKey: string, value: unknown) =&gt; {\n      setFieldValue(fieldKey, value);\n      if (state.touched.has(fieldKey)) {\n        validateField(fieldKey, value, false);\n      }\n    },\n    [setFieldValue, state.touched, validateField]\n  );\n\n  const handleFieldBlur = useCallback(\n    (fieldKey: string) =&gt; {\n      markFieldTouched(fieldKey);\n      validateField(fieldKey, state.formData[fieldKey], true);\n    },\n    [markFieldTouched, state.formData, validateField]\n  );\n\n  const autosaveFingerprint = useMemo(\n    () =&gt; JSON.stringify({ data: state.formData, step: state.currentStep }),\n    [state.formData, state.currentStep]\n  );\n\n  const runDraftSave = useCallback(() =&gt; {\n    return saveFormDraft({\n      formConfigId: formConfig.id,\n      organizationId,\n      entityId: formConfig.entityId,\n      geographyId: formConfig.geographyId,\n      applicationId,\n      formData: state.formData,\n      currentStep: state.currentStep,\n    });\n  }, [\n    applicationId,\n    formConfig.entityId,\n    formConfig.geographyId,\n    formConfig.id,\n    organizationId,\n    state.currentStep,\n    state.formData,\n  ]);\n\n  const {\n    status: draftStatus,\n    isSaving: isSavingDraft,\n    lastSavedAt,\n    error: draftError,\n    triggerSave,\n  } = useAutosave&lt;DraftSaveResult&gt;({\n    shouldAutosave: state.isDirty,\n    dataFingerprint: autosaveFingerprint,\n    save: runDraftSave,\n    onSuccess: (result) =&gt; {\n      markClean();\n      if (result.applicationId &amp;&amp; result.applicationId !== applicationId) {\n        onApplicationIdChange?.(result.applicationId);\n      }\n      onDraftSaved?.(result);\n    },\n    onError: (error) =&gt; {\n      toast({\n        variant: \&quot;destructive\&quot;,\n        title: \&quot;Draft save failed\&quot;,\n        description: error.message,\n      });\n    },\n  });\n\n  const handleNext = useCallback(async () =&gt; {\n    if (state.isSubmitting) {\n      return;\n    }\n\n    const validation = validateAndCommitStep(state.currentStep);\n    if (!validation.isValid) {\n      toast({\n        variant: \&quot;destructive\&quot;,\n        title: \&quot;Please fix validation errors\&quot;,\n        description: \&quot;Resolve highlighted fields before continuing.\&quot;,\n      });\n      focusFirstError(validation.firstErrorField);\n      return;\n    }\n\n    markStepComplete(state.currentStep);\n\n    if (isLastStep &amp;&amp; onComplete) {\n      try {\n        setIsSubmitting(true);\n        await onComplete(state.formData);\n        toast({\n          title: \&quot;Form submitted\&quot;,\n          description: \&quot;Thank you! We received your information.\&quot;,\n        });\n      } catch (error) {\n        toast({\n          variant: \&quot;destructive\&quot;,\n          title: \&quot;Submission failed\&quot;,\n          description:\n            error instanceof Error\n              ? error.message\n              : \&quot;Something went wrong while submitting. Please try again.\&quot;,\n        });\n      } finally {\n        setIsSubmitting(false);\n      }\n      return;\n    }\n\n    const nextStep = state.currentStep + 1;\n    goToStep(nextStep);\n    onStepChange?.(nextStep);\n    void triggerSave(\&quot;step-change\&quot;);\n  }, [\n    focusFirstError,\n    goToStep,\n    isLastStep,\n    markStepComplete,\n    onComplete,\n    onStepChange,\n    setIsSubmitting,\n    state.currentStep,\n    state.formData,\n    state.isSubmitting,\n    toast,\n    triggerSave,\n    validateAndCommitStep,\n  ]);\n\n  const handlePrevious = useCallback(() =&gt; {\n    if (isFirstStep) {\n      return;\n    }\n    const prevStep = state.currentStep - 1;\n    goToStep(prevStep);\n    onStepChange?.(prevStep);\n  }, [goToStep, isFirstStep, onStepChange, state.currentStep]);\n\n  const handleStepClick = useCallback(\n    (stepIndex: number) =&gt; {\n      if (stepIndex === state.currentStep) {\n        return;\n      }\n\n      const validation = validateAndCommitStep(state.currentStep);\n      if (!validation.isValid) {\n        toast({\n          variant: \&quot;destructive\&quot;,\n          title: \&quot;Cannot leave step yet\&quot;,\n          description: \&quot;Fix validation errors before moving on.\&quot;,\n        });\n        focusFirstError(validation.firstErrorField);\n        return;\n      }\n\n      if (\n        state.completedSteps.has(stepIndex) ||\n        stepIndex === state.currentStep + 1\n      ) {\n        goToStep(stepIndex);\n        onStepChange?.(stepIndex);\n        void triggerSave(\&quot;step-change\&quot;);\n      }\n    },\n    [\n      focusFirstError,\n      goToStep,\n      onStepChange,\n      state.completedSteps,\n      state.currentStep,\n      toast,\n      triggerSave,\n      validateAndCommitStep,\n    ]\n  );\n\n  const handleManualSave = useCallback(() =&gt; {\n    void triggerSave(\&quot;manual\&quot;);\n  }, [triggerSave]);\n\n  useEffect(() =&gt; {\n    const timers = validationTimersRef.current;\n    return () =&gt; {\n      Object.values(timers).forEach((timer) =&gt; {\n        clearTimeout(timer);\n      });\n    };\n  }, []);\n\n  useEffect(() =&gt; {\n    const sectionLabel = currentSection?.label ?? &#96;Step ${state.currentStep + 1}&#96;;\n    setLiveMessage(\n      &#96;Now viewing ${sectionLabel} (${state.currentStep + 1} of ${totalSteps})&#96;\n    );\n  }, [currentSection, state.currentStep, totalSteps]);\n\n  const progress =\n    totalSteps &gt; 0 ? ((state.currentStep + 1) / totalSteps) * 100 : 0;\n\n  return (\n    &lt;div className=\&quot;flex flex-col gap-6 pb-32 sm:pb-12\&quot;&gt;\n      &lt;StepIndicator\n        steps={sortedSections.map((section) =&gt; ({\n          id: section.id,\n          label: section.label,\n          order: section.order,\n        }))}\n        currentStep={state.currentStep}\n        completedSteps={state.completedSteps}\n        onStepClick={handleStepClick}\n      /&gt;\n\n      &lt;div\n        className={cn(\n          \&quot;min-h-[400px] space-y-6 rounded-3xl border border-border/60 bg-background/70 p-4 shadow-lg sm:p-8\&quot;,\n          !prefersReducedMotion &amp;&amp; \&quot;transition-shadow duration-300\&quot;\n        )}\n      &gt;\n        {(() =&gt; {\n          const stepFieldKeys = getStepFieldKeys(state.currentStep, formConfig);\n          const stepErrors: Record&lt;string, string&gt; = {};\n          stepFieldKeys.forEach((key) =&gt; {\n            if (state.errors[key] &amp;&amp; touchedMap[key]) {\n              stepErrors[key] = state.errors[key];\n            }\n          });\n\n          if (Object.keys(stepErrors).length &gt; 0) {\n            return (\n              &lt;FormErrorSummary\n                errors={stepErrors}\n                onErrorClick={(fieldKey) =&gt; focusFirstError(fieldKey)}\n              /&gt;\n            );\n          }\n          return null;\n        })()}\n\n        {currentSection &amp;&amp; (\n          &lt;FormStep\n            section={currentSection}\n            formData={state.formData}\n            errors={state.errors}\n            touched={touchedMap}\n            onFieldChange={handleFieldChange}\n            onFieldBlur={handleFieldBlur}\n          /&gt;\n        )}\n      &lt;/div&gt;\n\n      &lt;FormNavigation\n        isFirstStep={isFirstStep}\n        isLastStep={isLastStep}\n        onNext={handleNext}\n        onPrevious={handlePrevious}\n        onSaveDraft={handleManualSave}\n        progress={progress}\n        isSubmitting={state.isSubmitting}\n        isSavingDraft={isSavingDraft}\n        draftStatus={draftStatus}\n        draftError={draftError}\n        lastSavedAt={lastSavedAt}\n      /&gt;\n      &lt;p role=\&quot;status\&quot; aria-live=\&quot;polite\&quot; className=\&quot;sr-only\&quot;&gt;\n        {liveMessage}\n      &lt;/p&gt;\n    &lt;/div&gt;\n  );\n}\n\&quot;use client\&quot;;\n\nimport { useState, useCallback, useRef, useEffect } from \&quot;react\&quot;;\nimport type { FormConfigWithFields } from \&quot;@/lib/forms/types\&quot;;\nimport { validateStep, getStepFieldKeys } from \&quot;@/lib/forms/form-validator\&quot;;\nimport { buildFormSchema } from \&quot;@/lib/form-schema\&quot;;\nimport { StepIndicator } from \&quot;./step-indicator\&quot;;\nimport { FormStep } from \&quot;./form-step\&quot;;\nimport { FormNavigation } from \&quot;./form-navigation\&quot;;\nimport { FormErrorSummary } from \&quot;./form-error-summary\&quot;;\nimport { usePrefersReducedMotion } from \&quot;@/hooks/use-prefers-reduced-motion\&quot;;\nimport { useToast } from \&quot;@/components/ui/use-toast\&quot;;\nimport { cn } from \&quot;@/lib/utils\&quot;;\nimport type { DraftStatus } from \&quot;./draft-save-indicator\&quot;;\n\ninterface DynamicFormWizardProps {\n  formConfig: FormConfigWithFields;\n  initialData?: Record&lt;string, unknown&gt;;\n  onStepChange?: (stepIndex: number) =&gt; void;\n  onComplete?: (formData: Record&lt;string, unknown&gt;) =&gt; void;\n  onSaveDraft?: (formData: Record&lt;string, unknown&gt;) =&gt; void;\n}\n\nexport function DynamicFormWizard({\n  formConfig,\n  initialData = {},\n  onStepChange,\n  onComplete,\n  onSaveDraft,\n}: DynamicFormWizardProps) {\n  const sortedSections = [...formConfig.sections].sort(\n    (a, b) =&gt; a.order - b.order\n  );\n\n  const [currentStep, setCurrentStep] = useState(0);\n  const [formData, setFormData] = useState&lt;Record&lt;string, unknown&gt;&gt;(\n    initialData\n  );\n  const [completedSteps, setCompletedSteps] = useState&lt;Set&lt;number&gt;&gt;(\n    new Set()\n  );\n  const [errors, setErrors] = useState&lt;Record&lt;string, string&gt;&gt;({});\n  const [touched, setTouched] = useState&lt;Record&lt;string, boolean&gt;&gt;({});\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  const [isSavingDraft, setIsSavingDraft] = useState(false);\n  const [draftStatus, setDraftStatus] = useState&lt;DraftStatus&gt;(\&quot;idle\&quot;);\n  const [draftError, setDraftError] = useState&lt;string | null&gt;(null);\n  const [lastSavedAt, setLastSavedAt] = useState&lt;Date | null&gt;(null);\n  const [liveMessage, setLiveMessage] = useState(\&quot;\&quot;);\n  const validationTimersRef = useRef&lt;Record&lt;string, NodeJS.Timeout&gt;&gt;({});\n  const formSchemaRef = useRef(buildFormSchema(formConfig));\n  const prefersReducedMotion = usePrefersReducedMotion();\n  const { toast } = useToast();\n\n  const totalSteps = sortedSections.length;\n  const currentSection = sortedSections[currentStep];\n  const isFirstStep = currentStep === 0;\n  const isLastStep = currentStep === totalSteps - 1;\n\n  // Rebuild schema if form config changes\n  useEffect(() =&gt; {\n    formSchemaRef.current = buildFormSchema(formConfig);\n  }, [formConfig]);\n\n  /**\n   * Validate a single field with debouncing\n   */\n  const validateField = useCallback(\n    (fieldKey: string, value: unknown, immediate = false) =&gt; {\n      // Clear existing timer for this field\n      if (validationTimersRef.current[fieldKey]) {\n        clearTimeout(validationTimersRef.current[fieldKey]);\n      }\n\n      const performValidation = () =&gt; {\n        const fieldSchema = formSchemaRef.current.shape[fieldKey];\n        if (!fieldSchema) {\n          return;\n        }\n\n        try {\n          fieldSchema.parse(value);\n          // Clear error if validation passes\n          setErrors((prev) =&gt; {\n            const next = { ...prev };\n            delete next[fieldKey];\n            return next;\n          });\n        } catch (error) {\n          if (error &amp;&amp; typeof error === \&quot;object\&quot; &amp;&amp; \&quot;issues\&quot; in error) {\n            const zodError = error as { issues: Array&lt;{ message: string }&gt; };\n            const firstIssue = zodError.issues[0];\n            if (firstIssue) {\n              setErrors((prev) =&gt; ({\n                ...prev,\n                [fieldKey]: firstIssue.message,\n              }));\n            }\n          } else if (error instanceof Error) {\n            setErrors((prev) =&gt; ({\n              ...prev,\n              [fieldKey]: error.message,\n            }));\n          }\n        }\n      };\n\n      if (immediate) {\n        performValidation();\n      } else {\n        // Debounce validation on change (300ms)\n        validationTimersRef.current[fieldKey] = setTimeout(performValidation, 300);\n      }\n    },\n    []\n  );\n\n  const handleFieldChange = useCallback(\n    (fieldKey: string, value: unknown) =&gt; {\n      setFormData((prev) =&gt; ({\n        ...prev,\n        [fieldKey]: value,\n      }));\n\n      // Validate on change with debounce (only if field has been touched)\n      if (touched[fieldKey]) {\n        validateField(fieldKey, value, false);\n      }\n    },\n    [touched, validateField]\n  );\n\n  const handleFieldBlur = useCallback(\n    (fieldKey: string) =&gt; {\n      setTouched((prev) =&gt; ({\n        ...prev,\n        [fieldKey]: true,\n      }));\n\n      // Validate immediately on blur\n      const value = formData[fieldKey];\n      validateField(fieldKey, value, true);\n    },\n    [formData, validateField]\n  );\n\n  /**\n   * Validate current step using the validation utilities\n   */\n  const validateCurrentStep = useCallback((): boolean =&gt; {\n    const stepResult = validateStep(currentStep, formData, formConfig);\n\n    if (!stepResult.isValid) {\n      // Update errors for current step fields only\n      const stepFieldKeys = getStepFieldKeys(currentStep, formConfig);\n      setErrors((prev) =&gt; {\n        const next = { ...prev };\n        // Clear errors for fields not in current step\n        stepFieldKeys.forEach((key) =&gt; {\n          if (stepResult.errors[key]) {\n            next[key] = stepResult.errors[key];\n          } else {\n            delete next[key];\n          }\n        });\n        return next;\n      });\n\n      // Mark all fields in step as touched\n      setTouched((prev) =&gt; {\n        const next = { ...prev };\n        stepFieldKeys.forEach((key) =&gt; {\n          next[key] = true;\n        });\n        return next;\n      });\n\n      // Focus first error field\n      if (stepResult.firstErrorField) {\n        // Find the field by key to get its ID\n        const errorField = currentSection.fields.find(\n          (f) =&gt; f.key === stepResult.firstErrorField\n        );\n        if (errorField) {\n          // Field components use &#96;field-${field.id}&#96; as the ID\n          const fieldElement = document.getElementById(&#96;field-${errorField.id}&#96;);\n          if (fieldElement) {\n            fieldElement.focus();\n            fieldElement.scrollIntoView({ behavior: \&quot;smooth\&quot;, block: \&quot;center\&quot; });\n          }\n        }\n      }\n    }\n\n    return stepResult.isValid;\n  }, [currentStep, formData, formConfig, currentSection]);\n\n  const handleNext = useCallback(async () =&gt; {\n    if (isSubmitting) {\n      return;\n    }\n\n    const isStepValid = validateCurrentStep();\n    if (!isStepValid) {\n      toast({\n        variant: \&quot;destructive\&quot;,\n        title: \&quot;Please fix validation errors\&quot;,\n        description: \&quot;Resolve highlighted fields before continuing.\&quot;,\n      });\n      return;\n    }\n\n    setCompletedSteps((prev) =&gt; new Set(prev).add(currentStep));\n\n    if (isLastStep) {\n      if (!onComplete) {\n        return;\n      }\n      try {\n        setIsSubmitting(true);\n        await onComplete(formData);\n        toast({\n          title: \&quot;Form submitted\&quot;,\n          description: \&quot;Thanks! We received your information.\&quot;,\n        });\n      } catch (error) {\n        toast({\n          variant: \&quot;destructive\&quot;,\n          title: \&quot;Submission failed\&quot;,\n          description:\n            error instanceof Error\n              ? error.message\n              : \&quot;Something went wrong while submitting. Please try again.\&quot;,\n        });\n      } finally {\n        setIsSubmitting(false);\n      }\n    } else {\n      const nextStep = currentStep + 1;\n      setCurrentStep(nextStep);\n      onStepChange?.(nextStep);\n    }\n  }, [\n    currentStep,\n    formData,\n    isLastStep,\n    isSubmitting,\n    onComplete,\n    onStepChange,\n    toast,\n    validateCurrentStep,\n  ]);\n\n  const handlePrevious = useCallback(() =&gt; {\n    if (!isFirstStep) {\n      const prevStep = currentStep - 1;\n      setCurrentStep(prevStep);\n      onStepChange?.(prevStep);\n    }\n  }, [currentStep, isFirstStep, onStepChange]);\n\n  const handleStepClick = useCallback(\n    (stepIndex: number) =&gt; {\n      // Validate current step before allowing navigation\n      if (stepIndex !== currentStep) {\n        if (!validateCurrentStep()) {\n          return; // Don&#39;t allow navigation if current step is invalid\n        }\n      }\n\n      // Allow navigation to completed steps or the next step\n      if (completedSteps.has(stepIndex) || stepIndex === currentStep + 1) {\n        setCurrentStep(stepIndex);\n        onStepChange?.(stepIndex);\n      }\n    },\n    [completedSteps, currentStep, onStepChange, validateCurrentStep]\n  );\n\n  const handleSaveDraft = useCallback(async () =&gt; {\n    if (!onSaveDraft || isSavingDraft) {\n      return;\n    }\n    try {\n      setIsSavingDraft(true);\n      setDraftStatus(\&quot;saving\&quot;);\n      setDraftError(null);\n      await onSaveDraft(formData);\n      setDraftStatus(\&quot;success\&quot;);\n      const savedAt = new Date();\n      setLastSavedAt(savedAt);\n      toast({\n        title: \&quot;Draft saved\&quot;,\n        description: &#96;Progress saved at ${savedAt.toLocaleTimeString([], {\n          hour: \&quot;numeric\&quot;,\n          minute: \&quot;2-digit\&quot;,\n        })}&#96;,\n      });\n    } catch (error) {\n      setDraftStatus(\&quot;error\&quot;);\n      const message =\n        error instanceof Error\n          ? error.message\n          : \&quot;Unable to save your draft right now.\&quot;;\n      setDraftError(message);\n      toast({\n        variant: \&quot;destructive\&quot;,\n        title: \&quot;Draft not saved\&quot;,\n        description: message,\n      });\n    } finally {\n      setIsSavingDraft(false);\n    }\n  }, [formData, isSavingDraft, onSaveDraft, toast]);\n\n  // Cleanup timers on unmount\n  useEffect(() =&gt; {\n    const timers = validationTimersRef.current;\n    return () =&gt; {\n      Object.values(timers).forEach((timer) =&gt; {\n        clearTimeout(timer);\n      });\n    };\n  }, []);\n\n  const progress = totalSteps &gt; 0 ? ((currentStep + 1) / totalSteps) * 100 : 0;\n\n  useEffect(() =&gt; {\n    const sectionLabel = currentSection?.label ?? &#96;Step ${currentStep + 1}&#96;;\n    setLiveMessage(&#96;Now viewing ${sectionLabel} (${currentStep + 1} of ${totalSteps})&#96;);\n  }, [currentSection, currentStep, totalSteps]);\n\n  return (\n    &lt;div className=\&quot;flex flex-col gap-6 pb-32 sm:pb-12\&quot;&gt;\n      &lt;StepIndicator\n        steps={sortedSections.map((section, index) =&gt; ({\n          id: section.id,\n          label: section.label,\n          order: section.order,\n        }))}\n        currentStep={currentStep}\n        completedSteps={completedSteps}\n        onStepClick={handleStepClick}\n      /&gt;\n\n      &lt;div\n        className={cn(\n          \&quot;min-h-[400px] space-y-6 rounded-3xl border border-border/60 bg-background/70 p-4 shadow-lg sm:p-8\&quot;,\n          !prefersReducedMotion &amp;&amp; \&quot;transition-shadow duration-300\&quot;\n        )}\n      &gt;\n        {/* Error summary for current step */}\n        {(() =&gt; {\n          const stepFieldKeys = getStepFieldKeys(currentStep, formConfig);\n          const stepErrors: Record&lt;string, string&gt; = {};\n          stepFieldKeys.forEach((key) =&gt; {\n            if (errors[key] &amp;&amp; touched[key]) {\n              stepErrors[key] = errors[key];\n            }\n          });\n\n          if (Object.keys(stepErrors).length &gt; 0) {\n            return (\n              &lt;FormErrorSummary\n                errors={stepErrors}\n                onErrorClick={(fieldKey) =&gt; {\n                  // Find the field by key to get its ID\n                  const errorField = currentSection.fields.find(\n                    (f) =&gt; f.key === fieldKey\n                  );\n                  if (errorField) {\n                    // Field components use &#96;field-${field.id}&#96; as the ID\n                    const fieldElement = document.getElementById(&#96;field-${errorField.id}&#96;);\n                    if (fieldElement) {\n                      fieldElement.focus();\n                      fieldElement.scrollIntoView({\n                        behavior: \&quot;smooth\&quot;,\n                        block: \&quot;center\&quot;,\n                      });\n                    }\n                  }\n                }}\n              /&gt;\n            );\n          }\n          return null;\n        })()}\n\n        &lt;FormStep\n          section={currentSection}\n          formData={formData}\n          errors={errors}\n          touched={touched}\n          onFieldChange={handleFieldChange}\n          onFieldBlur={handleFieldBlur}\n        /&gt;\n      &lt;/div&gt;\n\n      &lt;FormNavigation\n        isFirstStep={isFirstStep}\n        isLastStep={isLastStep}\n        onNext={handleNext}\n        onPrevious={handlePrevious}\n        onSaveDraft={handleSaveDraft}\n        progress={progress}\n        isSubmitting={isSubmitting}\n        isSavingDraft={isSavingDraft}\n        draftStatus={draftStatus}\n        draftError={draftError}\n        lastSavedAt={lastSavedAt}\n      /&gt;\n      &lt;p role=\&quot;status\&quot; aria-live=\&quot;polite\&quot; className=\&quot;sr-only\&quot;&gt;\n        {liveMessage}\n      &lt;/p&gt;\n    &lt;/div&gt;\n  );\n}\n\n&quot;
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Verifying duplicate directives**</details></think>

---

<tool-use data-tool-type="grep" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for ""use client"" in "/Users/sahilmehta/supplier-onboarding-simple/components/forms/dynamic-form-wizard.tsx" • 3 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `components/forms/dynamic-form-wizard.tsx` | `"use client";` | L1 |
| `components/forms/dynamic-form-wizard.tsx` | `"use client";` | L401 |
| `components/forms/dynamic-form-wizard.tsx` | `"use client";` | L802 |


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Removing file via terminal command**</details></think>

---

<tool-use data-tool-type="bash" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **command** • Run command: cd /Users/sahilmehta/supplier-onboarding-simple && rm components/forms/dynamic-form-wizard.tsx</summary>

```bash
cd /Users/sahilmehta/supplier-onboarding-simple && rm components/forms/dynamic-form-wizard.tsx
```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Re-adding updated file**</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  &quot;relativeWorkspacePath&quot;: &quot;components/forms/dynamic-form-wizard.tsx&quot;
}
```
Additional data:

```json
{
  &quot;codeblockId&quot;: &quot;8f06b23e-766d-4cd1-a716-accc02ffdfa6&quot;,
  &quot;reviewData&quot;: {
    &quot;status&quot;: &quot;None&quot;,
    &quot;selectedOption&quot;: &quot;accept&quot;,
    &quot;isShowingInput&quot;: false,
    &quot;firstTimeReviewMode&quot;: false
  }
}
```
Result:

```json
{
  &quot;diff&quot;: {
    &quot;chunks&quot;: [
      {
        &quot;diffString&quot;: &quot;      validateAndCommitStep,\n    ]);\n+ \n+   const handlePrevious = useCallback(() =&gt; {\n+     if (isFirstStep) {\n+       return;\n+     }\n+     const prevStep = state.currentStep - 1;\n+     goToStep(prevStep);\n+     onStepChange?.(prevStep);\n+   }, [goToStep, isFirstStep, onStepChange, state.currentStep]);\n+ \n+   const handleStepClick = useCallback(\n+     (stepIndex: number) =&gt; {\n+       if (stepIndex === state.currentStep) {\n+         return;\n+       }\n+ \n+       const validation = validateAndCommitStep(state.currentStep);\n+       if (!validation.isValid) {\n+         toast({\n+           variant: \&quot;destructive\&quot;,\n+           title: \&quot;Cannot leave step yet\&quot;,\n+           description: \&quot;Fix validation errors before moving on.\&quot;,\n+         });\n+         focusFirstError(validation.firstErrorField);\n+         return;\n+       }\n+ \n+       if (\n+         state.completedSteps.has(stepIndex) ||\n+         stepIndex === state.currentStep + 1\n+       ) {\n+         goToStep(stepIndex);\n+         onStepChange?.(stepIndex);\n+         void triggerSave(\&quot;step-change\&quot;);\n+       }\n+     },\n+     [\n+       focusFirstError,\n+       goToStep,\n+       onStepChange,\n+       state.completedSteps,\n+       state.currentStep,\n+       toast,\n+       triggerSave,\n+       validateAndCommitStep,\n+     ]\n+   );\n+ \n+   const handleManualSave = useCallback(() =&gt; {\n+     void triggerSave(\&quot;manual\&quot;);\n+   }, [triggerSave]);\n+ \n+   useEffect(() =&gt; {\n+     return () =&gt; {\n+       Object.values(validationTimersRef.current).forEach((timer) =&gt; {\n+         clearTimeout(timer);\n+       });\n+     };\n+   }, []);\n+ \n+   useEffect(() =&gt; {\n+     const sectionLabel = currentSection?.label ?? &#96;Step ${state.currentStep + 1}&#96;;\n+     setLiveMessage(\n+       &#96;Now viewing ${sectionLabel} (${state.currentStep + 1} of ${totalSteps})&#96;\n+     );\n+   }, [currentSection, state.currentStep, totalSteps]);\n+ \n+   const progress =\n+     totalSteps &gt; 0 ? ((state.currentStep + 1) / totalSteps) * 100 : 0;\n+ \n+   return (\n+     &lt;div className=\&quot;flex flex-col gap-6 pb-32 sm:pb-12\&quot;&gt;\n+       &lt;StepIndicator\n+         steps={sortedSections.map((section) =&gt; ({\n+           id: section.id,\n+           label: section.label,\n+           order: section.order,\n+         }))}\n+         currentStep={state.currentStep}\n+         completedSteps={state.completedSteps}\n+         onStepClick={handleStepClick}\n+       /&gt;\n+ \n+       &lt;div\n+         className={cn(\n+           \&quot;min-h-[400px] space-y-6 rounded-3xl border border-border/60 bg-background/70 p-4 shadow-lg sm:p-8\&quot;,\n+           !prefersReducedMotion &amp;&amp; \&quot;transition-shadow duration-300\&quot;\n+         )}\n+       &gt;\n+         {(() =&gt; {\n+           const stepFieldKeys = getStepFieldKeys(state.currentStep, formConfig);\n+           const stepErrors: Record&lt;string, string&gt; = {};\n+           stepFieldKeys.forEach((key) =&gt; {\n+             if (state.errors[key] &amp;&amp; touchedMap[key]) {\n+               stepErrors[key] = state.errors[key];\n+             }\n+           });\n+ \n+           if (Object.keys(stepErrors).length &gt; 0) {\n+             return (\n+               &lt;FormErrorSummary\n+                 errors={stepErrors}\n+                 onErrorClick={(fieldKey) =&gt; focusFirstError(fieldKey)}\n+               /&gt;\n+             );\n+           }\n+           return null;\n+         })()}\n+ \n+         {currentSection &amp;&amp; (\n+           &lt;FormStep\n+             section={currentSection}\n+             formData={state.formData}\n+             errors={state.errors}\n+             touched={touchedMap}\n+             onFieldChange={handleFieldChange}\n+             onFieldBlur={handleFieldBlur}\n+           /&gt;\n+         )}\n+       &lt;/div&gt;\n+ \n+       &lt;FormNavigation\n+         isFirstStep={isFirstStep}\n+         isLastStep={isLastStep}\n+         onNext={handleNext}\n+         onPrevious={handlePrevious}\n+         onSaveDraft={handleManualSave}\n+         progress={progress}\n+         isSubmitting={state.isSubmitting}\n+         isSavingDraft={isSavingDraft}\n+         draftStatus={draftStatus}\n+         draftError={draftError}\n+         lastSavedAt={lastSavedAt}\n+       /&gt;\n+       &lt;p role=\&quot;status\&quot; aria-live=\&quot;polite\&quot; className=\&quot;sr-only\&quot;&gt;\n+         {liveMessage}\n+       &lt;/p&gt;\n+     &lt;/div&gt;\n+   );\n+ }\n+ \&quot;use client\&quot;;\n+ \n+ import { useCallback, useEffect, useMemo, useRef, useState } from \&quot;react\&quot;;\n+ import type { FormConfigWithFields } from \&quot;@/lib/forms/types\&quot;;\n+ import { getStepFieldKeys } from \&quot;@/lib/forms/form-validator\&quot;;\n+ import { buildFormSchema } from \&quot;@/lib/form-schema\&quot;;\n+ import { saveFormDraft, type DraftSaveResult } from \&quot;@/app/forms/actions\&quot;;\n+ import { StepIndicator } from \&quot;./step-indicator\&quot;;\n+ import { FormStep } from \&quot;./form-step\&quot;;\n+ import { FormNavigation } from \&quot;./form-navigation\&quot;;\n+ import { FormErrorSummary } from \&quot;./form-error-summary\&quot;;\n+ import { useFormState } from \&quot;@/hooks/use-form-state\&quot;;\n+ import { useAutosave } from \&quot;@/hooks/use-autosave\&quot;;\n+ import { useToast } from \&quot;@/components/ui/use-toast\&quot;;\n+ import { usePrefersReducedMotion } from \&quot;@/hooks/use-prefers-reduced-motion\&quot;;\n+ import { cn } from \&quot;@/lib/utils\&quot;;\n+ \n+ interface DynamicFormWizardProps {\n+   formConfig: FormConfigWithFields;\n+   initialData?: Record&lt;string, unknown&gt;;\n+   initialStep?: number;\n+   applicationId: string | null;\n+   organizationId: string;\n+   onApplicationIdChange?: (applicationId: string) =&gt; void;\n+   onDraftSaved?: (result: DraftSaveResult) =&gt; void;\n+   onStepChange?: (stepIndex: number) =&gt; void;\n+   onComplete?: (formData: Record&lt;string, unknown&gt;) =&gt; Promise&lt;void&gt; | void;\n+ }\n+ \n+ export function DynamicFormWizard({\n+   formConfig,\n+   initialData = {},\n+   initialStep = 0,\n+   applicationId,\n+   organizationId,\n+   onApplicationIdChange,\n+   onDraftSaved,\n+   onStepChange,\n+   onComplete,\n+ }: DynamicFormWizardProps) {\n+   const sortedSections = useMemo(\n+     () =&gt; [...formConfig.sections].sort((a, b) =&gt; a.order - b.order),\n+     [formConfig.sections]\n+   );\n+ \n+   const {\n+     state,\n+     touchedMap,\n+     setFieldValue,\n+     markFieldTouched,\n+     markFieldsTouched,\n+     setFieldError,\n+     setStepErrors,\n+     goToStep,\n+     markStepComplete,\n+     setIsSubmitting,\n+     markClean,\n+     validateAndCommitStep,\n+   } = useFormState({\n+     formConfig,\n+     initialData,\n+     initialStep,\n+   });\n+ \n+   const [liveMessage, setLiveMessage] = useState(\&quot;\&quot;);\n+   const validationTimersRef = useRef&lt;Record&lt;string, NodeJS.Timeout&gt;&gt;({});\n+   const formSchemaRef = useRef(buildFormSchema(formConfig));\n+   const prefersReducedMotion = usePrefersReducedMotion();\n+   const { toast } = useToast();\n+ \n+   const totalSteps = sortedSections.length;\n+   const currentSection = sortedSections[state.currentStep];\n+   const isFirstStep = state.currentStep === 0;\n+   const isLastStep = state.currentStep === totalSteps - 1;\n+ \n+   useEffect(() =&gt; {\n+     formSchemaRef.current = buildFormSchema(formConfig);\n+   }, [formConfig]);\n+ \n+   const focusFirstError = useCallback(\n+     (fieldKey?: string) =&gt; {\n+       if (!fieldKey || !currentSection) {\n+         return;\n+       }\n+       const errorField = currentSection.fields.find((field) =&gt; field.key === fieldKey);\n+       const fieldElement = errorField\n+         ? document.getElementById(&#96;field-${errorField.id}&#96;)\n+         : null;\n+       fieldElement?.focus();\n+       fieldElement?.scrollIntoView({ behavior: \&quot;smooth\&quot;, block: \&quot;center\&quot; });\n+     },\n+     [currentSection]\n+   );\n+ \n+   const validateField = useCallback(\n+     (fieldKey: string, value: unknown, immediate = false) =&gt; {\n+       if (validationTimersRef.current[fieldKey]) {\n+         clearTimeout(validationTimersRef.current[fieldKey]);\n+       }\n+ \n+       const performValidation = () =&gt; {\n+         const fieldSchema = formSchemaRef.current.shape[fieldKey];\n+         if (!fieldSchema) {\n+           return;\n+         }\n+ \n+         try {\n+           fieldSchema.parse(value);\n+           setFieldError(fieldKey);\n+         } catch (error) {\n+           if (error &amp;&amp; typeof error === \&quot;object\&quot; &amp;&amp; \&quot;issues\&quot; in error) {\n+             const zodError = error as { issues: Array&lt;{ message: string }&gt; };\n+             const firstIssue = zodError.issues[0];\n+             if (firstIssue) {\n+               setFieldError(fieldKey, firstIssue.message);\n+             }\n+           } else if (error instanceof Error) {\n+             setFieldError(fieldKey, error.message);\n+           }\n+         }\n+       };\n+ \n+       if (immediate) {\n+         performValidation();\n+       } else {\n+         validationTimersRef.current[fieldKey] = setTimeout(performValidation, 300);\n+       }\n+     },\n+     [setFieldError]\n+   );\n+ \n+   const handleFieldChange = useCallback(\n+     (fieldKey: string, value: unknown) =&gt; {\n+       setFieldValue(fieldKey, value);\n+       if (state.touched.has(fieldKey)) {\n+         validateField(fieldKey, value, false);\n+       }\n+     },\n+     [setFieldValue, state.touched, validateField]\n+   );\n+ \n+   const handleFieldBlur = useCallback(\n+     (fieldKey: string) =&gt; {\n+       markFieldTouched(fieldKey);\n+       validateField(fieldKey, state.formData[fieldKey], true);\n+     },\n+     [markFieldTouched, state.formData, validateField]\n+   );\n+ \n+   const autosaveFingerprint = useMemo(\n+     () =&gt; JSON.stringify({ data: state.formData, step: state.currentStep }),\n+     [state.formData, state.currentStep]\n+   );\n+ \n+   const runDraftSave = useCallback(() =&gt; {\n+     return saveFormDraft({\n+       formConfigId: formConfig.id,\n+       organizationId,\n+       entityId: formConfig.entityId,\n+       geographyId: formConfig.geographyId,\n+       applicationId,\n+       formData: state.formData,\n+       currentStep: state.currentStep,\n+     });\n+   }, [\n+     applicationId,\n+     formConfig.entityId,\n+     formConfig.geographyId,\n+     formConfig.id,\n+     organizationId,\n+     state.currentStep,\n+     state.formData,\n+   ]);\n+ \n+   const {\n+     status: draftStatus,\n+     isSaving: isSavingDraft,\n+     lastSavedAt,\n+     error: draftError,\n+     triggerSave,\n+   } = useAutosave&lt;DraftSaveResult&gt;({\n+     shouldAutosave: state.isDirty,\n+     dataFingerprint: autosaveFingerprint,\n+     save: runDraftSave,\n+     onSuccess: (result) =&gt; {\n+       markClean();\n+       if (result.applicationId &amp;&amp; result.applicationId !== applicationId) {\n+         onApplicationIdChange?.(result.applicationId);\n+       }\n+       onDraftSaved?.(result);\n+     },\n+     onError: (error) =&gt; {\n+       toast({\n+         variant: \&quot;destructive\&quot;,\n+         title: \&quot;Draft save failed\&quot;,\n+         description: error.message,\n+       });\n+     },\n+   });\n+ \n+   const handleNext = useCallback(async () =&gt; {\n+     if (state.isSubmitting) {\n+       return;\n+     }\n+ \n+     const validation = validateAndCommitStep(state.currentStep);\n+     if (!validation.isValid) {\n+       toast({\n+         variant: \&quot;destructive\&quot;,\n+         title: \&quot;Please fix validation errors\&quot;,\n+         description: \&quot;Resolve highlighted fields before continuing.\&quot;,\n+       });\n+       focusFirstError(validation.firstErrorField);\n+       return;\n+     }\n+ \n+     markStepComplete(state.currentStep);\n+ \n+     if (isLastStep &amp;&amp; onComplete) {\n+       try {\n+         setIsSubmitting(true);\n+         await onComplete(state.formData);\n+         toast({\n+           title: \&quot;Form submitted\&quot;,\n+           description: \&quot;Thank you! We received your information.\&quot;,\n+         });\n+       } catch (error) {\n+         toast({\n+           variant: \&quot;destructive\&quot;,\n+           title: \&quot;Submission failed\&quot;,\n+           description:\n+             error instanceof Error\n+               ? error.message\n+               : \&quot;Something went wrong while submitting. Please try again.\&quot;,\n+         });\n+       } finally {\n+         setIsSubmitting(false);\n+       }\n+       return;\n+     }\n+ \n+     const nextStep = state.currentStep + 1;\n+     goToStep(nextStep);\n+     onStepChange?.(nextStep);\n+     void triggerSave(\&quot;step-change\&quot;);\n+   }, [\n+     focusFirstError,\n+     goToStep,\n+     isLastStep,\n+     markStepComplete,\n+     onComplete,\n+     onStepChange,\n+     setIsSubmitting,\n+     state.currentStep,\n+     state.formData,\n+     state.isSubmitting,\n+     toast,\n+     triggerSave,\n+     validateAndCommitStep,\n+   ]);\n  \n    const handlePrevious = useCallback(() =&gt; {&quot;,
        &quot;oldStart&quot;: 659,
        &quot;newStart&quot;: 659,
        &quot;oldLines&quot;: 4,
        &quot;newLines&quot;: 404,
        &quot;linesAdded&quot;: 400
      }
    ],
    &quot;editor&quot;: &quot;EDITOR_AI&quot;
  },
  &quot;shouldAutoFixLints&quot;: true,
  &quot;resultForModel&quot;: &quot;Success. Updated the following files:\nM components/forms/dynamic-form-wizard.tsx&quot;,
  &quot;contentsAfterEdit&quot;: &quot;\&quot;use client\&quot;;\n\nimport { useCallback, useEffect, useMemo, useRef, useState } from \&quot;react\&quot;;\nimport type { FormConfigWithFields } from \&quot;@/lib/forms/types\&quot;;\nimport { getStepFieldKeys } from \&quot;@/lib/forms/form-validator\&quot;;\nimport { buildFormSchema } from \&quot;@/lib/form-schema\&quot;;\nimport { saveFormDraft, type DraftSaveResult } from \&quot;@/app/forms/actions\&quot;;\nimport { StepIndicator } from \&quot;./step-indicator\&quot;;\nimport { FormStep } from \&quot;./form-step\&quot;;\nimport { FormNavigation } from \&quot;./form-navigation\&quot;;\nimport { FormErrorSummary } from \&quot;./form-error-summary\&quot;;\nimport { useFormState } from \&quot;@/hooks/use-form-state\&quot;;\nimport { useAutosave } from \&quot;@/hooks/use-autosave\&quot;;\nimport { useToast } from \&quot;@/components/ui/use-toast\&quot;;\nimport { usePrefersReducedMotion } from \&quot;@/hooks/use-prefers-reduced-motion\&quot;;\nimport { cn } from \&quot;@/lib/utils\&quot;;\n\ninterface DynamicFormWizardProps {\n  formConfig: FormConfigWithFields;\n  initialData?: Record&lt;string, unknown&gt;;\n  initialStep?: number;\n  applicationId: string | null;\n  organizationId: string;\n  onApplicationIdChange?: (applicationId: string) =&gt; void;\n  onDraftSaved?: (result: DraftSaveResult) =&gt; void;\n  onStepChange?: (stepIndex: number) =&gt; void;\n  onComplete?: (formData: Record&lt;string, unknown&gt;) =&gt; Promise&lt;void&gt; | void;\n}\n\nexport function DynamicFormWizard({\n  formConfig,\n  initialData = {},\n  initialStep = 0,\n  applicationId,\n  organizationId,\n  onApplicationIdChange,\n  onDraftSaved,\n  onStepChange,\n  onComplete,\n}: DynamicFormWizardProps) {\n  const sortedSections = useMemo(\n    () =&gt; [...formConfig.sections].sort((a, b) =&gt; a.order - b.order),\n    [formConfig.sections]\n  );\n\n  const {\n    state,\n    touchedMap,\n    setFieldValue,\n    markFieldTouched,\n    markFieldsTouched,\n    setFieldError,\n    setStepErrors,\n    goToStep,\n    markStepComplete,\n    setIsSubmitting,\n    markClean,\n    validateAndCommitStep,\n  } = useFormState({\n    formConfig,\n    initialData,\n    initialStep,\n  });\n\n  const [liveMessage, setLiveMessage] = useState(\&quot;\&quot;);\n  const validationTimersRef = useRef&lt;Record&lt;string, NodeJS.Timeout&gt;&gt;({});\n  const formSchemaRef = useRef(buildFormSchema(formConfig));\n  const prefersReducedMotion = usePrefersReducedMotion();\n  const { toast } = useToast();\n\n  const totalSteps = sortedSections.length;\n  const currentSection = sortedSections[state.currentStep];\n  const isFirstStep = state.currentStep === 0;\n  const isLastStep = state.currentStep === totalSteps - 1;\n\n  useEffect(() =&gt; {\n    formSchemaRef.current = buildFormSchema(formConfig);\n  }, [formConfig]);\n\n  const focusFirstError = useCallback(\n    (fieldKey?: string) =&gt; {\n      if (!fieldKey || !currentSection) {\n        return;\n      }\n      const errorField = currentSection.fields.find((field) =&gt; field.key === fieldKey);\n      const fieldElement = errorField\n        ? document.getElementById(&#96;field-${errorField.id}&#96;)\n        : null;\n      fieldElement?.focus();\n      fieldElement?.scrollIntoView({ behavior: \&quot;smooth\&quot;, block: \&quot;center\&quot; });\n    },\n    [currentSection]\n  );\n\n  const validateField = useCallback(\n    (fieldKey: string, value: unknown, immediate = false) =&gt; {\n      if (validationTimersRef.current[fieldKey]) {\n        clearTimeout(validationTimersRef.current[fieldKey]);\n      }\n\n      const performValidation = () =&gt; {\n        const fieldSchema = formSchemaRef.current.shape[fieldKey];\n        if (!fieldSchema) {\n          return;\n        }\n\n        try {\n          fieldSchema.parse(value);\n          setFieldError(fieldKey);\n        } catch (error) {\n          if (error &amp;&amp; typeof error === \&quot;object\&quot; &amp;&amp; \&quot;issues\&quot; in error) {\n            const zodError = error as { issues: Array&lt;{ message: string }&gt; };\n            const firstIssue = zodError.issues[0];\n            if (firstIssue) {\n              setFieldError(fieldKey, firstIssue.message);\n            }\n          } else if (error instanceof Error) {\n            setFieldError(fieldKey, error.message);\n          }\n        }\n      };\n\n      if (immediate) {\n        performValidation();\n      } else {\n        validationTimersRef.current[fieldKey] = setTimeout(performValidation, 300);\n      }\n    },\n    [setFieldError]\n  );\n\n  const handleFieldChange = useCallback(\n    (fieldKey: string, value: unknown) =&gt; {\n      setFieldValue(fieldKey, value);\n      if (state.touched.has(fieldKey)) {\n        validateField(fieldKey, value, false);\n      }\n    },\n    [setFieldValue, state.touched, validateField]\n  );\n\n  const handleFieldBlur = useCallback(\n    (fieldKey: string) =&gt; {\n      markFieldTouched(fieldKey);\n      validateField(fieldKey, state.formData[fieldKey], true);\n    },\n    [markFieldTouched, state.formData, validateField]\n  );\n\n  const autosaveFingerprint = useMemo(\n    () =&gt; JSON.stringify({ data: state.formData, step: state.currentStep }),\n    [state.formData, state.currentStep]\n  );\n\n  const runDraftSave = useCallback(() =&gt; {\n    return saveFormDraft({\n      formConfigId: formConfig.id,\n      organizationId,\n      entityId: formConfig.entityId,\n      geographyId: formConfig.geographyId,\n      applicationId,\n      formData: state.formData,\n      currentStep: state.currentStep,\n    });\n  }, [\n    applicationId,\n    formConfig.entityId,\n    formConfig.geographyId,\n    formConfig.id,\n    organizationId,\n    state.currentStep,\n    state.formData,\n  ]);\n\n  const {\n    status: draftStatus,\n    isSaving: isSavingDraft,\n    lastSavedAt,\n    error: draftError,\n    triggerSave,\n  } = useAutosave&lt;DraftSaveResult&gt;({\n    shouldAutosave: state.isDirty,\n    dataFingerprint: autosaveFingerprint,\n    save: runDraftSave,\n    onSuccess: (result) =&gt; {\n      markClean();\n      if (result.applicationId &amp;&amp; result.applicationId !== applicationId) {\n        onApplicationIdChange?.(result.applicationId);\n      }\n      onDraftSaved?.(result);\n    },\n    onError: (error) =&gt; {\n      toast({\n        variant: \&quot;destructive\&quot;,\n        title: \&quot;Draft save failed\&quot;,\n        description: error.message,\n      });\n    },\n  });\n\n  const handleNext = useCallback(async () =&gt; {\n    if (state.isSubmitting) {\n      return;\n    }\n\n    const validation = validateAndCommitStep(state.currentStep);\n    if (!validation.isValid) {\n      toast({\n        variant: \&quot;destructive\&quot;,\n        title: \&quot;Please fix validation errors\&quot;,\n        description: \&quot;Resolve highlighted fields before continuing.\&quot;,\n      });\n      focusFirstError(validation.firstErrorField);\n      return;\n    }\n\n    markStepComplete(state.currentStep);\n\n    if (isLastStep &amp;&amp; onComplete) {\n      try {\n        setIsSubmitting(true);\n        await onComplete(state.formData);\n        toast({\n          title: \&quot;Form submitted\&quot;,\n          description: \&quot;Thank you! We received your information.\&quot;,\n        });\n      } catch (error) {\n        toast({\n          variant: \&quot;destructive\&quot;,\n          title: \&quot;Submission failed\&quot;,\n          description:\n            error instanceof Error\n              ? error.message\n              : \&quot;Something went wrong while submitting. Please try again.\&quot;,\n        });\n      } finally {\n        setIsSubmitting(false);\n      }\n      return;\n    }\n\n    const nextStep = state.currentStep + 1;\n    goToStep(nextStep);\n    onStepChange?.(nextStep);\n    void triggerSave(\&quot;step-change\&quot;);\n  }, [\n    focusFirstError,\n    goToStep,\n    isLastStep,\n    markStepComplete,\n    onComplete,\n    onStepChange,\n    setIsSubmitting,\n    state.currentStep,\n    state.formData,\n    state.isSubmitting,\n    toast,\n    triggerSave,\n    validateAndCommitStep,\n  ]);\n\n  const handlePrevious = useCallback(() =&gt; {\n    if (isFirstStep) {\n      return;\n    }\n    const prevStep = state.currentStep - 1;\n    goToStep(prevStep);\n    onStepChange?.(prevStep);\n  }, [goToStep, isFirstStep, onStepChange, state.currentStep]);\n\n  const handleStepClick = useCallback(\n    (stepIndex: number) =&gt; {\n      if (stepIndex === state.currentStep) {\n        return;\n      }\n\n      const validation = validateAndCommitStep(state.currentStep);\n      if (!validation.isValid) {\n        toast({\n          variant: \&quot;destructive\&quot;,\n          title: \&quot;Cannot leave step yet\&quot;,\n          description: \&quot;Fix validation errors before moving on.\&quot;,\n        });\n        focusFirstError(validation.firstErrorField);\n        return;\n      }\n\n      if (\n        state.completedSteps.has(stepIndex) ||\n        stepIndex === state.currentStep + 1\n      ) {\n        goToStep(stepIndex);\n        onStepChange?.(stepIndex);\n        void triggerSave(\&quot;step-change\&quot;);\n      }\n    },\n    [\n      focusFirstError,\n      goToStep,\n      onStepChange,\n      state.completedSteps,\n      state.currentStep,\n      toast,\n      triggerSave,\n      validateAndCommitStep,\n    ]\n  );\n\n  const handleManualSave = useCallback(() =&gt; {\n    void triggerSave(\&quot;manual\&quot;);\n  }, [triggerSave]);\n\n  useEffect(() =&gt; {\n    return () =&gt; {\n      Object.values(validationTimersRef.current).forEach((timer) =&gt; {\n        clearTimeout(timer);\n      });\n    };\n  }, []);\n\n  useEffect(() =&gt; {\n    const sectionLabel = currentSection?.label ?? &#96;Step ${state.currentStep + 1}&#96;;\n    setLiveMessage(\n      &#96;Now viewing ${sectionLabel} (${state.currentStep + 1} of ${totalSteps})&#96;\n    );\n  }, [currentSection, state.currentStep, totalSteps]);\n\n  const progress =\n    totalSteps &gt; 0 ? ((state.currentStep + 1) / totalSteps) * 100 : 0;\n\n  return (\n    &lt;div className=\&quot;flex flex-col gap-6 pb-32 sm:pb-12\&quot;&gt;\n      &lt;StepIndicator\n        steps={sortedSections.map((section) =&gt; ({\n          id: section.id,\n          label: section.label,\n          order: section.order,\n        }))}\n        currentStep={state.currentStep}\n        completedSteps={state.completedSteps}\n        onStepClick={handleStepClick}\n      /&gt;\n\n      &lt;div\n        className={cn(\n          \&quot;min-h-[400px] space-y-6 rounded-3xl border border-border/60 bg-background/70 p-4 shadow-lg sm:p-8\&quot;,\n          !prefersReducedMotion &amp;&amp; \&quot;transition-shadow duration-300\&quot;\n        )}\n      &gt;\n        {(() =&gt; {\n          const stepFieldKeys = getStepFieldKeys(state.currentStep, formConfig);\n          const stepErrors: Record&lt;string, string&gt; = {};\n          stepFieldKeys.forEach((key) =&gt; {\n            if (state.errors[key] &amp;&amp; touchedMap[key]) {\n              stepErrors[key] = state.errors[key];\n            }\n          });\n\n          if (Object.keys(stepErrors).length &gt; 0) {\n            return (\n              &lt;FormErrorSummary\n                errors={stepErrors}\n                onErrorClick={(fieldKey) =&gt; focusFirstError(fieldKey)}\n              /&gt;\n            );\n          }\n          return null;\n        })()}\n\n        {currentSection &amp;&amp; (\n          &lt;FormStep\n            section={currentSection}\n            formData={state.formData}\n            errors={state.errors}\n            touched={touchedMap}\n            onFieldChange={handleFieldChange}\n            onFieldBlur={handleFieldBlur}\n          /&gt;\n        )}\n      &lt;/div&gt;\n\n      &lt;FormNavigation\n        isFirstStep={isFirstStep}\n        isLastStep={isLastStep}\n        onNext={handleNext}\n        onPrevious={handlePrevious}\n        onSaveDraft={handleManualSave}\n        progress={progress}\n        isSubmitting={state.isSubmitting}\n        isSavingDraft={isSavingDraft}\n        draftStatus={draftStatus}\n        draftError={draftError}\n        lastSavedAt={lastSavedAt}\n      /&gt;\n      &lt;p role=\&quot;status\&quot; aria-live=\&quot;polite\&quot; className=\&quot;sr-only\&quot;&gt;\n        {liveMessage}\n      &lt;/p&gt;\n    &lt;/div&gt;\n  );\n}\n\&quot;use client\&quot;;\n\nimport { useCallback, useEffect, useMemo, useRef, useState } from \&quot;react\&quot;;\nimport type { FormConfigWithFields } from \&quot;@/lib/forms/types\&quot;;\nimport { getStepFieldKeys } from \&quot;@/lib/forms/form-validator\&quot;;\nimport { buildFormSchema } from \&quot;@/lib/form-schema\&quot;;\nimport { saveFormDraft, type DraftSaveResult } from \&quot;@/app/forms/actions\&quot;;\nimport { StepIndicator } from \&quot;./step-indicator\&quot;;\nimport { FormStep } from \&quot;./form-step\&quot;;\nimport { FormNavigation } from \&quot;./form-navigation\&quot;;\nimport { FormErrorSummary } from \&quot;./form-error-summary\&quot;;\nimport { useFormState } from \&quot;@/hooks/use-form-state\&quot;;\nimport { useAutosave } from \&quot;@/hooks/use-autosave\&quot;;\nimport { useToast } from \&quot;@/components/ui/use-toast\&quot;;\nimport { usePrefersReducedMotion } from \&quot;@/hooks/use-prefers-reduced-motion\&quot;;\nimport { cn } from \&quot;@/lib/utils\&quot;;\n\ninterface DynamicFormWizardProps {\n  formConfig: FormConfigWithFields;\n  initialData?: Record&lt;string, unknown&gt;;\n  initialStep?: number;\n  applicationId: string | null;\n  organizationId: string;\n  onApplicationIdChange?: (applicationId: string) =&gt; void;\n  onDraftSaved?: (result: DraftSaveResult) =&gt; void;\n  onStepChange?: (stepIndex: number) =&gt; void;\n  onComplete?: (formData: Record&lt;string, unknown&gt;) =&gt; Promise&lt;void&gt; | void;\n}\n\nexport function DynamicFormWizard({\n  formConfig,\n  initialData = {},\n  initialStep = 0,\n  applicationId,\n  organizationId,\n  onApplicationIdChange,\n  onDraftSaved,\n  onStepChange,\n  onComplete,\n}: DynamicFormWizardProps) {\n  const sortedSections = useMemo(\n    () =&gt; [...formConfig.sections].sort((a, b) =&gt; a.order - b.order),\n    [formConfig.sections]\n  );\n\n  const {\n    state,\n    touchedMap,\n    setFieldValue,\n    markFieldTouched,\n    markFieldsTouched,\n    setFieldError,\n    setStepErrors,\n    goToStep,\n    markStepComplete,\n    setIsSubmitting,\n    markClean,\n    validateAndCommitStep,\n  } = useFormState({\n    formConfig,\n    initialData,\n    initialStep,\n  });\n\n  const [liveMessage, setLiveMessage] = useState(\&quot;\&quot;);\n  const validationTimersRef = useRef&lt;Record&lt;string, NodeJS.Timeout&gt;&gt;({});\n  const formSchemaRef = useRef(buildFormSchema(formConfig));\n  const prefersReducedMotion = usePrefersReducedMotion();\n  const { toast } = useToast();\n\n  const totalSteps = sortedSections.length;\n  const currentSection = sortedSections[state.currentStep];\n  const isFirstStep = state.currentStep === 0;\n  const isLastStep = state.currentStep === totalSteps - 1;\n\n  useEffect(() =&gt; {\n    formSchemaRef.current = buildFormSchema(formConfig);\n  }, [formConfig]);\n\n  const focusFirstError = useCallback(\n    (fieldKey?: string) =&gt; {\n      if (!fieldKey || !currentSection) {\n        return;\n      }\n      const errorField = currentSection.fields.find((field) =&gt; field.key === fieldKey);\n      const fieldElement = errorField\n        ? document.getElementById(&#96;field-${errorField.id}&#96;)\n        : null;\n      fieldElement?.focus();\n      fieldElement?.scrollIntoView({ behavior: \&quot;smooth\&quot;, block: \&quot;center\&quot; });\n    },\n    [currentSection]\n  );\n\n  const validateField = useCallback(\n    (fieldKey: string, value: unknown, immediate = false) =&gt; {\n      if (validationTimersRef.current[fieldKey]) {\n        clearTimeout(validationTimersRef.current[fieldKey]);\n      }\n\n      const performValidation = () =&gt; {\n        const fieldSchema = formSchemaRef.current.shape[fieldKey];\n        if (!fieldSchema) {\n          return;\n        }\n\n        try {\n          fieldSchema.parse(value);\n          setFieldError(fieldKey);\n        } catch (error) {\n          if (error &amp;&amp; typeof error === \&quot;object\&quot; &amp;&amp; \&quot;issues\&quot; in error) {\n            const zodError = error as { issues: Array&lt;{ message: string }&gt; };\n            const firstIssue = zodError.issues[0];\n            if (firstIssue) {\n              setFieldError(fieldKey, firstIssue.message);\n            }\n          } else if (error instanceof Error) {\n            setFieldError(fieldKey, error.message);\n          }\n        }\n      };\n\n      if (immediate) {\n        performValidation();\n      } else {\n        validationTimersRef.current[fieldKey] = setTimeout(performValidation, 300);\n      }\n    },\n    [setFieldError]\n  );\n\n  const handleFieldChange = useCallback(\n    (fieldKey: string, value: unknown) =&gt; {\n      setFieldValue(fieldKey, value);\n      if (state.touched.has(fieldKey)) {\n        validateField(fieldKey, value, false);\n      }\n    },\n    [setFieldValue, state.touched, validateField]\n  );\n\n  const handleFieldBlur = useCallback(\n    (fieldKey: string) =&gt; {\n      markFieldTouched(fieldKey);\n      validateField(fieldKey, state.formData[fieldKey], true);\n    },\n    [markFieldTouched, state.formData, validateField]\n  );\n\n  const autosaveFingerprint = useMemo(\n    () =&gt; JSON.stringify({ data: state.formData, step: state.currentStep }),\n    [state.formData, state.currentStep]\n  );\n\n  const runDraftSave = useCallback(() =&gt; {\n    return saveFormDraft({\n      formConfigId: formConfig.id,\n      organizationId,\n      entityId: formConfig.entityId,\n      geographyId: formConfig.geographyId,\n      applicationId,\n      formData: state.formData,\n      currentStep: state.currentStep,\n    });\n  }, [\n    applicationId,\n    formConfig.entityId,\n    formConfig.geographyId,\n    formConfig.id,\n    organizationId,\n    state.currentStep,\n    state.formData,\n  ]);\n\n  const {\n    status: draftStatus,\n    isSaving: isSavingDraft,\n    lastSavedAt,\n    error: draftError,\n    triggerSave,\n  } = useAutosave&lt;DraftSaveResult&gt;({\n    shouldAutosave: state.isDirty,\n    dataFingerprint: autosaveFingerprint,\n    save: runDraftSave,\n    onSuccess: (result) =&gt; {\n      markClean();\n      if (result.applicationId &amp;&amp; result.applicationId !== applicationId) {\n        onApplicationIdChange?.(result.applicationId);\n      }\n      onDraftSaved?.(result);\n    },\n    onError: (error) =&gt; {\n      toast({\n        variant: \&quot;destructive\&quot;,\n        title: \&quot;Draft save failed\&quot;,\n        description: error.message,\n      });\n    },\n  });\n\n  const handleNext = useCallback(async () =&gt; {\n    if (state.isSubmitting) {\n      return;\n    }\n\n    const validation = validateAndCommitStep(state.currentStep);\n    if (!validation.isValid) {\n      toast({\n        variant: \&quot;destructive\&quot;,\n        title: \&quot;Please fix validation errors\&quot;,\n        description: \&quot;Resolve highlighted fields before continuing.\&quot;,\n      });\n      focusFirstError(validation.firstErrorField);\n      return;\n    }\n\n    markStepComplete(state.currentStep);\n\n    if (isLastStep &amp;&amp; onComplete) {\n      try {\n        setIsSubmitting(true);\n        await onComplete(state.formData);\n        toast({\n          title: \&quot;Form submitted\&quot;,\n          description: \&quot;Thank you! We received your information.\&quot;,\n        });\n      } catch (error) {\n        toast({\n          variant: \&quot;destructive\&quot;,\n          title: \&quot;Submission failed\&quot;,\n          description:\n            error instanceof Error\n              ? error.message\n              : \&quot;Something went wrong while submitting. Please try again.\&quot;,\n        });\n      } finally {\n        setIsSubmitting(false);\n      }\n      return;\n    }\n\n    const nextStep = state.currentStep + 1;\n    goToStep(nextStep);\n    onStepChange?.(nextStep);\n    void triggerSave(\&quot;step-change\&quot;);\n  }, [\n    focusFirstError,\n    goToStep,\n    isLastStep,\n    markStepComplete,\n    onComplete,\n    onStepChange,\n    setIsSubmitting,\n    state.currentStep,\n    state.formData,\n    state.isSubmitting,\n    toast,\n    triggerSave,\n    validateAndCommitStep,\n  ]);\n\n  const handlePrevious = useCallback(() =&gt; {\n    if (isFirstStep) {\n      return;\n    }\n    const prevStep = state.currentStep - 1;\n    goToStep(prevStep);\n    onStepChange?.(prevStep);\n  }, [goToStep, isFirstStep, onStepChange, state.currentStep]);\n\n  const handleStepClick = useCallback(\n    (stepIndex: number) =&gt; {\n      if (stepIndex === state.currentStep) {\n        return;\n      }\n\n      const validation = validateAndCommitStep(state.currentStep);\n      if (!validation.isValid) {\n        toast({\n          variant: \&quot;destructive\&quot;,\n          title: \&quot;Cannot leave step yet\&quot;,\n          description: \&quot;Fix validation errors before moving on.\&quot;,\n        });\n        focusFirstError(validation.firstErrorField);\n        return;\n      }\n\n      if (\n        state.completedSteps.has(stepIndex) ||\n        stepIndex === state.currentStep + 1\n      ) {\n        goToStep(stepIndex);\n        onStepChange?.(stepIndex);\n        void triggerSave(\&quot;step-change\&quot;);\n      }\n    },\n    [\n      focusFirstError,\n      goToStep,\n      onStepChange,\n      state.completedSteps,\n      state.currentStep,\n      toast,\n      triggerSave,\n      validateAndCommitStep,\n    ]\n  );\n\n  const handleManualSave = useCallback(() =&gt; {\n    void triggerSave(\&quot;manual\&quot;);\n  }, [triggerSave]);\n\n  useEffect(() =&gt; {\n    return () =&gt; {\n      Object.values(validationTimersRef.current).forEach((timer) =&gt; {\n        clearTimeout(timer);\n      });\n    };\n  }, []);\n\n  useEffect(() =&gt; {\n    const sectionLabel = currentSection?.label ?? &#96;Step ${state.currentStep + 1}&#96;;\n    setLiveMessage(\n      &#96;Now viewing ${sectionLabel} (${state.currentStep + 1} of ${totalSteps})&#96;\n    );\n  }, [currentSection, state.currentStep, totalSteps]);\n\n  const progress =\n    totalSteps &gt; 0 ? ((state.currentStep + 1) / totalSteps) * 100 : 0;\n\n  return (\n    &lt;div className=\&quot;flex flex-col gap-6 pb-32 sm:pb-12\&quot;&gt;\n      &lt;StepIndicator\n        steps={sortedSections.map((section) =&gt; ({\n          id: section.id,\n          label: section.label,\n          order: section.order,\n        }))}\n        currentStep={state.currentStep}\n        completedSteps={state.completedSteps}\n        onStepClick={handleStepClick}\n      /&gt;\n\n      &lt;div\n        className={cn(\n          \&quot;min-h-[400px] space-y-6 rounded-3xl border border-border/60 bg-background/70 p-4 shadow-lg sm:p-8\&quot;,\n          !prefersReducedMotion &amp;&amp; \&quot;transition-shadow duration-300\&quot;\n        )}\n      &gt;\n        {(() =&gt; {\n          const stepFieldKeys = getStepFieldKeys(state.currentStep, formConfig);\n          const stepErrors: Record&lt;string, string&gt; = {};\n          stepFieldKeys.forEach((key) =&gt; {\n            if (state.errors[key] &amp;&amp; touchedMap[key]) {\n              stepErrors[key] = state.errors[key];\n            }\n          });\n\n          if (Object.keys(stepErrors).length &gt; 0) {\n            return (\n              &lt;FormErrorSummary\n                errors={stepErrors}\n                onErrorClick={(fieldKey) =&gt; focusFirstError(fieldKey)}\n              /&gt;\n            );\n          }\n          return null;\n        })()}\n\n        {currentSection &amp;&amp; (\n          &lt;FormStep\n            section={currentSection}\n            formData={state.formData}\n            errors={state.errors}\n            touched={touchedMap}\n            onFieldChange={handleFieldChange}\n            onFieldBlur={handleFieldBlur}\n          /&gt;\n        )}\n      &lt;/div&gt;\n\n      &lt;FormNavigation\n        isFirstStep={isFirstStep}\n        isLastStep={isLastStep}\n        onNext={handleNext}\n        onPrevious={handlePrevious}\n        onSaveDraft={handleManualSave}\n        progress={progress}\n        isSubmitting={state.isSubmitting}\n        isSavingDraft={isSavingDraft}\n        draftStatus={draftStatus}\n        draftError={draftError}\n        lastSavedAt={lastSavedAt}\n      /&gt;\n      &lt;p role=\&quot;status\&quot; aria-live=\&quot;polite\&quot; className=\&quot;sr-only\&quot;&gt;\n        {liveMessage}\n      &lt;/p&gt;\n    &lt;/div&gt;\n  );\n}\n\&quot;use client\&quot;;\n\nimport { useCallback, useEffect, useMemo, useRef, useState } from \&quot;react\&quot;;\nimport type { FormConfigWithFields } from \&quot;@/lib/forms/types\&quot;;\nimport { getStepFieldKeys } from \&quot;@/lib/forms/form-validator\&quot;;\nimport { buildFormSchema } from \&quot;@/lib/form-schema\&quot;;\nimport { saveFormDraft, type DraftSaveResult } from \&quot;@/app/forms/actions\&quot;;\nimport { StepIndicator } from \&quot;./step-indicator\&quot;;\nimport { FormStep } from \&quot;./form-step\&quot;;\nimport { FormNavigation } from \&quot;./form-navigation\&quot;;\nimport { FormErrorSummary } from \&quot;./form-error-summary\&quot;;\nimport { useFormState } from \&quot;@/hooks/use-form-state\&quot;;\nimport { useAutosave } from \&quot;@/hooks/use-autosave\&quot;;\nimport { useToast } from \&quot;@/components/ui/use-toast\&quot;;\nimport { usePrefersReducedMotion } from \&quot;@/hooks/use-prefers-reduced-motion\&quot;;\nimport { cn } from \&quot;@/lib/utils\&quot;;\n\ninterface DynamicFormWizardProps {\n  formConfig: FormConfigWithFields;\n  initialData?: Record&lt;string, unknown&gt;;\n  initialStep?: number;\n  applicationId: string | null;\n  organizationId: string;\n  onApplicationIdChange?: (applicationId: string) =&gt; void;\n  onDraftSaved?: (result: DraftSaveResult) =&gt; void;\n  onStepChange?: (stepIndex: number) =&gt; void;\n  onComplete?: (formData: Record&lt;string, unknown&gt;) =&gt; Promise&lt;void&gt; | void;\n}\n\nexport function DynamicFormWizard({\n  formConfig,\n  initialData = {},\n  initialStep = 0,\n  applicationId,\n  organizationId,\n  onApplicationIdChange,\n  onDraftSaved,\n  onStepChange,\n  onComplete,\n}: DynamicFormWizardProps) {\n  const sortedSections = useMemo(\n    () =&gt; [...formConfig.sections].sort((a, b) =&gt; a.order - b.order),\n    [formConfig.sections]\n  );\n\n  const {\n    state,\n    touchedMap,\n    setFieldValue,\n    markFieldTouched,\n    markFieldsTouched,\n    setFieldError,\n    setStepErrors,\n    goToStep,\n    markStepComplete,\n    setIsSubmitting,\n    markClean,\n    validateAndCommitStep,\n  } = useFormState({\n    formConfig,\n    initialData,\n    initialStep,\n  });\n\n  const [liveMessage, setLiveMessage] = useState(\&quot;\&quot;);\n  const validationTimersRef = useRef&lt;Record&lt;string, NodeJS.Timeout&gt;&gt;({});\n  const formSchemaRef = useRef(buildFormSchema(formConfig));\n  const prefersReducedMotion = usePrefersReducedMotion();\n  const { toast } = useToast();\n\n  const totalSteps = sortedSections.length;\n  const currentSection = sortedSections[state.currentStep];\n  const isFirstStep = state.currentStep === 0;\n  const isLastStep = state.currentStep === totalSteps - 1;\n\n  useEffect(() =&gt; {\n    formSchemaRef.current = buildFormSchema(formConfig);\n  }, [formConfig]);\n\n  const focusFirstError = useCallback(\n    (fieldKey?: string) =&gt; {\n      if (!fieldKey || !currentSection) {\n        return;\n      }\n      const errorField = currentSection.fields.find((field) =&gt; field.key === fieldKey);\n      const fieldElement = errorField\n        ? document.getElementById(&#96;field-${errorField.id}&#96;)\n        : null;\n      fieldElement?.focus();\n      fieldElement?.scrollIntoView({ behavior: \&quot;smooth\&quot;, block: \&quot;center\&quot; });\n    },\n    [currentSection]\n  );\n\n  const validateField = useCallback(\n    (fieldKey: string, value: unknown, immediate = false) =&gt; {\n      if (validationTimersRef.current[fieldKey]) {\n        clearTimeout(validationTimersRef.current[fieldKey]);\n      }\n\n      const performValidation = () =&gt; {\n        const fieldSchema = formSchemaRef.current.shape[fieldKey];\n        if (!fieldSchema) {\n          return;\n        }\n\n        try {\n          fieldSchema.parse(value);\n          setFieldError(fieldKey);\n        } catch (error) {\n          if (error &amp;&amp; typeof error === \&quot;object\&quot; &amp;&amp; \&quot;issues\&quot; in error) {\n            const zodError = error as { issues: Array&lt;{ message: string }&gt; };\n            const firstIssue = zodError.issues[0];\n            if (firstIssue) {\n              setFieldError(fieldKey, firstIssue.message);\n            }\n          } else if (error instanceof Error) {\n            setFieldError(fieldKey, error.message);\n          }\n        }\n      };\n\n      if (immediate) {\n        performValidation();\n      } else {\n        validationTimersRef.current[fieldKey] = setTimeout(performValidation, 300);\n      }\n    },\n    [setFieldError]\n  );\n\n  const handleFieldChange = useCallback(\n    (fieldKey: string, value: unknown) =&gt; {\n      setFieldValue(fieldKey, value);\n      if (state.touched.has(fieldKey)) {\n        validateField(fieldKey, value, false);\n      }\n    },\n    [setFieldValue, state.touched, validateField]\n  );\n\n  const handleFieldBlur = useCallback(\n    (fieldKey: string) =&gt; {\n      markFieldTouched(fieldKey);\n      validateField(fieldKey, state.formData[fieldKey], true);\n    },\n    [markFieldTouched, state.formData, validateField]\n  );\n\n  const autosaveFingerprint = useMemo(\n    () =&gt; JSON.stringify({ data: state.formData, step: state.currentStep }),\n    [state.formData, state.currentStep]\n  );\n\n  const runDraftSave = useCallback(() =&gt; {\n    return saveFormDraft({\n      formConfigId: formConfig.id,\n      organizationId,\n      entityId: formConfig.entityId,\n      geographyId: formConfig.geographyId,\n      applicationId,\n      formData: state.formData,\n      currentStep: state.currentStep,\n    });\n  }, [\n    applicationId,\n    formConfig.entityId,\n    formConfig.geographyId,\n    formConfig.id,\n    organizationId,\n    state.currentStep,\n    state.formData,\n  ]);\n\n  const {\n    status: draftStatus,\n    isSaving: isSavingDraft,\n    lastSavedAt,\n    error: draftError,\n    triggerSave,\n  } = useAutosave&lt;DraftSaveResult&gt;({\n    shouldAutosave: state.isDirty,\n    dataFingerprint: autosaveFingerprint,\n    save: runDraftSave,\n    onSuccess: (result) =&gt; {\n      markClean();\n      if (result.applicationId &amp;&amp; result.applicationId !== applicationId) {\n        onApplicationIdChange?.(result.applicationId);\n      }\n      onDraftSaved?.(result);\n    },\n    onError: (error) =&gt; {\n      toast({\n        variant: \&quot;destructive\&quot;,\n        title: \&quot;Draft save failed\&quot;,\n        description: error.message,\n      });\n    },\n  });\n\n  const handleNext = useCallback(async () =&gt; {\n    if (state.isSubmitting) {\n      return;\n    }\n\n    const validation = validateAndCommitStep(state.currentStep);\n    if (!validation.isValid) {\n      toast({\n        variant: \&quot;destructive\&quot;,\n        title: \&quot;Please fix validation errors\&quot;,\n        description: \&quot;Resolve highlighted fields before continuing.\&quot;,\n      });\n      focusFirstError(validation.firstErrorField);\n      return;\n    }\n\n    markStepComplete(state.currentStep);\n\n    if (isLastStep &amp;&amp; onComplete) {\n      try {\n        setIsSubmitting(true);\n        await onComplete(state.formData);\n        toast({\n          title: \&quot;Form submitted\&quot;,\n          description: \&quot;Thank you! We received your information.\&quot;,\n        });\n      } catch (error) {\n        toast({\n          variant: \&quot;destructive\&quot;,\n          title: \&quot;Submission failed\&quot;,\n          description:\n            error instanceof Error\n              ? error.message\n              : \&quot;Something went wrong while submitting. Please try again.\&quot;,\n        });\n      } finally {\n        setIsSubmitting(false);\n      }\n      return;\n    }\n\n    const nextStep = state.currentStep + 1;\n    goToStep(nextStep);\n    onStepChange?.(nextStep);\n    void triggerSave(\&quot;step-change\&quot;);\n  }, [\n    focusFirstError,\n    goToStep,\n    isLastStep,\n    markStepComplete,\n    onComplete,\n    onStepChange,\n    setIsSubmitting,\n    state.currentStep,\n    state.formData,\n    state.isSubmitting,\n    toast,\n    triggerSave,\n    validateAndCommitStep,\n  ]);\n\n  const handlePrevious = useCallback(() =&gt; {\n    if (isFirstStep) {\n      return;\n    }\n    const prevStep = state.currentStep - 1;\n    goToStep(prevStep);\n    onStepChange?.(prevStep);\n  }, [goToStep, isFirstStep, onStepChange, state.currentStep]);\n\n  const handleStepClick = useCallback(\n    (stepIndex: number) =&gt; {\n      if (stepIndex === state.currentStep) {\n        return;\n      }\n\n      const validation = validateAndCommitStep(state.currentStep);\n      if (!validation.isValid) {\n        toast({\n          variant: \&quot;destructive\&quot;,\n          title: \&quot;Cannot leave step yet\&quot;,\n          description: \&quot;Fix validation errors before moving on.\&quot;,\n        });\n        focusFirstError(validation.firstErrorField);\n        return;\n      }\n\n      if (\n        state.completedSteps.has(stepIndex) ||\n        stepIndex === state.currentStep + 1\n      ) {\n        goToStep(stepIndex);\n        onStepChange?.(stepIndex);\n        void triggerSave(\&quot;step-change\&quot;);\n      }\n    },\n    [\n      focusFirstError,\n      goToStep,\n      onStepChange,\n      state.completedSteps,\n      state.currentStep,\n      toast,\n      triggerSave,\n      validateAndCommitStep,\n    ]\n  );\n\n  const handleManualSave = useCallback(() =&gt; {\n    void triggerSave(\&quot;manual\&quot;);\n  }, [triggerSave]);\n\n  useEffect(() =&gt; {\n    const timers = validationTimersRef.current;\n    return () =&gt; {\n      Object.values(timers).forEach((timer) =&gt; {\n        clearTimeout(timer);\n      });\n    };\n  }, []);\n\n  useEffect(() =&gt; {\n    const sectionLabel = currentSection?.label ?? &#96;Step ${state.currentStep + 1}&#96;;\n    setLiveMessage(\n      &#96;Now viewing ${sectionLabel} (${state.currentStep + 1} of ${totalSteps})&#96;\n    );\n  }, [currentSection, state.currentStep, totalSteps]);\n\n  const progress =\n    totalSteps &gt; 0 ? ((state.currentStep + 1) / totalSteps) * 100 : 0;\n\n  return (\n    &lt;div className=\&quot;flex flex-col gap-6 pb-32 sm:pb-12\&quot;&gt;\n      &lt;StepIndicator\n        steps={sortedSections.map((section) =&gt; ({\n          id: section.id,\n          label: section.label,\n          order: section.order,\n        }))}\n        currentStep={state.currentStep}\n        completedSteps={state.completedSteps}\n        onStepClick={handleStepClick}\n      /&gt;\n\n      &lt;div\n        className={cn(\n          \&quot;min-h-[400px] space-y-6 rounded-3xl border border-border/60 bg-background/70 p-4 shadow-lg sm:p-8\&quot;,\n          !prefersReducedMotion &amp;&amp; \&quot;transition-shadow duration-300\&quot;\n        )}\n      &gt;\n        {(() =&gt; {\n          const stepFieldKeys = getStepFieldKeys(state.currentStep, formConfig);\n          const stepErrors: Record&lt;string, string&gt; = {};\n          stepFieldKeys.forEach((key) =&gt; {\n            if (state.errors[key] &amp;&amp; touchedMap[key]) {\n              stepErrors[key] = state.errors[key];\n            }\n          });\n\n          if (Object.keys(stepErrors).length &gt; 0) {\n            return (\n              &lt;FormErrorSummary\n                errors={stepErrors}\n                onErrorClick={(fieldKey) =&gt; focusFirstError(fieldKey)}\n              /&gt;\n            );\n          }\n          return null;\n        })()}\n\n        {currentSection &amp;&amp; (\n          &lt;FormStep\n            section={currentSection}\n            formData={state.formData}\n            errors={state.errors}\n            touched={touchedMap}\n            onFieldChange={handleFieldChange}\n            onFieldBlur={handleFieldBlur}\n          /&gt;\n        )}\n      &lt;/div&gt;\n\n      &lt;FormNavigation\n        isFirstStep={isFirstStep}\n        isLastStep={isLastStep}\n        onNext={handleNext}\n        onPrevious={handlePrevious}\n        onSaveDraft={handleManualSave}\n        progress={progress}\n        isSubmitting={state.isSubmitting}\n        isSavingDraft={isSavingDraft}\n        draftStatus={draftStatus}\n        draftError={draftError}\n        lastSavedAt={lastSavedAt}\n      /&gt;\n      &lt;p role=\&quot;status\&quot; aria-live=\&quot;polite\&quot; className=\&quot;sr-only\&quot;&gt;\n        {liveMessage}\n      &lt;/p&gt;\n    &lt;/div&gt;\n  );\n}\n\&quot;use client\&quot;;\n\nimport { useState, useCallback, useRef, useEffect } from \&quot;react\&quot;;\nimport type { FormConfigWithFields } from \&quot;@/lib/forms/types\&quot;;\nimport { validateStep, getStepFieldKeys } from \&quot;@/lib/forms/form-validator\&quot;;\nimport { buildFormSchema } from \&quot;@/lib/form-schema\&quot;;\nimport { StepIndicator } from \&quot;./step-indicator\&quot;;\nimport { FormStep } from \&quot;./form-step\&quot;;\nimport { FormNavigation } from \&quot;./form-navigation\&quot;;\nimport { FormErrorSummary } from \&quot;./form-error-summary\&quot;;\nimport { usePrefersReducedMotion } from \&quot;@/hooks/use-prefers-reduced-motion\&quot;;\nimport { useToast } from \&quot;@/components/ui/use-toast\&quot;;\nimport { cn } from \&quot;@/lib/utils\&quot;;\nimport type { DraftStatus } from \&quot;./draft-save-indicator\&quot;;\n\ninterface DynamicFormWizardProps {\n  formConfig: FormConfigWithFields;\n  initialData?: Record&lt;string, unknown&gt;;\n  onStepChange?: (stepIndex: number) =&gt; void;\n  onComplete?: (formData: Record&lt;string, unknown&gt;) =&gt; void;\n  onSaveDraft?: (formData: Record&lt;string, unknown&gt;) =&gt; void;\n}\n\nexport function DynamicFormWizard({\n  formConfig,\n  initialData = {},\n  onStepChange,\n  onComplete,\n  onSaveDraft,\n}: DynamicFormWizardProps) {\n  const sortedSections = [...formConfig.sections].sort(\n    (a, b) =&gt; a.order - b.order\n  );\n\n  const [currentStep, setCurrentStep] = useState(0);\n  const [formData, setFormData] = useState&lt;Record&lt;string, unknown&gt;&gt;(\n    initialData\n  );\n  const [completedSteps, setCompletedSteps] = useState&lt;Set&lt;number&gt;&gt;(\n    new Set()\n  );\n  const [errors, setErrors] = useState&lt;Record&lt;string, string&gt;&gt;({});\n  const [touched, setTouched] = useState&lt;Record&lt;string, boolean&gt;&gt;({});\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  const [isSavingDraft, setIsSavingDraft] = useState(false);\n  const [draftStatus, setDraftStatus] = useState&lt;DraftStatus&gt;(\&quot;idle\&quot;);\n  const [draftError, setDraftError] = useState&lt;string | null&gt;(null);\n  const [lastSavedAt, setLastSavedAt] = useState&lt;Date | null&gt;(null);\n  const [liveMessage, setLiveMessage] = useState(\&quot;\&quot;);\n  const validationTimersRef = useRef&lt;Record&lt;string, NodeJS.Timeout&gt;&gt;({});\n  const formSchemaRef = useRef(buildFormSchema(formConfig));\n  const prefersReducedMotion = usePrefersReducedMotion();\n  const { toast } = useToast();\n\n  const totalSteps = sortedSections.length;\n  const currentSection = sortedSections[currentStep];\n  const isFirstStep = currentStep === 0;\n  const isLastStep = currentStep === totalSteps - 1;\n\n  // Rebuild schema if form config changes\n  useEffect(() =&gt; {\n    formSchemaRef.current = buildFormSchema(formConfig);\n  }, [formConfig]);\n\n  /**\n   * Validate a single field with debouncing\n   */\n  const validateField = useCallback(\n    (fieldKey: string, value: unknown, immediate = false) =&gt; {\n      // Clear existing timer for this field\n      if (validationTimersRef.current[fieldKey]) {\n        clearTimeout(validationTimersRef.current[fieldKey]);\n      }\n\n      const performValidation = () =&gt; {\n        const fieldSchema = formSchemaRef.current.shape[fieldKey];\n        if (!fieldSchema) {\n          return;\n        }\n\n        try {\n          fieldSchema.parse(value);\n          // Clear error if validation passes\n          setErrors((prev) =&gt; {\n            const next = { ...prev };\n            delete next[fieldKey];\n            return next;\n          });\n        } catch (error) {\n          if (error &amp;&amp; typeof error === \&quot;object\&quot; &amp;&amp; \&quot;issues\&quot; in error) {\n            const zodError = error as { issues: Array&lt;{ message: string }&gt; };\n            const firstIssue = zodError.issues[0];\n            if (firstIssue) {\n              setErrors((prev) =&gt; ({\n                ...prev,\n                [fieldKey]: firstIssue.message,\n              }));\n            }\n          } else if (error instanceof Error) {\n            setErrors((prev) =&gt; ({\n              ...prev,\n              [fieldKey]: error.message,\n            }));\n          }\n        }\n      };\n\n      if (immediate) {\n        performValidation();\n      } else {\n        // Debounce validation on change (300ms)\n        validationTimersRef.current[fieldKey] = setTimeout(performValidation, 300);\n      }\n    },\n    []\n  );\n\n  const handleFieldChange = useCallback(\n    (fieldKey: string, value: unknown) =&gt; {\n      setFormData((prev) =&gt; ({\n        ...prev,\n        [fieldKey]: value,\n      }));\n\n      // Validate on change with debounce (only if field has been touched)\n      if (touched[fieldKey]) {\n        validateField(fieldKey, value, false);\n      }\n    },\n    [touched, validateField]\n  );\n\n  const handleFieldBlur = useCallback(\n    (fieldKey: string) =&gt; {\n      setTouched((prev) =&gt; ({\n        ...prev,\n        [fieldKey]: true,\n      }));\n\n      // Validate immediately on blur\n      const value = formData[fieldKey];\n      validateField(fieldKey, value, true);\n    },\n    [formData, validateField]\n  );\n\n  /**\n   * Validate current step using the validation utilities\n   */\n  const validateCurrentStep = useCallback((): boolean =&gt; {\n    const stepResult = validateStep(currentStep, formData, formConfig);\n\n    if (!stepResult.isValid) {\n      // Update errors for current step fields only\n      const stepFieldKeys = getStepFieldKeys(currentStep, formConfig);\n      setErrors((prev) =&gt; {\n        const next = { ...prev };\n        // Clear errors for fields not in current step\n        stepFieldKeys.forEach((key) =&gt; {\n          if (stepResult.errors[key]) {\n            next[key] = stepResult.errors[key];\n          } else {\n            delete next[key];\n          }\n        });\n        return next;\n      });\n\n      // Mark all fields in step as touched\n      setTouched((prev) =&gt; {\n        const next = { ...prev };\n        stepFieldKeys.forEach((key) =&gt; {\n          next[key] = true;\n        });\n        return next;\n      });\n\n      // Focus first error field\n      if (stepResult.firstErrorField) {\n        // Find the field by key to get its ID\n        const errorField = currentSection.fields.find(\n          (f) =&gt; f.key === stepResult.firstErrorField\n        );\n        if (errorField) {\n          // Field components use &#96;field-${field.id}&#96; as the ID\n          const fieldElement = document.getElementById(&#96;field-${errorField.id}&#96;);\n          if (fieldElement) {\n            fieldElement.focus();\n            fieldElement.scrollIntoView({ behavior: \&quot;smooth\&quot;, block: \&quot;center\&quot; });\n          }\n        }\n      }\n    }\n\n    return stepResult.isValid;\n  }, [currentStep, formData, formConfig, currentSection]);\n\n  const handleNext = useCallback(async () =&gt; {\n    if (isSubmitting) {\n      return;\n    }\n\n    const isStepValid = validateCurrentStep();\n    if (!isStepValid) {\n      toast({\n        variant: \&quot;destructive\&quot;,\n        title: \&quot;Please fix validation errors\&quot;,\n        description: \&quot;Resolve highlighted fields before continuing.\&quot;,\n      });\n      return;\n    }\n\n    setCompletedSteps((prev) =&gt; new Set(prev).add(currentStep));\n\n    if (isLastStep) {\n      if (!onComplete) {\n        return;\n      }\n      try {\n        setIsSubmitting(true);\n        await onComplete(formData);\n        toast({\n          title: \&quot;Form submitted\&quot;,\n          description: \&quot;Thanks! We received your information.\&quot;,\n        });\n      } catch (error) {\n        toast({\n          variant: \&quot;destructive\&quot;,\n          title: \&quot;Submission failed\&quot;,\n          description:\n            error instanceof Error\n              ? error.message\n              : \&quot;Something went wrong while submitting. Please try again.\&quot;,\n        });\n      } finally {\n        setIsSubmitting(false);\n      }\n    } else {\n      const nextStep = currentStep + 1;\n      setCurrentStep(nextStep);\n      onStepChange?.(nextStep);\n    }\n  }, [\n    currentStep,\n    formData,\n    isLastStep,\n    isSubmitting,\n    onComplete,\n    onStepChange,\n    toast,\n    validateCurrentStep,\n  ]);\n\n  const handlePrevious = useCallback(() =&gt; {\n    if (!isFirstStep) {\n      const prevStep = currentStep - 1;\n      setCurrentStep(prevStep);\n      onStepChange?.(prevStep);\n    }\n  }, [currentStep, isFirstStep, onStepChange]);\n\n  const handleStepClick = useCallback(\n    (stepIndex: number) =&gt; {\n      // Validate current step before allowing navigation\n      if (stepIndex !== currentStep) {\n        if (!validateCurrentStep()) {\n          return; // Don&#39;t allow navigation if current step is invalid\n        }\n      }\n\n      // Allow navigation to completed steps or the next step\n      if (completedSteps.has(stepIndex) || stepIndex === currentStep + 1) {\n        setCurrentStep(stepIndex);\n        onStepChange?.(stepIndex);\n      }\n    },\n    [completedSteps, currentStep, onStepChange, validateCurrentStep]\n  );\n\n  const handleSaveDraft = useCallback(async () =&gt; {\n    if (!onSaveDraft || isSavingDraft) {\n      return;\n    }\n    try {\n      setIsSavingDraft(true);\n      setDraftStatus(\&quot;saving\&quot;);\n      setDraftError(null);\n      await onSaveDraft(formData);\n      setDraftStatus(\&quot;success\&quot;);\n      const savedAt = new Date();\n      setLastSavedAt(savedAt);\n      toast({\n        title: \&quot;Draft saved\&quot;,\n        description: &#96;Progress saved at ${savedAt.toLocaleTimeString([], {\n          hour: \&quot;numeric\&quot;,\n          minute: \&quot;2-digit\&quot;,\n        })}&#96;,\n      });\n    } catch (error) {\n      setDraftStatus(\&quot;error\&quot;);\n      const message =\n        error instanceof Error\n          ? error.message\n          : \&quot;Unable to save your draft right now.\&quot;;\n      setDraftError(message);\n      toast({\n        variant: \&quot;destructive\&quot;,\n        title: \&quot;Draft not saved\&quot;,\n        description: message,\n      });\n    } finally {\n      setIsSavingDraft(false);\n    }\n  }, [formData, isSavingDraft, onSaveDraft, toast]);\n\n  // Cleanup timers on unmount\n  useEffect(() =&gt; {\n    const timers = validationTimersRef.current;\n    return () =&gt; {\n      Object.values(timers).forEach((timer) =&gt; {\n        clearTimeout(timer);\n      });\n    };\n  }, []);\n\n  const progress = totalSteps &gt; 0 ? ((currentStep + 1) / totalSteps) * 100 : 0;\n\n  useEffect(() =&gt; {\n    const sectionLabel = currentSection?.label ?? &#96;Step ${currentStep + 1}&#96;;\n    setLiveMessage(&#96;Now viewing ${sectionLabel} (${currentStep + 1} of ${totalSteps})&#96;);\n  }, [currentSection, currentStep, totalSteps]);\n\n  return (\n    &lt;div className=\&quot;flex flex-col gap-6 pb-32 sm:pb-12\&quot;&gt;\n      &lt;StepIndicator\n        steps={sortedSections.map((section, index) =&gt; ({\n          id: section.id,\n          label: section.label,\n          order: section.order,\n        }))}\n        currentStep={currentStep}\n        completedSteps={completedSteps}\n        onStepClick={handleStepClick}\n      /&gt;\n\n      &lt;div\n        className={cn(\n          \&quot;min-h-[400px] space-y-6 rounded-3xl border border-border/60 bg-background/70 p-4 shadow-lg sm:p-8\&quot;,\n          !prefersReducedMotion &amp;&amp; \&quot;transition-shadow duration-300\&quot;\n        )}\n      &gt;\n        {/* Error summary for current step */}\n        {(() =&gt; {\n          const stepFieldKeys = getStepFieldKeys(currentStep, formConfig);\n          const stepErrors: Record&lt;string, string&gt; = {};\n          stepFieldKeys.forEach((key) =&gt; {\n            if (errors[key] &amp;&amp; touched[key]) {\n              stepErrors[key] = errors[key];\n            }\n          });\n\n          if (Object.keys(stepErrors).length &gt; 0) {\n            return (\n              &lt;FormErrorSummary\n                errors={stepErrors}\n                onErrorClick={(fieldKey) =&gt; {\n                  // Find the field by key to get its ID\n                  const errorField = currentSection.fields.find(\n                    (f) =&gt; f.key === fieldKey\n                  );\n                  if (errorField) {\n                    // Field components use &#96;field-${field.id}&#96; as the ID\n                    const fieldElement = document.getElementById(&#96;field-${errorField.id}&#96;);\n                    if (fieldElement) {\n                      fieldElement.focus();\n                      fieldElement.scrollIntoView({\n                        behavior: \&quot;smooth\&quot;,\n                        block: \&quot;center\&quot;,\n                      });\n                    }\n                  }\n                }}\n              /&gt;\n            );\n          }\n          return null;\n        })()}\n\n        &lt;FormStep\n          section={currentSection}\n          formData={formData}\n          errors={errors}\n          touched={touched}\n          onFieldChange={handleFieldChange}\n          onFieldBlur={handleFieldBlur}\n        /&gt;\n      &lt;/div&gt;\n\n      &lt;FormNavigation\n        isFirstStep={isFirstStep}\n        isLastStep={isLastStep}\n        onNext={handleNext}\n        onPrevious={handlePrevious}\n        onSaveDraft={handleSaveDraft}\n        progress={progress}\n        isSubmitting={isSubmitting}\n        isSavingDraft={isSavingDraft}\n        draftStatus={draftStatus}\n        draftError={draftError}\n        lastSavedAt={lastSavedAt}\n      /&gt;\n      &lt;p role=\&quot;status\&quot; aria-live=\&quot;polite\&quot; className=\&quot;sr-only\&quot;&gt;\n        {liveMessage}\n      &lt;/p&gt;\n    &lt;/div&gt;\n  );\n}\n\n&quot;
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Verifying single "use client" occurrence**</details></think>

---

<tool-use data-tool-type="grep" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for ""use client"" in "/Users/sahilmehta/supplier-onboarding-simple/components/forms/dynamic-form-wizard.tsx" • 4 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `components/forms/dynamic-form-wizard.tsx` | `"use client";` | L1 |
| `components/forms/dynamic-form-wizard.tsx` | `"use client";` | L401 |
| `components/forms/dynamic-form-wizard.tsx` | `"use client";` | L801 |
| `components/forms/dynamic-form-wizard.tsx` | `"use client";` | L1202 |


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Analyzing duplicate file content issue**</details></think>

---

<tool-use data-tool-type="bash" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **command** • Run command: cd /Users/sahilmehta/supplier-onboarding-simple && rm components/forms/dynamic-form-wizard.tsx</summary>

```bash
cd /Users/sahilmehta/supplier-onboarding-simple && rm components/forms/dynamic-form-wizard.tsx
```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Preparing command to create file with cat**</details></think>

---

<tool-use data-tool-type="bash" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **command** • Run command: cd /Users/sahilmehta/supplier-onboarding-simple && cat <<'EOF' > components/forms/dynamic-form-wizard.tsx
"use client";

import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import type { FormConfigWithFields } from "@/lib/forms/types";
import { getStepFieldKeys } from "@/lib/forms/form-validator";
import { buildFormSchema } from "@/lib/form-schema";
import { saveFormDraft, type DraftSaveResult } from "@/app/forms/actions";
import { StepIndicator } from "./step-indicator";
import { FormStep } from "./form-step";
import { FormNavigation } from "./form-navigation";
import { FormErrorSummary } from "./form-error-summary";
import { useFormState } from "@/hooks/use-form-state";
import { useAutosave } from "@/hooks/use-autosave";
import { useToast } from "@/components/ui/use-toast";
import { usePrefersReducedMotion } from "@/hooks/use-prefers-reduced-motion";
import { cn } from "@/lib/utils";

interface DynamicFormWizardProps {
  formConfig: FormConfigWithFields;
  initialData?: Record<string, unknown>;
  initialStep?: number;
  applicationId: string | null;
  organizationId: string;
  onApplicationIdChange?: (applicationId: string) => void;
  onDraftSaved?: (result: DraftSaveResult) => void;
  onStepChange?: (stepIndex: number) => void;
  onComplete?: (formData: Record<string, unknown>) => Promise<void> | void;
}

export function DynamicFormWizard({
  formConfig,
  initialData = {},
  initialStep = 0,
  applicationId,
  organizationId,
  onApplicationIdChange,
  onDraftSaved,
  onStepChange,
  onComplete,
}: DynamicFormWizardProps) {
  const sortedSections = useMemo(
    () => [...formConfig.sections].sort((a, b) => a.order - b.order),
    [formConfig.sections]
  );

  const {
    state,
    touchedMap,
    setFieldValue,
    markFieldTouched,
    markFieldsTouched,
    setFieldError,
    setStepErrors,
    goToStep,
    markStepComplete,
    setIsSubmitting,
    markClean,
    validateAndCommitStep,
  } = useFormState({
    formConfig,
    initialData,
    initialStep,
  });

  const [liveMessage, setLiveMessage] = useState("");
  const validationTimersRef = useRef<Record<string, NodeJS.Timeout>>({});
  const formSchemaRef = useRef(buildFormSchema(formConfig));
  const prefersReducedMotion = usePrefersReducedMotion();
  const { toast } = useToast();

  const totalSteps = sortedSections.length;
  const currentSection = sortedSections[state.currentStep];
  const isFirstStep = state.currentStep === 0;
  const isLastStep = state.currentStep === totalSteps - 1;

  useEffect(() => {
    formSchemaRef.current = buildFormSchema(formConfig);
  }, [formConfig]);

  const focusFirstError = useCallback(
    (fieldKey?: string) => {
      if (!fieldKey || !currentSection) {
        return;
      }
      const errorField = currentSection.fields.find((field) => field.key === fieldKey);
      const fieldElement = errorField
        ? document.getElementById(`field-${errorField.id}`)
        : null;
      fieldElement?.focus();
      fieldElement?.scrollIntoView({ behavior: "smooth", block: "center" });
    },
    [currentSection]
  );

  const validateField = useCallback(
    (fieldKey: string, value: unknown, immediate = false) => {
      if (validationTimersRef.current[fieldKey]) {
        clearTimeout(validationTimersRef.current[fieldKey]);
      }

      const performValidation = () => {
        const fieldSchema = formSchemaRef.current.shape[fieldKey];
        if (!fieldSchema) {
          return;
        }

        try {
          fieldSchema.parse(value);
          setFieldError(fieldKey);
        } catch (error) {
          if (error && typeof error === "object" && "issues" in error) {
            const zodError = error as { issues: Array<{ message: string }> };
            const firstIssue = zodError.issues[0];
            if (firstIssue) {
              setFieldError(fieldKey, firstIssue.message);
            }
          } else if (error instanceof Error) {
            setFieldError(fieldKey, error.message);
          }
        }
      };

      if (immediate) {
        performValidation();
      } else {
        validationTimersRef.current[fieldKey] = setTimeout(performValidation, 300);
      }
    },
    [setFieldError]
  );

  const handleFieldChange = useCallback(
    (fieldKey: string, value: unknown) => {
      setFieldValue(fieldKey, value);
      if (state.touched.has(fieldKey)) {
        validateField(fieldKey, value, false);
      }
    },
    [setFieldValue, state.touched, validateField]
  );

  const handleFieldBlur = useCallback(
    (fieldKey: string) => {
      markFieldTouched(fieldKey);
      validateField(fieldKey, state.formData[fieldKey], true);
    },
    [markFieldTouched, state.formData, validateField]
  );

  const autosaveFingerprint = useMemo(
    () => JSON.stringify({ data: state.formData, step: state.currentStep }),
    [state.formData, state.currentStep]
  );

  const runDraftSave = useCallback(() => {
    return saveFormDraft({
      formConfigId: formConfig.id,
      organizationId,
      entityId: formConfig.entityId,
      geographyId: formConfig.geographyId,
      applicationId,
      formData: state.formData,
      currentStep: state.currentStep,
    });
  }, [
    applicationId,
    formConfig.entityId,
    formConfig.geographyId,
    formConfig.id,
    organizationId,
    state.currentStep,
    state.formData,
  ]);

  const {
    status: draftStatus,
    isSaving: isSavingDraft,
    lastSavedAt,
    error: draftError,
    triggerSave,
  } = useAutosave<DraftSaveResult>({
    shouldAutosave: state.isDirty,
    dataFingerprint: autosaveFingerprint,
    save: runDraftSave,
    onSuccess: (result) => {
      markClean();
      if (result.applicationId && result.applicationId !== applicationId) {
        onApplicationIdChange?.(result.applicationId);
      }
      onDraftSaved?.(result);
    },
    onError: (error) => {
      toast({
        variant: "destructive",
        title: "Draft save failed",
        description: error.message,
      });
    },
  });

  const handleNext = useCallback(async () => {
    if (state.isSubmitting) {
      return;
    }

    const validation = validateAndCommitStep(state.currentStep);
    if (!validation.isValid) {
      toast({
        variant: "destructive",
        title: "Please fix validation errors",
        description: "Resolve highlighted fields before continuing.",
      });
      focusFirstError(validation.firstErrorField);
      return;
    }

    markStepComplete(state.currentStep);

    if (isLastStep && onComplete) {
      try {
        setIsSubmitting(true);
        await onComplete(state.formData);
        toast({
          title: "Form submitted",
          description: "Thank you! We received your information.",
        });
      } catch (error) {
        toast({
          variant: "destructive",
          title: "Submission failed",
          description:
            error instanceof Error
              ? error.message
              : "Something went wrong while submitting. Please try again.",
        });
      } finally {
        setIsSubmitting(false);
      }
      return;
    }

    const nextStep = state.currentStep + 1;
    goToStep(nextStep);
    onStepChange?.(nextStep);
    void triggerSave("step-change");
  }, [
    focusFirstError,
    goToStep,
    isLastStep,
    markStepComplete,
    onComplete,
    onStepChange,
    setIsSubmitting,
    state.currentStep,
    state.formData,
    state.isSubmitting,
    toast,
    triggerSave,
    validateAndCommitStep,
  ]);

  const handlePrevious = useCallback(() => {
    if (isFirstStep) {
      return;
    }
    const prevStep = state.currentStep - 1;
    goToStep(prevStep);
    onStepChange?.(prevStep);
  }, [goToStep, isFirstStep, onStepChange, state.currentStep]);

  const handleStepClick = useCallback(
    (stepIndex: number) => {
      if (stepIndex === state.currentStep) {
        return;
      }

      const validation = validateAndCommitStep(state.currentStep);
      if (!validation.isValid) {
        toast({
          variant: "destructive",
          title: "Cannot leave step yet",
          description: "Fix validation errors before moving on.",
        });
        focusFirstError(validation.firstErrorField);
        return;
      }

      if (
        state.completedSteps.has(stepIndex) ||
        stepIndex === state.currentStep + 1
      ) {
        goToStep(stepIndex);
        onStepChange?.(stepIndex);
        void triggerSave("step-change");
      }
    },
    [
      focusFirstError,
      goToStep,
      onwe'll break due to length]}</summary>

```bash
cd /Users/sahilmehta/supplier-onboarding-simple && cat <<'EOF' > components/forms/dynamic-form-wizard.tsx
"use client";

import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import type { FormConfigWithFields } from "@/lib/forms/types";
import { getStepFieldKeys } from "@/lib/forms/form-validator";
import { buildFormSchema } from "@/lib/form-schema";
import { saveFormDraft, type DraftSaveResult } from "@/app/forms/actions";
import { StepIndicator } from "./step-indicator";
import { FormStep } from "./form-step";
import { FormNavigation } from "./form-navigation";
import { FormErrorSummary } from "./form-error-summary";
import { useFormState } from "@/hooks/use-form-state";
import { useAutosave } from "@/hooks/use-autosave";
import { useToast } from "@/components/ui/use-toast";
import { usePrefersReducedMotion } from "@/hooks/use-prefers-reduced-motion";
import { cn } from "@/lib/utils";

interface DynamicFormWizardProps {
  formConfig: FormConfigWithFields;
  initialData?: Record<string, unknown>;
  initialStep?: number;
  applicationId: string | null;
  organizationId: string;
  onApplicationIdChange?: (applicationId: string) => void;
  onDraftSaved?: (result: DraftSaveResult) => void;
  onStepChange?: (stepIndex: number) => void;
  onComplete?: (formData: Record<string, unknown>) => Promise<void> | void;
}

export function DynamicFormWizard({
  formConfig,
  initialData = {},
  initialStep = 0,
  applicationId,
  organizationId,
  onApplicationIdChange,
  onDraftSaved,
  onStepChange,
  onComplete,
}: DynamicFormWizardProps) {
  const sortedSections = useMemo(
    () => [...formConfig.sections].sort((a, b) => a.order - b.order),
    [formConfig.sections]
  );

  const {
    state,
    touchedMap,
    setFieldValue,
    markFieldTouched,
    markFieldsTouched,
    setFieldError,
    setStepErrors,
    goToStep,
    markStepComplete,
    setIsSubmitting,
    markClean,
    validateAndCommitStep,
  } = useFormState({
    formConfig,
    initialData,
    initialStep,
  });

  const [liveMessage, setLiveMessage] = useState("");
  const validationTimersRef = useRef<Record<string, NodeJS.Timeout>>({});
  const formSchemaRef = useRef(buildFormSchema(formConfig));
  const prefersReducedMotion = usePrefersReducedMotion();
  const { toast } = useToast();

  const totalSteps = sortedSections.length;
  const currentSection = sortedSections[state.currentStep];
  const isFirstStep = state.currentStep === 0;
  const isLastStep = state.currentStep === totalSteps - 1;

  useEffect(() => {
    formSchemaRef.current = buildFormSchema(formConfig);
  }, [formConfig]);

  const focusFirstError = useCallback(
    (fieldKey?: string) => {
      if (!fieldKey || !currentSection) {
        return;
      }
      const errorField = currentSection.fields.find((field) => field.key === fieldKey);
      const fieldElement = errorField
        ? document.getElementById(`field-${errorField.id}`)
        : null;
      fieldElement?.focus();
      fieldElement?.scrollIntoView({ behavior: "smooth", block: "center" });
    },
    [currentSection]
  );

  const validateField = useCallback(
    (fieldKey: string, value: unknown, immediate = false) => {
      if (validationTimersRef.current[fieldKey]) {
        clearTimeout(validationTimersRef.current[fieldKey]);
      }

      const performValidation = () => {
        const fieldSchema = formSchemaRef.current.shape[fieldKey];
        if (!fieldSchema) {
          return;
        }

        try {
          fieldSchema.parse(value);
          setFieldError(fieldKey);
        } catch (error) {
          if (error && typeof error === "object" && "issues" in error) {
            const zodError = error as { issues: Array<{ message: string }> };
            const firstIssue = zodError.issues[0];
            if (firstIssue) {
              setFieldError(fieldKey, firstIssue.message);
            }
          } else if (error instanceof Error) {
            setFieldError(fieldKey, error.message);
          }
        }
      };

      if (immediate) {
        performValidation();
      } else {
        validationTimersRef.current[fieldKey] = setTimeout(performValidation, 300);
      }
    },
    [setFieldError]
  );

  const handleFieldChange = useCallback(
    (fieldKey: string, value: unknown) => {
      setFieldValue(fieldKey, value);
      if (state.touched.has(fieldKey)) {
        validateField(fieldKey, value, false);
      }
    },
    [setFieldValue, state.touched, validateField]
  );

  const handleFieldBlur = useCallback(
    (fieldKey: string) => {
      markFieldTouched(fieldKey);
      validateField(fieldKey, state.formData[fieldKey], true);
    },
    [markFieldTouched, state.formData, validateField]
  );

  const autosaveFingerprint = useMemo(
    () => JSON.stringify({ data: state.formData, step: state.currentStep }),
    [state.formData, state.currentStep]
  );

  const runDraftSave = useCallback(() => {
    return saveFormDraft({
      formConfigId: formConfig.id,
      organizationId,
      entityId: formConfig.entityId,
      geographyId: formConfig.geographyId,
      applicationId,
      formData: state.formData,
      currentStep: state.currentStep,
    });
  }, [
    applicationId,
    formConfig.entityId,
    formConfig.geographyId,
    formConfig.id,
    organizationId,
    state.currentStep,
    state.formData,
  ]);

  const {
    status: draftStatus,
    isSaving: isSavingDraft,
    lastSavedAt,
    error: draftError,
    triggerSave,
  } = useAutosave<DraftSaveResult>({
    shouldAutosave: state.isDirty,
    dataFingerprint: autosaveFingerprint,
    save: runDraftSave,
    onSuccess: (result) => {
      markClean();
      if (result.applicationId && result.applicationId !== applicationId) {
        onApplicationIdChange?.(result.applicationId);
      }
      onDraftSaved?.(result);
    },
    onError: (error) => {
      toast({
        variant: "destructive",
        title: "Draft save failed",
        description: error.message,
      });
    },
  });

  const handleNext = useCallback(async () => {
    if (state.isSubmitting) {
      return;
    }

    const validation = validateAndCommitStep(state.currentStep);
    if (!validation.isValid) {
      toast({
        variant: "destructive",
        title: "Please fix validation errors",
        description: "Resolve highlighted fields before continuing.",
      });
      focusFirstError(validation.firstErrorField);
      return;
    }

    markStepComplete(state.currentStep);

    if (isLastStep && onComplete) {
      try {
        setIsSubmitting(true);
        await onComplete(state.formData);
        toast({
          title: "Form submitted",
          description: "Thank you! We received your information.",
        });
      } catch (error) {
        toast({
          variant: "destructive",
          title: "Submission failed",
          description:
            error instanceof Error
              ? error.message
              : "Something went wrong while submitting. Please try again.",
        });
      } finally {
        setIsSubmitting(false);
      }
      return;
    }

    const nextStep = state.currentStep + 1;
    goToStep(nextStep);
    onStepChange?.(nextStep);
    void triggerSave("step-change");
  }, [
    focusFirstError,
    goToStep,
    isLastStep,
    markStepComplete,
    onComplete,
    onStepChange,
    setIsSubmitting,
    state.currentStep,
    state.formData,
    state.isSubmitting,
    toast,
    triggerSave,
    validateAndCommitStep,
  ]);

  const handlePrevious = useCallback(() => {
    if (isFirstStep) {
      return;
    }
    const prevStep = state.currentStep - 1;
    goToStep(prevStep);
    onStepChange?.(prevStep);
  }, [goToStep, isFirstStep, onStepChange, state.currentStep]);

  const handleStepClick = useCallback(
    (stepIndex: number) => {
      if (stepIndex === state.currentStep) {
        return;
      }

      const validation = validateAndCommitStep(state.currentStep);
      if (!validation.isValid) {
        toast({
          variant: "destructive",
          title: "Cannot leave step yet",
          description: "Fix validation errors before moving on.",
        });
        focusFirstError(validation.firstErrorField);
        return;
      }

      if (
        state.completedSteps.has(stepIndex) ||
        stepIndex === state.currentStep + 1
      ) {
        goToStep(stepIndex);
        onStepChange?.(stepIndex);
        void triggerSave("step-change");
      }
    },
    [
      focusFirstError,
      goToStep,
      onwe'll break due to length]}
```

```
sahilmehta@tests-MacBook-Pro supplier-onboarding-simple % &gt;....                 
    (stepIndex: number) =&gt; {
      if (stepIndex === state.currentStep) {
        return;
      }

      const validation = validateAndCommitStep(state.currentStep);
      if (!validation.isValid) {
        toast({
          variant: &quot;destructive&quot;,
          title: &quot;Cannot leave step yet&quot;,
          description: &quot;Fix validation errors before moving on.&quot;,
        });
        focusFirstError(validation.firstErrorField);
        return;
      }

      if (
        state.completedSteps.has(stepIndex) ||
        stepIndex === state.currentStep + 1
      ) {
        goToStep(stepIndex);
        onStepChange?.(stepIndex);
        void triggerSave(&quot;step-change&quot;);
      }
    },
    [
      focusFirstError,
      goToStep,
      onwe&#39;ll break due to length]}
cmdand heredoc&gt; 
```
</details>
</tool-use>

---

_**User (2025-11-17 23:03Z)**_



---

_**Agent (model default, mode Agent)**_



---

<think><details><summary>Thought Process</summary>
**Reviewing project structure and pending tasks**</details></think>

---

<tool-use data-tool-type="generic" data-tool-name="list_dir">
<details>
            <summary>Tool use: **list_directory** • Listed directory undefined • **0** results</summary>
        
No results found
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Reviewing TODO list and documentation**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/sahilmehta/supplier-onboarding-simple/docs/agent-stream-5-state-draft.md</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Reviewing route pages structure**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/sahilmehta/supplier-onboarding-simple/app/forms/[entityCode]/[geographyCode]/page.tsx</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Adding dynamic route for formConfigId**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/sahilmehta/supplier-onboarding-simple/app/forms/[formConfigId]/page.tsx</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Inspecting form wizard client for integration**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/sahilmehta/supplier-onboarding-simple/components/forms/form-wizard-client.tsx</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Checking formConfig type for updates**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/sahilmehta/supplier-onboarding-simple/lib/forms/types.ts</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Verifying type consistency for touched state**</details></think>

---

<tool-use data-tool-type="bash" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **command** • Run command: cd /Users/sahilmehta/supplier-onboarding-simple && git status -sb</summary>

```bash
cd /Users/sahilmehta/supplier-onboarding-simple && git status -sb
```

```
## main
 M .specstory/history/2025-11-11_07-30Z-setup-next-js-project-with-postgres-and-authentication.md                                                               
 M README.md
 M app/layout.tsx
 M app/page.tsx
 M app/signin/page.tsx
 M eslint.config.mjs
 M lib/auth.ts
 M package-lock.json
 M package.json
 M prisma/schema.prisma
 M prisma/seed.ts
 M tsconfig.json
 M types/next-auth.d.ts
?? .specstory/history/2025-11-17_06-13Z-critical-security-vulnerabilities-in-dependencies.md                                                                    
?? .specstory/history/2025-11-17_08-56Z-unable-to-login-due-to-infinite-loop.md
?? .specstory/history/2025-11-17_09-59Z-fix-missing-database-column-error.md
?? .specstory/history/2025-11-17_11-11Z-create-script-for-unimacts-entity.md
?? .specstory/history/2025-11-17_11-23Z-improve-configuration-menu-structure.md
?? .specstory/history/2025-11-17_11-55Z-addressing-critical-vulnerability-in-next-package.md                                                                    
?? .specstory/history/2025-11-17_12-01Z-how-to-view-unx-entity-form.md
?? .specstory/history/2025-11-18_05-22Z-have-we-built-the-ui-and-routes.md
?? .specstory/history/2025-11-18_06-18Z-execute-agent-stream-field-rendering.md
?? .specstory/history/2025-11-18_06-18Z-execute-authentication-routes-plan.md
?? .specstory/history/2025-11-18_06-19Z-execute-command-in-agent-stream.md
?? .specstory/history/2025-11-18_06-19Z-execute-validation-task.md
?? .specstory/history/2025-11-18_06-25Z-integrate-completed-workstreams-together.md                                                                             
?? .specstory/history/2025-11-18_06-57Z-implement-conditional-fields-and-update-status.md                                                                       
?? .specstory/history/2025-11-18_06-57Z-implement-draft-and-update-status.md
?? .specstory/history/2025-11-18_06-59Z-execute-plan-and-update-status.md
?? app/(marketing)/
?? app/api/configuration/
?? app/api/documents/
?? app/api/users/
?? app/dashboard/
?? app/forms/
?? app/settings/
?? app/supplier/
?? app/users/
?? components/admin/
?? components/forms/
?? components/navigation/admin-config-nav.tsx
?? components/navigation/app-sidebar.tsx
?? components/procurement/
?? components/providers/sidebar-provider.tsx
?? components/supplier/
?? components/ui/accordion.tsx
?? components/ui/dialog.tsx
?? components/ui/input.tsx
?? components/ui/label.tsx
?? components/ui/progress.tsx
?? components/ui/select.tsx
?? components/ui/sheet.tsx
?? components/ui/sidebar.tsx
?? components/ui/table.tsx
?? components/ui/toast.tsx
?? components/ui/toaster.tsx
?? components/ui/tooltip.tsx
?? components/ui/use-toast.ts
?? components/users/
?? docs/
?? hooks/
?? lib/admin-api.ts
?? lib/application-state.ts
?? lib/form-schema.ts
?? lib/forms/
?? lib/organizations.ts
?? lib/permissions.ts
?? lib/supplierWizardSchema.ts
?? prisma/migrations/20251117090000_align_membership_role_values/
?? prisma/migrations/20251117120000_add_org_freshdesk_columns/
?? prisma/migrations/20251117125500_sync_schema_core_tables/
?? scripts/
?? supplier_capabilities/
?? tests/
?? vitest.config.ts
```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Confirming form hooking tasks**</details></think>

---

<tool-use data-tool-type="grep" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "DraftResumeDialog" in "/Users/sahilmehta/supplier-onboarding-simple" • 4 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `./components/forms/draft-resume-dialog.tsx` | `interface DraftResumeDialogProps \{` | L17 |
| `./components/forms/draft-resume-dialog.tsx` | `export function DraftResumeDialog(\{` | L26 |
| `./components/forms/draft-resume-dialog.tsx` | `\}: DraftResumeDialogProps) \{` | L33 |
| `./docs/agent-stream-5-state-draft.md` | `**Create `DraftResumeDialog`:**` | L177 |


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Planning draft integration and data fetching**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/sahilmehta/supplier-onboarding-simple/lib/forms/draft-manager.ts</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Planning to align FormState interface**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/sahilmehta/supplier-onboarding-simple/lib/forms/form-state.ts</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Verifying createInitialFormState usage**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/sahilmehta/supplier-onboarding-simple/hooks/use-form-state.ts</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Planning draft data integration**

I'm figuring out how to load and pass initial draft data into the form wizard component, considering fetching drafts server-side to supply `initialData`, `initialStep`, and `applicationId`. I want to clarify how to obtain keys like `organizationId` from the form config or schema to properly support multiple drafts and enable the resume draft dialog feature on the client.</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/sahilmehta/supplier-onboarding-simple/prisma/schema.prisma</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Checking FormConfig fields**</details></think>

---

<tool-use data-tool-type="grep" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "model FormConfig" in "/Users/sahilmehta/supplier-onboarding-simple/prisma/schema.prisma" • 1 match</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `prisma/schema.prisma` | `model FormConfig \{` | L141 |


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Investigating organizationId source**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/sahilmehta/supplier-onboarding-simple/components/supplier/wizard-form.tsx</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Planning updates for FormWizardClient**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/sahilmehta/supplier-onboarding-simple/components/forms/dynamic-form-wizard.tsx</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Planning FormWizardClient cleanup and server hook investigation**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/sahilmehta/supplier-onboarding-simple/app/forms/actions.ts</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Planning draft listing and loading**

I'm figuring out how to add a new server action to list drafts since the current server doesn’t expose that. It looks like pages running on the server can call functions like `listDraftSummaries` directly, but I need to ensure membership checks get handled properly, maybe reusing or replicating `ensureMembership`. I also want to automatically load the latest draft on form mount by fetching summaries first and then loading full data for the initial state. I'll need to figure out how to get the organization context, probably from session membership, and I'll check existing code patterns to confirm.</details></think>

---

<tool-use data-tool-type="grep" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "organizationId" in "/Users/sahilmehta/supplier-onboarding-simple/app/forms" • 10 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `app/forms/actions.ts` | `organizationId: string;` | L14 |
| `app/forms/actions.ts` | `organizationId: string;` | L32 |
| `app/forms/actions.ts` | `async function ensureMembership(userId: string, organizationId: string) \{` | L38 |
| `app/forms/actions.ts` | `where: \{ userId, organizationId \},` | L40 |
| `app/forms/actions.ts` | `await ensureMembership(session.user.id, input.organizationId);` | L57 |
| `app/forms/actions.ts` | `organizationId: input.organizationId,` | L62 |
| `app/forms/actions.ts` | `await ensureMembership(session.user.id, input.organizationId);` | L86 |
| `app/forms/actions.ts` | `organizationId: input.organizationId,` | L90 |
| `app/forms/actions.ts` | `await ensureMembership(session.user.id, input.organizationId);` | L103 |
| `app/forms/actions.ts` | `organizationId: input.organizationId,` | L106 |


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Investigating organization ID source**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/sahilmehta/supplier-onboarding-simple/types/next-auth.d.ts</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Investigating organization roles handling**</details></think>

---

<tool-use data-tool-type="grep" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "organizationRoles" in "/Users/sahilmehta/supplier-onboarding-simple" • 15 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `./app/dashboard/admin/actions.ts` | `const userRole = session.user.organizationRoles.find(` | L51 |
| `./supplier_capabilities/tests/auth-session.test.ts` | `organizationRoles: [],` | L27 |
| `./supplier_capabilities/tests/auth-session.test.ts` | `organizationRoles: mockRoles,` | L34 |
| `./supplier_capabilities/tests/auth-session.test.ts` | `expect(result?.user.organizationRoles).toEqual(mockRoles);` | L47 |
| `./docs/auth-rbac.md` | `- `jwt` callback loads membership roles on initial sign-in and stores as `token.organizationRoles`.` | L7 |
| `./docs/auth-rbac.md` | `- `session` callback exposes `session.user.organizationRoles` for layouts/components.` | L8 |
| `./docs/auth-rbac.md` | `organizationRoles: Array<\{ organizationId: string; role: MembershipRole \}>` | L27 |
| `./lib/auth.ts` | `token.organizationRoles = memberships.map((membership) => (\{` | L59 |
| `./lib/auth.ts` | `if (token?.organizationRoles) \{` | L89 |
| `./lib/auth.ts` | `session.user.organizationRoles = token.organizationRoles as Array<\{` | L90 |
| `./lib/auth.ts` | `session.user.organizationRoles = [];` | L98 |
| `./lib/auth.ts` | `session.user.organizationRoles = memberships.map((membership) => (\{` | L110 |
| `./docs/phase-1-core-data-auth.md` | `- `session.user` contains `id`, `organizationRoles` for use across layouts. ✅ Session typings updated in `types/next-auth.d.ts`.` | L32 |
| `./types/next-auth.d.ts` | `organizationRoles: OrganizationRoleClaim[];` | L12 |
| `./types/next-auth.d.ts` | `organizationRoles?: OrganizationRoleClaim[];` | L19 |


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Investigating organization selection**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/sahilmehta/supplier-onboarding-simple/lib/application-state.ts</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Investigating Entity model in Prisma**</details></think>

---

<tool-use data-tool-type="grep" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "model Entity" in "/Users/sahilmehta/supplier-onboarding-simple/prisma/schema.prisma" • 2 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `prisma/schema.prisma` | `model Entity \{` | L106 |
| `prisma/schema.prisma` | `model EntityGeography \{` | L129 |


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Checking Organization model**</details></think>

---

<tool-use data-tool-type="grep" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "model Organization" in "/Users/sahilmehta/supplier-onboarding-simple/prisma/schema.prisma" • 1 match</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `prisma/schema.prisma` | `model Organization \{` | L77 |


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Evaluating organizationId sourcing**</details></think>

---

<tool-use data-tool-type="grep" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "const.*organizationId" in "/Users/sahilmehta/supplier-onboarding-simple" • 5 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `./app/dashboard/admin/actions.ts` | `const organizationId = formData.get("integration-org") as string;` | L30 |
| `./lib/permissions.ts` | `const membership = await getCurrentUserMembership(organizationId);` | L37 |
| `./lib/permissions.ts` | `const isUserAdmin = await isAdmin(organizationId);` | L48 |
| `./lib/permissions.ts` | `const membership = await getCurrentUserMembership(organizationId);` | L58 |
| `./app/api/users/invite/route.ts` | `const \{ email, role, organizationId \} = body;` | L26 |


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Checking supplier onboarding page**</details></think>

---

Could not find file '/Users/sahilmehta/supplier-onboarding-simple/app/supplier/onboarding/page.tsx' in the workspace.

---

<think><details><summary>Thought Process</summary>
**Checking app/supplier/onboarding contents**</details></think>

---

<tool-use data-tool-type="generic" data-tool-name="list_dir">
<details>
            <summary>Tool use: **list_directory** • Listed directory undefined • **0** results</summary>
        
No results found
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Opening specific page**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/sahilmehta/supplier-onboarding-simple/app/supplier/onboarding/[id]/page.tsx</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Investigating FormWizardClient usage**</details></think>

---

<tool-use data-tool-type="grep" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "FormWizardClient" in "/Users/sahilmehta/supplier-onboarding-simple" • 11 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `./app/forms/[formConfigId]/page.tsx` | `import \{ FormWizardClient \} from "@/components/forms/form-wizard-client";` | L5 |
| `./app/forms/[formConfigId]/page.tsx` | `<FormWizardClient formConfig=\{formConfig\} />` | L52 |
| `./components/forms/form-wizard-client.tsx` | `interface FormWizardClientProps \{` | L6 |
| `./components/forms/form-wizard-client.tsx` | `export function FormWizardClient(\{ formConfig \}: FormWizardClientProps) \{` | L14 |
| `./app/forms/[entityCode]/[geographyCode]/page.tsx` | `import \{ FormWizardClient \} from "@/components/forms/form-wizard-client";` | L5 |
| `./app/forms/[entityCode]/[geographyCode]/page.tsx` | `<FormWizardClient formConfig=\{formConfig\} />` | L51 |
| `./docs/agent-orchestrator.md` | `- ✅ FormWizardClient wrapper for server/client boundary` | L238 |
| `./docs/agent-orchestrator.md` | `5. ✅ Created `FormWizardClient` wrapper component to handle server/client component boundary` | L268 |
| `./docs/streams-1-4-verification-report.md` | `- ✅ Routes pass form config to `FormWizardClient`` | L34 |
| `./docs/streams-1-4-verification-report.md` | `- ✅ FormWizardClient wrapper handles server/client boundary` | L100 |
| `./docs/streams-1-4-verification-report.md` | `- Routes fetch form config and pass to FormWizardClient` | L145 |


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Updating task statuses**</details></think>

---

<tool-use data-tool-type="generic" data-tool-name="todo_write">
<details><summary>Tool use: **todo_write** • Todo List</summary>

- [x] Review Stream 5 requirements and inspect current form wizard/state logic
- [x] Implement shared form state + draft persistence libs/hooks
- [-] Integrate autosave and draft UI into form components/routes
- [ ] Add server actions + route draft loading, update docs status

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Outlining detailed form draft resume implementation**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/sahilmehta/supplier-onboarding-simple/components/forms/draft-resume-dialog.tsx</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Detailing draft integration plan**</details></think>

---

<tool-use data-tool-type="grep" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "FormWizardState" in "/Users/sahilmehta/supplier-onboarding-simple" • 2 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `./lib/forms/types.ts` | `export interface FormWizardState \{` | L62 |
| `./docs/dynamic-form-rendering-prd.md` | `interface FormWizardState \{` | L256 |


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Planning comprehensive form wizard updates**

This involves updating form state handling and UI components to support draft loading, resetting, and resuming, including safe step clamping, managing draft lists, and integrating dialogs for draft resumption, all while ensuring data serialization and state synchronization between server and client. I’m working through how to handle draft loading, saving, deletion, and reset behaviors in the client with proper hooks and effects, also considering user organization validation and error handling.
**Coordinating draft loading, server updates, and documentation**

I'm planning to disable form editing while loading drafts to prevent conflicts and manage state consistency, then updating server pages to fetch and serialize draft data properly. I’ll also handle updating documentation status after implementation and plan targeted linting and tests to verify changes before finalizing everything.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  &quot;relativeWorkspacePath&quot;: &quot;lib/forms/types.ts&quot;
}
```
Additional data:

```json
{
  &quot;codeblockId&quot;: &quot;2aae896d-4098-468d-9893-57d5d4e370ea&quot;,
  &quot;reviewData&quot;: {
    &quot;status&quot;: &quot;None&quot;,
    &quot;selectedOption&quot;: &quot;accept&quot;,
    &quot;isShowingInput&quot;: false,
    &quot;firstTimeReviewMode&quot;: false
  }
}
```
Result:

```json
{
  &quot;diff&quot;: {
    &quot;chunks&quot;: [
      {
        &quot;diffString&quot;: &quot;    formData: Record&lt;string, unknown&gt;;\n    errors: Record&lt;string, string&gt;;\n-   touched: Record&lt;string, boolean&gt;;\n+   touched: Set&lt;string&gt;;\n    completedSteps: Set&lt;number&gt;;\n    isDirty: boolean;&quot;,
        &quot;oldStart&quot;: 64,
        &quot;newStart&quot;: 64,
        &quot;oldLines&quot;: 5,
        &quot;newLines&quot;: 5,
        &quot;linesRemoved&quot;: 1,
        &quot;linesAdded&quot;: 1
      }
    ],
    &quot;editor&quot;: &quot;EDITOR_AI&quot;
  },
  &quot;shouldAutoFixLints&quot;: true,
  &quot;resultForModel&quot;: &quot;Success. Updated the following files:\nM lib/forms/types.ts&quot;,
  &quot;contentsAfterEdit&quot;: &quot;/**\n * Shared type definitions for dynamic form rendering system\n * Used across all implementation streams\n */\n\nimport type {\n  DocumentType,\n  FormConfig,\n  FormDocumentRequirement,\n  FormField,\n  FormSection,\n  Entity,\n  Geography,\n} from \&quot;@prisma/client\&quot;;\n\n/**\n * Form configuration with nested sections and fields\n */\nexport type FormConfigWithFields = FormConfig &amp; {\n  sections: (FormSection &amp; { fields: FormField[] })[];\n  documentRules: (FormDocumentRequirement &amp; { documentType: DocumentType })[];\n  entity: Entity;\n  geography: Geography;\n};\n\n/**\n * Field rendering configuration\n */\nexport interface FieldRenderConfig {\n  key: string;\n  label: string;\n  type: string;\n  placeholder?: string;\n  helpText?: string;\n  required: boolean;\n  options?: { values: string[] };\n  validation?: {\n    min?: number;\n    max?: number;\n    pattern?: string;\n    minLength?: number;\n    maxLength?: number;\n  };\n  visibility?: {\n    dependsOn: string;\n    condition:\n      | \&quot;equals\&quot;\n      | \&quot;notEquals\&quot;\n      | \&quot;contains\&quot;\n      | \&quot;greaterThan\&quot;\n      | \&quot;lessThan\&quot;\n      | \&quot;isEmpty\&quot;\n      | \&quot;isNotEmpty\&quot;;\n    value: unknown;\n  };\n  isSensitive: boolean;\n}\n\n/**\n * Form wizard state\n */\nexport interface FormWizardState {\n  currentStep: number;\n  formData: Record&lt;string, unknown&gt;;\n  errors: Record&lt;string, string&gt;;\n  touched: Set&lt;string&gt;;\n  completedSteps: Set&lt;number&gt;;\n  isDirty: boolean;\n  isSubmitting: boolean;\n}\n\n/**\n * Visibility rule for conditional fields\n */\nexport interface VisibilityRule {\n  dependsOn: string; // Field key\n  condition:\n    | \&quot;equals\&quot;\n    | \&quot;notEquals\&quot;\n    | \&quot;contains\&quot;\n    | \&quot;greaterThan\&quot;\n    | \&quot;lessThan\&quot;\n    | \&quot;isEmpty\&quot;\n    | \&quot;isNotEmpty\&quot;;\n  value: unknown;\n}\n\n&quot;
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Updating form state initialization**</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  &quot;relativeWorkspacePath&quot;: &quot;lib/forms/form-state.ts&quot;
}
```
Additional data:

```json
{
  &quot;codeblockId&quot;: &quot;bed213ec-2151-4a15-893d-289596808ce8&quot;,
  &quot;reviewData&quot;: {
    &quot;status&quot;: &quot;None&quot;,
    &quot;selectedOption&quot;: &quot;accept&quot;,
    &quot;isShowingInput&quot;: false,
    &quot;firstTimeReviewMode&quot;: false
  }
}
```
Result:

```json
{
  &quot;diff&quot;: {
    &quot;chunks&quot;: [
      {
        &quot;diffString&quot;: &quot;    initialStep = 0\n  ): FormState {\n+   const normalizedStep =\n+     Number.isFinite(initialStep) &amp;&amp; initialStep &gt; 0\n+       ? Math.floor(initialStep)\n+       : 0;\n+ \n    return {\n      formData: initialData,\n      touched: new Set(),\n      errors: {},\n-     currentStep: initialStep,\n+     currentStep: normalizedStep,\n      completedSteps:\n-       initialStep &gt; 0\n-         ? new Set(Array.from({ length: initialStep }, (_, index) =&gt; index))\n+       normalizedStep &gt; 0\n+         ? new Set(Array.from({ length: normalizedStep }, (_, index) =&gt; index))\n          : new Set(),\n-     isDirty: Object.keys(initialData).length &gt; 0,\n+     isDirty: false,\n      isSubmitting: false,\n    };&quot;,
        &quot;oldStart&quot;: 23,
        &quot;newStart&quot;: 23,
        &quot;oldLines&quot;: 14,
        &quot;newLines&quot;: 19,
        &quot;linesRemoved&quot;: 4,
        &quot;linesAdded&quot;: 9
      }
    ],
    &quot;editor&quot;: &quot;EDITOR_AI&quot;
  },
  &quot;shouldAutoFixLints&quot;: true,
  &quot;resultForModel&quot;: &quot;Success. Updated the following files:\nM lib/forms/form-state.ts&quot;,
  &quot;contentsAfterEdit&quot;: &quot;export interface FormState {\n  formData: Record&lt;string, unknown&gt;;\n  touched: Set&lt;string&gt;;\n  errors: Record&lt;string, string&gt;;\n  currentStep: number;\n  completedSteps: Set&lt;number&gt;;\n  isDirty: boolean;\n  isSubmitting: boolean;\n}\n\nexport interface SerializedFormState {\n  formData: Record&lt;string, unknown&gt;;\n  touched: string[];\n  errors: Record&lt;string, string&gt;;\n  currentStep: number;\n  completedSteps: number[];\n  isDirty: boolean;\n  isSubmitting: boolean;\n}\n\nexport function createInitialFormState(\n  initialData: Record&lt;string, unknown&gt; = {},\n  initialStep = 0\n): FormState {\n  const normalizedStep =\n    Number.isFinite(initialStep) &amp;&amp; initialStep &gt; 0\n      ? Math.floor(initialStep)\n      : 0;\n\n  return {\n    formData: initialData,\n    touched: new Set(),\n    errors: {},\n    currentStep: normalizedStep,\n    completedSteps:\n      normalizedStep &gt; 0\n        ? new Set(Array.from({ length: normalizedStep }, (_, index) =&gt; index))\n        : new Set(),\n    isDirty: false,\n    isSubmitting: false,\n  };\n}\n\nexport function serializeFormState(state: FormState): SerializedFormState {\n  return {\n    formData: state.formData,\n    errors: state.errors,\n    currentStep: state.currentStep,\n    isDirty: state.isDirty,\n    isSubmitting: state.isSubmitting,\n    touched: Array.from(state.touched),\n    completedSteps: Array.from(state.completedSteps),\n  };\n}\n\nexport function hydrateFormState(\n  snapshot: Partial&lt;SerializedFormState&gt;\n): FormState {\n  return {\n    formData: snapshot.formData ?? {},\n    errors: snapshot.errors ?? {},\n    currentStep: snapshot.currentStep ?? 0,\n    isDirty: snapshot.isDirty ?? false,\n    isSubmitting: snapshot.isSubmitting ?? false,\n    touched: new Set(snapshot.touched ?? []),\n    completedSteps: new Set(snapshot.completedSteps ?? []),\n  };\n}\n\n&quot;
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Updating form state reducer and reset action**</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  &quot;relativeWorkspacePath&quot;: &quot;hooks/use-form-state.ts&quot;
}
```
Additional data:

```json
{
  &quot;codeblockId&quot;: &quot;f6502037-eac2-48f3-be8c-02798caff22d&quot;,
  &quot;reviewData&quot;: {
    &quot;status&quot;: &quot;None&quot;,
    &quot;selectedOption&quot;: &quot;accept&quot;,
    &quot;isShowingInput&quot;: false,
    &quot;firstTimeReviewMode&quot;: false
  }
}
```
Result:

```json
{
  &quot;diff&quot;: {
    &quot;chunks&quot;: [
      {
        &quot;diffString&quot;: &quot;    | { type: \&quot;MARK_STEP_COMPLETE\&quot;; step: number }\n    | { type: \&quot;SET_SUBMITTING\&quot;; value: boolean }\n-   | { type: \&quot;SET_DIRTY\&quot;; value: boolean };\n+   | { type: \&quot;SET_DIRTY\&quot;; value: boolean }\n+   | { type: \&quot;RESET\&quot;; state: FormState };\n  \n  function reducer(state: FormState, action: FormStateAction): FormState {&quot;,
        &quot;oldStart&quot;: 23,
        &quot;newStart&quot;: 23,
        &quot;oldLines&quot;: 5,
        &quot;newLines&quot;: 6,
        &quot;linesRemoved&quot;: 1,
        &quot;linesAdded&quot;: 2
      },
      {
        &quot;diffString&quot;: &quot;        };\n      }\n+     case \&quot;RESET\&quot;: {\n+       return action.state;\n+     }\n      default:\n        return state;&quot;,
        &quot;oldStart&quot;: 151,
        &quot;newStart&quot;: 152,
        &quot;oldLines&quot;: 4,
        &quot;newLines&quot;: 7,
        &quot;linesAdded&quot;: 3
      },
      {
        &quot;diffString&quot;: &quot;    setIsSubmitting: (value: boolean) =&gt; void;\n    markClean: () =&gt; void;\n+   resetForm: (nextData?: Record&lt;string, unknown&gt;, nextStep?: number) =&gt; void;\n    validateStepAt: (\n      stepIndex: number&quot;,
        &quot;oldStart&quot;: 175,
        &quot;newStart&quot;: 179,
        &quot;oldLines&quot;: 4,
        &quot;newLines&quot;: 5,
        &quot;linesAdded&quot;: 1
      },
      {
        &quot;diffString&quot;: &quot;      dispatch({ type: \&quot;SET_DIRTY\&quot;, value: false });\n    }, []);\n+ \n+   const resetForm = useCallback(\n+     (nextData: Record&lt;string, unknown&gt; = {}, nextStep = 0) =&gt; {\n+       dispatch({\n+         type: \&quot;RESET\&quot;,\n+         state: createInitialFormState(nextData, nextStep),\n+       });\n+     },\n+     []\n+   );\n  \n    const validateStepAt = useCallback(&quot;,
        &quot;oldStart&quot;: 248,
        &quot;newStart&quot;: 253,
        &quot;oldLines&quot;: 4,
        &quot;newLines&quot;: 14,
        &quot;linesAdded&quot;: 10
      },
      {
        &quot;diffString&quot;: &quot;      setIsSubmitting,\n      markClean,\n+     resetForm,\n      validateStepAt,\n      validateAndCommitStep,&quot;,
        &quot;oldStart&quot;: 284,
        &quot;newStart&quot;: 299,
        &quot;oldLines&quot;: 4,
        &quot;newLines&quot;: 5,
        &quot;linesAdded&quot;: 1
      }
    ],
    &quot;editor&quot;: &quot;EDITOR_AI&quot;
  },
  &quot;shouldAutoFixLints&quot;: true,
  &quot;resultForModel&quot;: &quot;Success. Updated the following files:\nM hooks/use-form-state.ts&quot;,
  &quot;contentsAfterEdit&quot;: &quot;\&quot;use client\&quot;;\n\nimport { useCallback, useMemo, useReducer } from \&quot;react\&quot;;\nimport type { FormConfigWithFields } from \&quot;@/lib/forms/types\&quot;;\nimport {\n  createInitialFormState,\n  type FormState,\n} from \&quot;@/lib/forms/form-state\&quot;;\nimport {\n  getStepFieldKeys,\n  validateStep,\n  type StepValidationResult,\n} from \&quot;@/lib/forms/form-validator\&quot;;\n\ntype FormStateAction =\n  | { type: \&quot;SET_FIELD_VALUE\&quot;; fieldKey: string; value: unknown }\n  | { type: \&quot;MARK_TOUCHED\&quot;; fieldKey: string }\n  | { type: \&quot;MARK_TOUCHED_FIELDS\&quot;; fieldKeys: string[] }\n  | { type: \&quot;SET_STEP_ERRORS\&quot;; fieldKeys: string[]; errors: Record&lt;string, string&gt; }\n  | { type: \&quot;SET_ERRORS\&quot;; errors: Record&lt;string, string&gt; }\n  | { type: \&quot;SET_FIELD_ERROR\&quot;; fieldKey: string; error?: string }\n  | { type: \&quot;SET_CURRENT_STEP\&quot;; step: number }\n  | { type: \&quot;MARK_STEP_COMPLETE\&quot;; step: number }\n  | { type: \&quot;SET_SUBMITTING\&quot;; value: boolean }\n  | { type: \&quot;SET_DIRTY\&quot;; value: boolean }\n  | { type: \&quot;RESET\&quot;; state: FormState };\n\nfunction reducer(state: FormState, action: FormStateAction): FormState {\n  switch (action.type) {\n    case \&quot;SET_FIELD_VALUE\&quot;: {\n      const nextValue = action.value;\n      const hasChanged = state.formData[action.fieldKey] !== nextValue;\n      if (!hasChanged) {\n        return state;\n      }\n\n      return {\n        ...state,\n        formData: {\n          ...state.formData,\n          [action.fieldKey]: nextValue,\n        },\n        isDirty: true,\n      };\n    }\n    case \&quot;SET_FIELD_ERROR\&quot;: {\n      const nextErrors = { ...state.errors };\n      if (!action.error) {\n        delete nextErrors[action.fieldKey];\n      } else {\n        nextErrors[action.fieldKey] = action.error;\n      }\n      return {\n        ...state,\n        errors: nextErrors,\n      };\n    }\n    case \&quot;MARK_TOUCHED\&quot;: {\n      if (state.touched.has(action.fieldKey)) {\n        return state;\n      }\n      const touched = new Set(state.touched);\n      touched.add(action.fieldKey);\n      return {\n        ...state,\n        touched,\n      };\n    }\n    case \&quot;MARK_TOUCHED_FIELDS\&quot;: {\n      if (action.fieldKeys.length === 0) {\n        return state;\n      }\n      const touched = new Set(state.touched);\n      let modified = false;\n      action.fieldKeys.forEach((key) =&gt; {\n        if (!touched.has(key)) {\n          touched.add(key);\n          modified = true;\n        }\n      });\n      if (!modified) {\n        return state;\n      }\n      return {\n        ...state,\n        touched,\n      };\n    }\n    case \&quot;SET_STEP_ERRORS\&quot;: {\n      const nextErrors = { ...state.errors };\n      const fieldSet = new Set(action.fieldKeys);\n\n      // Remove stale errors for this step\n      fieldSet.forEach((fieldKey) =&gt; {\n        if (!(fieldKey in action.errors)) {\n          delete nextErrors[fieldKey];\n        }\n      });\n\n      // Apply new errors\n      Object.entries(action.errors).forEach(([fieldKey, message]) =&gt; {\n        nextErrors[fieldKey] = message;\n      });\n\n      return {\n        ...state,\n        errors: nextErrors,\n      };\n    }\n    case \&quot;SET_ERRORS\&quot;: {\n      return {\n        ...state,\n        errors: action.errors,\n      };\n    }\n    case \&quot;SET_CURRENT_STEP\&quot;: {\n      if (state.currentStep === action.step) {\n        return state;\n      }\n      return {\n        ...state,\n        currentStep: action.step,\n      };\n    }\n    case \&quot;MARK_STEP_COMPLETE\&quot;: {\n      if (state.completedSteps.has(action.step)) {\n        return state;\n      }\n      const completedSteps = new Set(state.completedSteps);\n      completedSteps.add(action.step);\n      return {\n        ...state,\n        completedSteps,\n      };\n    }\n    case \&quot;SET_SUBMITTING\&quot;: {\n      if (state.isSubmitting === action.value) {\n        return state;\n      }\n      return {\n        ...state,\n        isSubmitting: action.value,\n      };\n    }\n    case \&quot;SET_DIRTY\&quot;: {\n      if (state.isDirty === action.value) {\n        return state;\n      }\n      return {\n        ...state,\n        isDirty: action.value,\n      };\n    }\n    case \&quot;RESET\&quot;: {\n      return action.state;\n    }\n    default:\n      return state;\n  }\n}\n\nexport interface UseFormStateOptions {\n  formConfig: FormConfigWithFields;\n  initialData?: Record&lt;string, unknown&gt;;\n  initialStep?: number;\n}\n\nexport interface UseFormStateReturn {\n  state: FormState;\n  touchedMap: Record&lt;string, boolean&gt;;\n  setFieldValue: (fieldKey: string, value: unknown) =&gt; void;\n  markFieldTouched: (fieldKey: string) =&gt; void;\n  markFieldsTouched: (fieldKeys: string[]) =&gt; void;\n  setStepErrors: (fieldKeys: string[], errors: Record&lt;string, string&gt;) =&gt; void;\n  setErrors: (errors: Record&lt;string, string&gt;) =&gt; void;\n  setFieldError: (fieldKey: string, error?: string) =&gt; void;\n  goToStep: (step: number) =&gt; void;\n  markStepComplete: (step: number) =&gt; void;\n  setIsSubmitting: (value: boolean) =&gt; void;\n  markClean: () =&gt; void;\n  resetForm: (nextData?: Record&lt;string, unknown&gt;, nextStep?: number) =&gt; void;\n  validateStepAt: (\n    stepIndex: number\n  ) =&gt; StepValidationResult &amp; { fieldKeys: string[] };\n  validateAndCommitStep: (\n    stepIndex: number\n  ) =&gt; StepValidationResult &amp; { fieldKeys: string[] };\n}\n\nexport function useFormState({\n  formConfig,\n  initialData,\n  initialStep = 0,\n}: UseFormStateOptions): UseFormStateReturn {\n  const [state, dispatch] = useReducer(\n    reducer,\n    undefined,\n    () =&gt; createInitialFormState(initialData ?? {}, initialStep)\n  );\n\n  const touchedMap = useMemo(() =&gt; {\n    const result: Record&lt;string, boolean&gt; = {};\n    state.touched.forEach((key) =&gt; {\n      result[key] = true;\n    });\n    return result;\n  }, [state.touched]);\n\n  const setFieldValue = useCallback((fieldKey: string, value: unknown) =&gt; {\n    dispatch({ type: \&quot;SET_FIELD_VALUE\&quot;, fieldKey, value });\n  }, []);\n\n  const markFieldTouched = useCallback((fieldKey: string) =&gt; {\n    dispatch({ type: \&quot;MARK_TOUCHED\&quot;, fieldKey });\n  }, []);\n\n  const markFieldsTouched = useCallback((fieldKeys: string[]) =&gt; {\n    dispatch({ type: \&quot;MARK_TOUCHED_FIELDS\&quot;, fieldKeys });\n  }, []);\n\n  const setStepErrors = useCallback(\n    (fieldKeys: string[], errors: Record&lt;string, string&gt;) =&gt; {\n      dispatch({\n        type: \&quot;SET_STEP_ERRORS\&quot;,\n        fieldKeys,\n        errors,\n      });\n    },\n    []\n  );\n\n  const setErrors = useCallback((errors: Record&lt;string, string&gt;) =&gt; {\n    dispatch({ type: \&quot;SET_ERRORS\&quot;, errors });\n  }, []);\n\n  const setFieldError = useCallback((fieldKey: string, error?: string) =&gt; {\n    dispatch({ type: \&quot;SET_FIELD_ERROR\&quot;, fieldKey, error });\n  }, []);\n\n  const goToStep = useCallback((step: number) =&gt; {\n    dispatch({ type: \&quot;SET_CURRENT_STEP\&quot;, step });\n  }, []);\n\n  const markStepComplete = useCallback((step: number) =&gt; {\n    dispatch({ type: \&quot;MARK_STEP_COMPLETE\&quot;, step });\n  }, []);\n\n  const setIsSubmitting = useCallback((value: boolean) =&gt; {\n    dispatch({ type: \&quot;SET_SUBMITTING\&quot;, value });\n  }, []);\n\n  const markClean = useCallback(() =&gt; {\n    dispatch({ type: \&quot;SET_DIRTY\&quot;, value: false });\n  }, []);\n\n  const resetForm = useCallback(\n    (nextData: Record&lt;string, unknown&gt; = {}, nextStep = 0) =&gt; {\n      dispatch({\n        type: \&quot;RESET\&quot;,\n        state: createInitialFormState(nextData, nextStep),\n      });\n    },\n    []\n  );\n\n  const validateStepAt = useCallback(\n    (stepIndex: number) =&gt; {\n      const result = validateStep(stepIndex, state.formData, formConfig);\n      const fieldKeys = getStepFieldKeys(stepIndex, formConfig);\n      return {\n        ...result,\n        fieldKeys,\n      };\n    },\n    [formConfig, state.formData]\n  );\n\n  const validateAndCommitStep = useCallback(\n    (stepIndex: number) =&gt; {\n      const validation = validateStepAt(stepIndex);\n      markFieldsTouched(validation.fieldKeys);\n      setStepErrors(validation.fieldKeys, validation.errors);\n      return validation;\n    },\n    [markFieldsTouched, setStepErrors, validateStepAt]\n  );\n\n  return {\n    state,\n    touchedMap,\n    setFieldValue,\n    markFieldTouched,\n    markFieldsTouched,\n    setStepErrors,\n    setErrors,\n    setFieldError,\n    goToStep,\n    markStepComplete,\n    setIsSubmitting,\n    markClean,\n    resetForm,\n    validateStepAt,\n    validateAndCommitStep,\n  };\n}\n\n&quot;
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Preparing full rewrite for dynamic-form-wizard.tsx**

I’m planning to rewrite the entire `dynamic-form-wizard.tsx` file to a clean, single-version implementation that removes duplicates and preserves key logic like state management, effects, and hooks. I want to ensure import order is tidy, handle JSON stringification safely for initial data, and include features like `prefersReducedMotion` and `DraftSaveResult`. Using a here-doc (`cat <<EOF > file`) feels like the best approach to produce a fresh, consistent file.</details></think>

---

<tool-use data-tool-type="bash" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **command** • Run command: cd /Users/sahilmehta/supplier-onboarding-simple && cat <<'EOF' > components/forms/dynamic-form-wizard.tsx
"use client";

import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import type { FormConfigWithFields } from "@/lib/forms/types";
import { getStepFieldKeys } from "@/lib/forms/form-validator";
import { buildFormSchema } from "@/lib/form-schema";
import { saveFormDraft, type DraftSaveResult } from "@/app/forms/actions";
import { StepIndicator } from "./step-indicator";
import { FormStep } from "./form-step";
import { FormNavigation } from "./form-navigation";
import { FormErrorSummary } from "./form-error-summary";
import { useFormState } from "@/hooks/use-form-state";
import { useAutosave } from "@/hooks/use-autosave";
import { useToast } from "@/components/ui/use-toast";
import { usePrefersReducedMotion } from "@/hooks/use-prefers-reduced-motion";
import { cn } from "@/lib/utils";

interface DynamicFormWizardProps {
  formConfig: FormConfigWithFields;
  initialData?: Record<string, unknown>;
  initialStep?: number;
  applicationId: string | null;
  organizationId: string;
  onApplicationIdChange?: (applicationId: string) => void;
  onDraftSaved?: (result: DraftSaveResult) => void;
  onStepChange?: (stepIndex: number) => void;
  onComplete?: (formData: Record<string, unknown>) => Promise<void> | void;
}

const clampStep = (step: number, totalSteps: number) => {
  if (totalSteps <= 0) {
    return 0;
  }
  return Math.max(0, Math.min(step, totalSteps - 1));
};

export function DynamicFormWizard({
  formConfig,
  initialData = {},
  initialStep = 0,
  applicationId,
  organizationId,
  onApplicationIdChange,
  onDraftSaved,
  onStepChange,
  onComplete,
}: DynamicFormWizardProps) {
  const sortedSections = useMemo(
    () => [...formConfig.sections].sort((a, b) => a.order - b.order),
    [formConfig.sections]
  );

  const totalSteps = sortedSections.length;
  const safeInitialStep = clampStep(initialStep ?? 0, totalSteps);

  const {
    state,
    touchedMap,
    setFieldValue,
    markFieldTouched,
    markFieldsTouched,
    setFieldError,
    setStepErrors,
    goToStep,
    markStepComplete,
    setIsSubmitting,
    markClean,
    resetForm,
    validateAndCommitStep,
  } = useFormState({
    formConfig,
    initialData,
    initialStep: safeInitialStep,
  });

  const [liveMessage, setLiveMessage] = useState("");
  const validationTimersRef = useRef<Record<string, NodeJS.Timeout>>({});
  const formSchemaRef = useRef(buildFormSchema(formConfig));
  const prefersReducedMotion = usePrefersReducedMotion();
  const { toast } = useToast();
  const initialSnapshotRef = useRef(
    JSON.stringify({ data: initialData, step: safeInitialStep, applicationId })
  );

  const isFirstStep = state.currentStep === 0;
  const isLastStep = state.currentStep === totalSteps - 1;
  const currentSection = sortedSections[state.currentStep];

  useEffect(() => {
    formSchemaRef.current = buildFormSchema(formConfig);
  }, [formConfig]);

  useEffect(() => {
    const nextSnapshot = JSON.stringify({
      data: initialData,
      step: safeInitialStep,
      applicationId,
    });

    if (nextSnapshot !== initialSnapshotRef.current) {
      resetForm(initialData, safeInitialStep);
      initialSnapshotRef.current = nextSnapshot;
    }
  }, [initialData, resetForm, safeInitialStep, applicationId]);

  const focusFirstError = useCallback(
    (fieldKey?: string) => {
      if (!fieldKey || !currentSection) {
        return;
      }
      const errorField = currentSection.fields.find((field) => field.key === fieldKey);
      const fieldElement = errorField
        ? document.getElementById(`field-${errorField.id}`)
        : null;
      fieldElement?.focus();
      fieldElement?.scrollIntoView({ behavior: "smooth", block: "center" });
    },
    [currentSection]
  );

  const validateField = useCallback(
    (fieldKey: string, value: unknown, immediate = false) => {
      if (validationTimersRef.current[fieldKey]) {
        clearTimeout(validationTimersRef.current[fieldKey]);
      }

      const performValidation = () => {
        const fieldSchema = formSchemaRef.current.shape[fieldKey];
        if (!fieldSchema) {
          return;
        }

        try {
          fieldSchema.parse(value);
          setFieldError(fieldKey);
        } catch (error) {
          if (error && typeof error === "object" && "issues" in error) {
            const zodError = error as { issues: Array<{ message: string }> };
            const firstIssue = zodError.issues[0];
            if (firstIssue) {
              setFieldError(fieldKey, firstIssue.message);
            }
          } else if (error instanceof Error) {
            setFieldError(fieldKey, error.message);
          }
        }
      };

      if (immediate) {
        performValidation();
      } else {
        validationTimersRef.current[fieldKey] = setTimeout(performValidation, 300);
      }
    },
    [setFieldError]
  );

  const handleFieldChange = useCallback(
    (fieldKey: string, value: unknown) => {
      setFieldValue(fieldKey, value);
      if (state.touched.has(fieldKey)) {
        validateField(fieldKey, value, false);
      }
    },
    [setFieldValue, state.touched, validateField]
  );

  const handleFieldBlur = useCallback(
    (fieldKey: string) => {
      markFieldTouched(fieldKey);
      validateField(fieldKey, state.formData[fieldKey], true);
    },
    [markFieldTouched, state.formData, validateField]
  );

  const autosaveFingerprint = useMemo(
    () => JSON.stringify({ data: state.formData, step: state.currentStep }),
    [state.formData, state.currentStep]
  );

  const runDraftSave = useCallback(() => {
    return saveFormDraft({
      formConfigId: formConfig.id,
      organizationId,
      entityId: formConfig.entityId,
      geographyId: formConfig.geographyId,
      applicationId,
      formData: state.formData,
      currentStep: state.currentStep,
    });
  }, [
    applicationId,
    formConfig.entityId,
    formConfig.geographyId,
    formConfig.id,
    organizationId,
    state.currentStep,
    state.formData,
  ]);

  const {
    status: draftStatus,
    isSaving: isSavingDraft,
    lastSavedAt,
    error: draftError,
    triggerSave,
  } = useAutosave<DraftSaveResult>({
    shouldAutosave: state.isDirty,
    dataFingerprint: autosaveFingerprint,
    save: runDraftSave,
    onSuccess: (result) => {
      markClean();
      if (result.applicationId && result.applicationId !== applicationId) {
        onApplicationIdChange?.(result.applicationId);
      }
      onDraftSaved?.(result);
    },
    onError: (error) => {
      toast({
        variant: "destructive",
        title: "Draft save failed",
        description: error.message,
      });
    },
  });

  const handleNext = useCallback(async () => {
    if (state.isSubmitting) {
      return;
    }

    const validation = validateAndCommitStep(state.currentStep);
    if (!validation.isValid) {
      toast({
        variant: "destructive",
        title: "Please fix validation errors",
        description: "Resolve highlighted fields before continuing.",
      });
      focusFirstError(validation.firstErrorField);
      return;
    }

    markStepComplete(state.currentStep);

    if (isLastStep && onComplete) {
      try {
        setIsSubmitting(true);
        await onComplete(state.formData);
        toast({
          title: "Form submitted",
          description: "Thank you! We received your information.",
        });
      } catch (error) {
        toast({
          variant: "destructive",
          title: "Submission failed",
          description:
            error instanceof Error
              ? error.message
              : "Something went wrong while submitting. Please try again.",
        });
      } finally {
        setIsSubmitting(false);
      }
      return;
    }

    const nextStep = clampStep(state.currentStep + 1, totalSteps);
    goToStep(nextStep);
    onStepChange?.(nextStep);
    void triggerSave("step-change");
  }, [
    focusFirstError,
    goToStep,
    isLastStep,
    markStepComplete,
    onComplete,
    onStepChange,
    setIsSubmitting,
    state.currentStep,
    state.formData,
    state.isSubmitting,
    toast,
    totalSteps,
    triggerSave,
    validateAndCommitStep,
  ]);

  const handlePrevious = useCallback(() => {
    if (isFirstStep) {
      return;
    }
    const prevStep = clampStep(state.currentStep - 1, totalSteps);
    goToStep(prevStep);
    onStepChange?.(prevStep);
  }, [goToStep, isFirstStep, onStepChange, state.currentStep, totalSteps]);

  const handleStepClick = useCallback(
    (stepIndex: number) => {
      if (stepIndex === state.currentStep) {
        return;
      }

      const validation = validateAndCommitStep(state.currentStep);
      if (!validation.isValid) {
        toast({
          variant: "destructive",
          title: "Cannot leave step yet",
          description: "Fix validation errors before moving on.",
        });
        focusFirstError(validation.firstErrorField);
        return;
      }

      if (
        state.completedSteps.has(stepIndex) ||
        stepIndex === clampStep(state.currentStep + 1, totalSteps)
      ) {
        const nextStep = clampStep(stepIndex, totalSteps);
        goToStep(nextStep);
        onStepChange?.(nextStep);
        void triggerSave("step-change");
      }
    },
    [
      focusFirstError,
      goToStep,
      onStepChange,
      state.completedSteps,
      state.currentStep,
      toast,
      totalSteps,
      triggerSave,
      validateAndCommitStep,
    ]
  );

  const handleManualSave = useCallback(() => {
    void triggerSave("manual");
  }, [triggerSave]);

  useEffect(() => {
    return () => {
      Object.values(validationTimersRef.current).forEach((timer) => {
        clearTimeout(timer);
      });
    };
  }, []);

  useEffect(() => {
    const sectionLabel = currentSection?.label ?? `Step ${state.currentStep + 1}`;
    setLiveMessage(
      `Now viewing ${sectionLabel} (${state.currentStep + 1} of ${totalSteps})`
    );
  }, [currentSection, state.currentStep, totalSteps]);

  const progress =
    totalSteps > 0 ? ((state.currentStep + 1) / totalSteps) * 100 : 0;

  return (
    <div className="flex flex-col gap-6 pb-32 sm:pb-12">
      <StepIndicator
        steps={sortedSections.map((section) => ({
          id: section.id,
          label: section.label,
          order: section.order,
        }))}
        currentStep={state.currentStep}
        completedSteps={state.completedSteps}
        onStepClick={handleStepClick}
      />

      <div
        className={cn(
          "min-h-[400px] space-y-6 rounded-3xl border border-border/60 bg-background/70 p-4 shadow-lg sm:p-8",
          !prefersReducedMotion && "transition-shadow duration-300"
        )}
      >
        {(() => {
          const stepFieldKeys = getStepFieldKeys(state.currentStep, formConfig);
          const stepErrors: Record<string, string> = {};
          stepFieldKeys.forEach((key) => {
            if (state.errors[key] && touchedMap[key]) {
              stepErrors[key] = state.errors[key];
            }
          });

          if (Object.keys(stepErrors).length > 0) {
            return (
              <FormErrorSummary
                errors={stepErrors}
                onErrorClick={(fieldKey) => focusFirstError(fieldKey)}
              />
            );
          }
          return null;
        })()}

        {currentSection && (
          <FormStep
            section={currentSection}
            formData={state.formData}
            errors={state.errors}
            touched={touchedMap}
            onFieldChange={handleFieldChange}
            onFieldBlur={handleFieldBlur}
          />
        )}
      </div>

      <FormNavigation
        isFirstStep={isFirstStep}
        isLastStep={isLastStep}
        onNext={handleNext}
        onPrevious={handlePrevious}
        onSaveDraft={handleManualSave}
        progress={progress}
        isSubmitting={state.isSubmitting}
        isSavingDraft={isSavingDraft}
        draftStatus={draftStatus}
        draftError={draftError}
        lastSavedAt={lastSavedAt}
      />
      <p role="status" aria-live="polite" className="sr-only">
        {liveMessage}
      </p>
    </div>
  );
}
EOF</summary>

```bash
cd /Users/sahilmehta/supplier-onboarding-simple && cat <<'EOF' > components/forms/dynamic-form-wizard.tsx
"use client";

import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import type { FormConfigWithFields } from "@/lib/forms/types";
import { getStepFieldKeys } from "@/lib/forms/form-validator";
import { buildFormSchema } from "@/lib/form-schema";
import { saveFormDraft, type DraftSaveResult } from "@/app/forms/actions";
import { StepIndicator } from "./step-indicator";
import { FormStep } from "./form-step";
import { FormNavigation } from "./form-navigation";
import { FormErrorSummary } from "./form-error-summary";
import { useFormState } from "@/hooks/use-form-state";
import { useAutosave } from "@/hooks/use-autosave";
import { useToast } from "@/components/ui/use-toast";
import { usePrefersReducedMotion } from "@/hooks/use-prefers-reduced-motion";
import { cn } from "@/lib/utils";

interface DynamicFormWizardProps {
  formConfig: FormConfigWithFields;
  initialData?: Record<string, unknown>;
  initialStep?: number;
  applicationId: string | null;
  organizationId: string;
  onApplicationIdChange?: (applicationId: string) => void;
  onDraftSaved?: (result: DraftSaveResult) => void;
  onStepChange?: (stepIndex: number) => void;
  onComplete?: (formData: Record<string, unknown>) => Promise<void> | void;
}

const clampStep = (step: number, totalSteps: number) => {
  if (totalSteps <= 0) {
    return 0;
  }
  return Math.max(0, Math.min(step, totalSteps - 1));
};

export function DynamicFormWizard({
  formConfig,
  initialData = {},
  initialStep = 0,
  applicationId,
  organizationId,
  onApplicationIdChange,
  onDraftSaved,
  onStepChange,
  onComplete,
}: DynamicFormWizardProps) {
  const sortedSections = useMemo(
    () => [...formConfig.sections].sort((a, b) => a.order - b.order),
    [formConfig.sections]
  );

  const totalSteps = sortedSections.length;
  const safeInitialStep = clampStep(initialStep ?? 0, totalSteps);

  const {
    state,
    touchedMap,
    setFieldValue,
    markFieldTouched,
    markFieldsTouched,
    setFieldError,
    setStepErrors,
    goToStep,
    markStepComplete,
    setIsSubmitting,
    markClean,
    resetForm,
    validateAndCommitStep,
  } = useFormState({
    formConfig,
    initialData,
    initialStep: safeInitialStep,
  });

  const [liveMessage, setLiveMessage] = useState("");
  const validationTimersRef = useRef<Record<string, NodeJS.Timeout>>({});
  const formSchemaRef = useRef(buildFormSchema(formConfig));
  const prefersReducedMotion = usePrefersReducedMotion();
  const { toast } = useToast();
  const initialSnapshotRef = useRef(
    JSON.stringify({ data: initialData, step: safeInitialStep, applicationId })
  );

  const isFirstStep = state.currentStep === 0;
  const isLastStep = state.currentStep === totalSteps - 1;
  const currentSection = sortedSections[state.currentStep];

  useEffect(() => {
    formSchemaRef.current = buildFormSchema(formConfig);
  }, [formConfig]);

  useEffect(() => {
    const nextSnapshot = JSON.stringify({
      data: initialData,
      step: safeInitialStep,
      applicationId,
    });

    if (nextSnapshot !== initialSnapshotRef.current) {
      resetForm(initialData, safeInitialStep);
      initialSnapshotRef.current = nextSnapshot;
    }
  }, [initialData, resetForm, safeInitialStep, applicationId]);

  const focusFirstError = useCallback(
    (fieldKey?: string) => {
      if (!fieldKey || !currentSection) {
        return;
      }
      const errorField = currentSection.fields.find((field) => field.key === fieldKey);
      const fieldElement = errorField
        ? document.getElementById(`field-${errorField.id}`)
        : null;
      fieldElement?.focus();
      fieldElement?.scrollIntoView({ behavior: "smooth", block: "center" });
    },
    [currentSection]
  );

  const validateField = useCallback(
    (fieldKey: string, value: unknown, immediate = false) => {
      if (validationTimersRef.current[fieldKey]) {
        clearTimeout(validationTimersRef.current[fieldKey]);
      }

      const performValidation = () => {
        const fieldSchema = formSchemaRef.current.shape[fieldKey];
        if (!fieldSchema) {
          return;
        }

        try {
          fieldSchema.parse(value);
          setFieldError(fieldKey);
        } catch (error) {
          if (error && typeof error === "object" && "issues" in error) {
            const zodError = error as { issues: Array<{ message: string }> };
            const firstIssue = zodError.issues[0];
            if (firstIssue) {
              setFieldError(fieldKey, firstIssue.message);
            }
          } else if (error instanceof Error) {
            setFieldError(fieldKey, error.message);
          }
        }
      };

      if (immediate) {
        performValidation();
      } else {
        validationTimersRef.current[fieldKey] = setTimeout(performValidation, 300);
      }
    },
    [setFieldError]
  );

  const handleFieldChange = useCallback(
    (fieldKey: string, value: unknown) => {
      setFieldValue(fieldKey, value);
      if (state.touched.has(fieldKey)) {
        validateField(fieldKey, value, false);
      }
    },
    [setFieldValue, state.touched, validateField]
  );

  const handleFieldBlur = useCallback(
    (fieldKey: string) => {
      markFieldTouched(fieldKey);
      validateField(fieldKey, state.formData[fieldKey], true);
    },
    [markFieldTouched, state.formData, validateField]
  );

  const autosaveFingerprint = useMemo(
    () => JSON.stringify({ data: state.formData, step: state.currentStep }),
    [state.formData, state.currentStep]
  );

  const runDraftSave = useCallback(() => {
    return saveFormDraft({
      formConfigId: formConfig.id,
      organizationId,
      entityId: formConfig.entityId,
      geographyId: formConfig.geographyId,
      applicationId,
      formData: state.formData,
      currentStep: state.currentStep,
    });
  }, [
    applicationId,
    formConfig.entityId,
    formConfig.geographyId,
    formConfig.id,
    organizationId,
    state.currentStep,
    state.formData,
  ]);

  const {
    status: draftStatus,
    isSaving: isSavingDraft,
    lastSavedAt,
    error: draftError,
    triggerSave,
  } = useAutosave<DraftSaveResult>({
    shouldAutosave: state.isDirty,
    dataFingerprint: autosaveFingerprint,
    save: runDraftSave,
    onSuccess: (result) => {
      markClean();
      if (result.applicationId && result.applicationId !== applicationId) {
        onApplicationIdChange?.(result.applicationId);
      }
      onDraftSaved?.(result);
    },
    onError: (error) => {
      toast({
        variant: "destructive",
        title: "Draft save failed",
        description: error.message,
      });
    },
  });

  const handleNext = useCallback(async () => {
    if (state.isSubmitting) {
      return;
    }

    const validation = validateAndCommitStep(state.currentStep);
    if (!validation.isValid) {
      toast({
        variant: "destructive",
        title: "Please fix validation errors",
        description: "Resolve highlighted fields before continuing.",
      });
      focusFirstError(validation.firstErrorField);
      return;
    }

    markStepComplete(state.currentStep);

    if (isLastStep && onComplete) {
      try {
        setIsSubmitting(true);
        await onComplete(state.formData);
        toast({
          title: "Form submitted",
          description: "Thank you! We received your information.",
        });
      } catch (error) {
        toast({
          variant: "destructive",
          title: "Submission failed",
          description:
            error instanceof Error
              ? error.message
              : "Something went wrong while submitting. Please try again.",
        });
      } finally {
        setIsSubmitting(false);
      }
      return;
    }

    const nextStep = clampStep(state.currentStep + 1, totalSteps);
    goToStep(nextStep);
    onStepChange?.(nextStep);
    void triggerSave("step-change");
  }, [
    focusFirstError,
    goToStep,
    isLastStep,
    markStepComplete,
    onComplete,
    onStepChange,
    setIsSubmitting,
    state.currentStep,
    state.formData,
    state.isSubmitting,
    toast,
    totalSteps,
    triggerSave,
    validateAndCommitStep,
  ]);

  const handlePrevious = useCallback(() => {
    if (isFirstStep) {
      return;
    }
    const prevStep = clampStep(state.currentStep - 1, totalSteps);
    goToStep(prevStep);
    onStepChange?.(prevStep);
  }, [goToStep, isFirstStep, onStepChange, state.currentStep, totalSteps]);

  const handleStepClick = useCallback(
    (stepIndex: number) => {
      if (stepIndex === state.currentStep) {
        return;
      }

      const validation = validateAndCommitStep(state.currentStep);
      if (!validation.isValid) {
        toast({
          variant: "destructive",
          title: "Cannot leave step yet",
          description: "Fix validation errors before moving on.",
        });
        focusFirstError(validation.firstErrorField);
        return;
      }

      if (
        state.completedSteps.has(stepIndex) ||
        stepIndex === clampStep(state.currentStep + 1, totalSteps)
      ) {
        const nextStep = clampStep(stepIndex, totalSteps);
        goToStep(nextStep);
        onStepChange?.(nextStep);
        void triggerSave("step-change");
      }
    },
    [
      focusFirstError,
      goToStep,
      onStepChange,
      state.completedSteps,
      state.currentStep,
      toast,
      totalSteps,
      triggerSave,
      validateAndCommitStep,
    ]
  );

  const handleManualSave = useCallback(() => {
    void triggerSave("manual");
  }, [triggerSave]);

  useEffect(() => {
    return () => {
      Object.values(validationTimersRef.current).forEach((timer) => {
        clearTimeout(timer);
      });
    };
  }, []);

  useEffect(() => {
    const sectionLabel = currentSection?.label ?? `Step ${state.currentStep + 1}`;
    setLiveMessage(
      `Now viewing ${sectionLabel} (${state.currentStep + 1} of ${totalSteps})`
    );
  }, [currentSection, state.currentStep, totalSteps]);

  const progress =
    totalSteps > 0 ? ((state.currentStep + 1) / totalSteps) * 100 : 0;

  return (
    <div className="flex flex-col gap-6 pb-32 sm:pb-12">
      <StepIndicator
        steps={sortedSections.map((section) => ({
          id: section.id,
          label: section.label,
          order: section.order,
        }))}
        currentStep={state.currentStep}
        completedSteps={state.completedSteps}
        onStepClick={handleStepClick}
      />

      <div
        className={cn(
          "min-h-[400px] space-y-6 rounded-3xl border border-border/60 bg-background/70 p-4 shadow-lg sm:p-8",
          !prefersReducedMotion && "transition-shadow duration-300"
        )}
      >
        {(() => {
          const stepFieldKeys = getStepFieldKeys(state.currentStep, formConfig);
          const stepErrors: Record<string, string> = {};
          stepFieldKeys.forEach((key) => {
            if (state.errors[key] && touchedMap[key]) {
              stepErrors[key] = state.errors[key];
            }
          });

          if (Object.keys(stepErrors).length > 0) {
            return (
              <FormErrorSummary
                errors={stepErrors}
                onErrorClick={(fieldKey) => focusFirstError(fieldKey)}
              />
            );
          }
          return null;
        })()}

        {currentSection && (
          <FormStep
            section={currentSection}
            formData={state.formData}
            errors={state.errors}
            touched={touchedMap}
            onFieldChange={handleFieldChange}
            onFieldBlur={handleFieldBlur}
          />
        )}
      </div>

      <FormNavigation
        isFirstStep={isFirstStep}
        isLastStep={isLastStep}
        onNext={handleNext}
        onPrevious={handlePrevious}
        onSaveDraft={handleManualSave}
        progress={progress}
        isSubmitting={state.isSubmitting}
        isSavingDraft={isSavingDraft}
        draftStatus={draftStatus}
        draftError={draftError}
        lastSavedAt={lastSavedAt}
      />
      <p role="status" aria-live="polite" className="sr-only">
        {liveMessage}
      </p>
    </div>
  );
}
EOF
```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Verifying file integrity**</details></think>

---

<tool-use data-tool-type="bash" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **command** • Run command: cd /Users/sahilmehta/supplier-onboarding-simple && wc -l components/forms/dynamic-form-wizard.tsx && head -n 5 components/forms/dynamic-form-wizard.tsx && tail -n 5 components/forms/dynamic-form-wizard.tsx</summary>

```bash
cd /Users/sahilmehta/supplier-onboarding-simple && wc -l components/forms/dynamic-form-wizard.tsx && head -n 5 components/forms/dynamic-form-wizard.tsx && tail -n 5 components/forms/dynamic-form-wizard.tsx
```

```
     429 components/forms/dynamic-form-wizard.tsx
&quot;use client&quot;;

import { useCallback, useEffect, useMemo, useRef, useState } from &quot;react&quot;;
import type { FormConfigWithFields } from &quot;@/lib/forms/types&quot;;
import { getStepFieldKeys } from &quot;@/lib/forms/form-validator&quot;;
        {liveMessage}
      &lt;/p&gt;
    &lt;/div&gt;
  );
}
```
</details>
</tool-use>

---



---

_**User (2025-11-17 23:03Z)**_

continue

---

_**Agent (model default, mode Agent)**_

<think><details><summary>Thought Process</summary>
**Continuing form draft integration tasks**</details></think>

---

<tool-use data-tool-type="grep" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "organizationId" in "/Users/sahilmehta/supplier-onboarding-simple" • 10 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `./components/forms/dynamic-form-wizard.tsx` | `organizationId: string;` | L23 |
| `./components/forms/dynamic-form-wizard.tsx` | `organizationId,` | L42 |
| `./components/forms/dynamic-form-wizard.tsx` | `organizationId,` | L184 |
| `./components/forms/dynamic-form-wizard.tsx` | `organizationId,` | L196 |
| `./app/dashboard/users/page.tsx` | `organizationId: activeOrganization.id,` | L66 |
| `./app/dashboard/users/page.tsx` | `\{canManage && <InviteUserDialog organizationId=\{activeOrganization.id\} />\}` | L103 |
| `./app/supplier/onboarding/new/page.tsx` | `organizationId: membership.organizationId,` | L34 |
| `./components/users/invite-user-dialog.tsx` | `organizationId: string;` | L27 |
| `./components/users/invite-user-dialog.tsx` | `export function InviteUserDialog(\{ organizationId \}: InviteUserDialogProps) \{` | L30 |
| `./components/users/invite-user-dialog.tsx` | `body: JSON.stringify(\{ email: email.trim(), role, organizationId \}),` | L48 |


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Searching for active organization context**</details></think>

---

<tool-use data-tool-type="grep" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "activeOrganization" in "/Users/sahilmehta/supplier-onboarding-simple" • 7 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `./app/dashboard/users/page.tsx` | `const activeOrganization = activeMembership.organization;` | L60 |
| `./app/dashboard/users/page.tsx` | `const canManage = await canManageUsers(activeOrganization.id);` | L61 |
| `./app/dashboard/users/page.tsx` | `organizationId: activeOrganization.id,` | L66 |
| `./app/dashboard/users/page.tsx` | `\{canManage && <InviteUserDialog organizationId=\{activeOrganization.id\} />\}` | L103 |
| `./app/dashboard/users/page.tsx` | `\{activeOrganization.name\}` | L111 |
| `./app/dashboard/layout.tsx` | `const activeOrganization = user?.memberships[0]?.organization;` | L50 |
| `./app/dashboard/layout.tsx` | `const organizationName = activeOrganization?.name ?? "Supplier Hub";` | L51 |


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Inspecting auth module for memberships**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/sahilmehta/supplier-onboarding-simple/lib/auth.ts</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Searching for active membership helper**</details></think>

---

<tool-use data-tool-type="grep" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "activeMembership" in "/Users/sahilmehta/supplier-onboarding-simple" • 2 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `./app/dashboard/users/page.tsx` | `const activeMembership = user.memberships[0];` | L59 |
| `./app/dashboard/users/page.tsx` | `const activeOrganization = activeMembership.organization;` | L60 |


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Checking user membership retrieval**</details></think>

---

<tool-use data-tool-type="grep" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "getCurrentUser" in "/Users/sahilmehta/supplier-onboarding-simple" • 13 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `./docs/auth-rbac.md` | `- `getCurrentUserMembership()` fetches membership (used in API routes).` | L17 |
| `./lib/permissions.ts` | `export async function getCurrentUserWithMembership() \{` | L4 |
| `./lib/permissions.ts` | `export async function getCurrentUserMembership(organizationId?: string) \{` | L23 |
| `./lib/permissions.ts` | `const user = await getCurrentUserWithMembership();` | L24 |
| `./lib/permissions.ts` | `const membership = await getCurrentUserMembership(organizationId);` | L37 |
| `./lib/permissions.ts` | `const membership = await getCurrentUserMembership(organizationId);` | L58 |
| `./app/api/users/invite/route.ts` | `import \{ getCurrentUserMembership, requireAdmin \} from "@/lib/permissions";` | L4 |
| `./app/api/users/invite/route.ts` | `const membership = await getCurrentUserMembership();` | L13 |
| `./app/api/users/[id]/route.ts` | `import \{ getCurrentUserMembership, requireAdmin \} from "@/lib/permissions";` | L4 |
| `./app/api/users/[id]/route.ts` | `const membership = await getCurrentUserMembership();` | L17 |
| `./app/api/users/[id]/route.ts` | `const membership = await getCurrentUserMembership();` | L112 |
| `./app/api/users/route.ts` | `import \{ getCurrentUserMembership \} from "@/lib/permissions";` | L4 |
| `./app/api/users/route.ts` | `const membership = await getCurrentUserMembership();` | L13 |


</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/sahilmehta/supplier-onboarding-simple/lib/permissions.ts</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Planning form and draft integration**</details></think>

---

<tool-use data-tool-type="grep" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "DraftResumeDialog" in "/Users/sahilmehta/supplier-onboarding-simple" • 3 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `./components/forms/draft-resume-dialog.tsx` | `interface DraftResumeDialogProps \{` | L17 |
| `./components/forms/draft-resume-dialog.tsx` | `export function DraftResumeDialog(\{` | L26 |
| `./components/forms/draft-resume-dialog.tsx` | `\}: DraftResumeDialogProps) \{` | L33 |


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Outlining draft resume feature implementation**

I’m mapping out how to extend FormWizardClient and server routes to support loading, listing, resuming, and deleting form drafts with metadata like title, steps, and timestamps. I plan to update draft-manager interfaces and queries to align data structures, handle initial draft loading on page mount, enable dynamic switching of drafts in the UI, and create necessary server actions for listing and loading drafts safely with user and organization context. Let’s explore syncing internal state, server calls, and UI components like DraftResumeDialog to fully realize this resume workflow!</details></think>

---

<tool-use data-tool-type="grep" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "currentStep" in "/Users/sahilmehta/supplier-onboarding-simple" • 65 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `./hooks/use-form-state.ts` | `if (state.currentStep === action.step) \{` | L117 |
| `./hooks/use-form-state.ts` | `currentStep: action.step,` | L122 |
| `./lib/forms/types.ts` | `currentStep: number;` | L63 |
| `./lib/forms/form-state.ts` | `currentStep: number;` | L5 |
| `./lib/forms/form-state.ts` | `currentStep: number;` | L15 |
| `./lib/forms/form-state.ts` | `currentStep: normalizedStep,` | L34 |
| `./lib/forms/form-state.ts` | `currentStep: state.currentStep,` | L48 |
| `./lib/forms/form-state.ts` | `currentStep: snapshot.currentStep ?? 0,` | L62 |
| `./components/forms/dynamic-form-wizard.tsx` | `const isFirstStep = state.currentStep === 0;` | L85 |
| `./components/forms/dynamic-form-wizard.tsx` | `const isLastStep = state.currentStep === totalSteps - 1;` | L86 |
| `./components/forms/dynamic-form-wizard.tsx` | `const currentSection = sortedSections[state.currentStep];` | L87 |
| `./components/forms/dynamic-form-wizard.tsx` | `() => JSON.stringify(\{ data: state.formData, step: state.currentStep \}),` | L177 |
| `./components/forms/dynamic-form-wizard.tsx` | `[state.formData, state.currentStep]` | L178 |
| `./components/forms/dynamic-form-wizard.tsx` | `currentStep: state.currentStep,` | L189 |
| `./components/forms/dynamic-form-wizard.tsx` | `state.currentStep,` | L197 |
| `./components/forms/dynamic-form-wizard.tsx` | `const validation = validateAndCommitStep(state.currentStep);` | L232 |
| `./components/forms/dynamic-form-wizard.tsx` | `markStepComplete(state.currentStep);` | L243 |
| `./components/forms/dynamic-form-wizard.tsx` | `const nextStep = clampStep(state.currentStep + 1, totalSteps);` | L268 |
| `./components/forms/dynamic-form-wizard.tsx` | `state.currentStep,` | L280 |
| `./components/forms/dynamic-form-wizard.tsx` | `const prevStep = clampStep(state.currentStep - 1, totalSteps);` | L293 |
| `./components/forms/dynamic-form-wizard.tsx` | `\}, [goToStep, isFirstStep, onStepChange, state.currentStep, totalSteps]);` | L296 |
| `./components/forms/dynamic-form-wizard.tsx` | `if (stepIndex === state.currentStep) \{` | L300 |
| `./components/forms/dynamic-form-wizard.tsx` | `const validation = validateAndCommitStep(state.currentStep);` | L304 |
| `./components/forms/dynamic-form-wizard.tsx` | `stepIndex === clampStep(state.currentStep + 1, totalSteps)` | L317 |
| `./components/forms/dynamic-form-wizard.tsx` | `state.currentStep,` | L330 |
| `./components/forms/dynamic-form-wizard.tsx` | `const sectionLabel = currentSection?.label ?? `Step $\{state.currentStep + 1\}`;` | L351 |
| `./components/forms/dynamic-form-wizard.tsx` | ``Now viewing $\{sectionLabel\} ($\{state.currentStep + 1\} of $\{totalSteps\})`` | L353 |
| `./components/forms/dynamic-form-wizard.tsx` | `\}, [currentSection, state.currentStep, totalSteps]);` | L355 |
| `./components/forms/dynamic-form-wizard.tsx` | `totalSteps > 0 ? ((state.currentStep + 1) / totalSteps) * 100 : 0;` | L358 |
| `./components/forms/dynamic-form-wizard.tsx` | `currentStep=\{state.currentStep\}` | L368 |
| `./components/forms/dynamic-form-wizard.tsx` | `const stepFieldKeys = getStepFieldKeys(state.currentStep, formConfig);` | L380 |
| `./app/forms/actions.ts` | `currentStep: number;` | L19 |
| `./app/forms/actions.ts` | `currentStep: number;` | L25 |
| `./app/forms/actions.ts` | `currentStep: input.currentStep,` | L66 |
| `./app/forms/actions.ts` | `currentStep: record.currentStep,` | L73 |
| `./lib/forms/draft-manager.ts` | `currentStep: number;` | L6 |
| `./lib/forms/draft-manager.ts` | `currentStep: number;` | L18 |
| `./lib/forms/draft-manager.ts` | `currentStep: number;` | L33 |
| `./lib/forms/draft-manager.ts` | `currentStep: number` | L58 |
| `./lib/forms/draft-manager.ts` | `currentStep,` | L63 |
| `./lib/forms/draft-manager.ts` | `currentStep: 0,` | L77 |
| `./lib/forms/draft-manager.ts` | `currentStep: Number.isFinite(meta.currentStep) ? meta.currentStep : 0,` | L83 |
| `./lib/forms/draft-manager.ts` | `const payload = encodeDraftPayload(options.formData, options.currentStep);` | L102 |
| `./lib/forms/draft-manager.ts` | `currentStep: record.currentStep,` | L215 |
| `./components/forms/draft-resume-dialog.tsx` | `Step \{draft.currentStep + 1\} · Updated\{" "\}` | L123 |
| `./components/forms/step-indicator.tsx` | `currentStep: number;` | L15 |
| `./components/forms/step-indicator.tsx` | `currentStep,` | L22 |
| `./components/forms/step-indicator.tsx` | `return <MobileStepIndicator steps=\{steps\} currentStep=\{currentStep\} />;` | L29 |
| `./components/forms/step-indicator.tsx` | `currentStep=\{currentStep\}` | L35 |
| `./components/forms/step-indicator.tsx` | `currentStep,` | L44 |
| `./components/forms/step-indicator.tsx` | `const isCurrent = index === currentStep;` | L53 |
| `./components/forms/step-indicator.tsx` | `isCompleted \|\| index === currentStep + 1 \|\| index === currentStep;` | L55 |
| `./components/forms/step-indicator.tsx` | `isCompleted \|\| index < currentStep` | L108 |
| `./components/forms/step-indicator.tsx` | `currentStep,` | L125 |
| `./components/forms/step-indicator.tsx` | `currentStep: number;` | L128 |
| `./components/forms/step-indicator.tsx` | `const currentStepData = steps[currentStep];` | L130 |
| `./components/forms/step-indicator.tsx` | `const progress = ((currentStep + 1) / steps.length) * 100;` | L131 |
| `./components/forms/step-indicator.tsx` | `Step \{currentStep + 1\} of \{steps.length\}` | L137 |
| `./components/forms/step-indicator.tsx` | `\{currentStepData?.label\}` | L157 |
| `./docs/agent-stream-5-state-draft.md` | `currentStep: number;` | L93 |
| `./docs/agent-stream-5-state-draft.md` | `currentStep: number` | L135 |
| `./docs/agent-stream-5-state-draft.md` | `): Promise<\{ formData: Record<string, unknown>; currentStep: number \} \| null>` | L140 |
| `./docs/agent-stream-5-state-draft.md` | `currentStep: 2,` | L195 |
| `./docs/implementation-stream-1-routes-auth.md` | `currentStep: number;` | L408 |
| `./docs/dynamic-form-rendering-prd.md` | `currentStep: number;` | L257 |


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Searching for currentStep in migrations****Investigating currentStep field mismatch**</details></think>

---

<tool-use data-tool-type="grep" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "currentStep" in "/Users/sahilmehta/supplier-onboarding-simple/prisma/schema.prisma" • 0 matches</summary>

Output mode: content


_No matches found_

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Refactoring form draft management and UI integration**

I'm updating how form drafts are loaded, saved, and displayed by restructuring draft-related types and server actions, enhancing the FormWizardClient to manage draft state and resume flows, and adjusting UI components like DraftResumeDialog to align with new draft metadata fields like lastSavedAt and title. This involves careful hooking of server actions to client with useTransition and ensuring props flow correctly through page and client components for smooth user draft experience.</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/sahilmehta/supplier-onboarding-simple/components/forms/form-wizard-client.tsx</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Updating form wizard and server route props**

I’m reworking the server-side page to provide all the new props `FormWizardClient` needs—like initial data, membership organization ID, and draft summaries—by fetching user session, membership, and drafts. I’m also planning to rename some props, confirm types, and consider shared logic between similar pages while keeping an eye on unused handlers like `onSaveDraft`. It’s a lot of orchestration to align client and server data properly!</details></think>

---

<tool-use data-tool-type="grep" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "onSaveDraft" in "/Users/sahilmehta/supplier-onboarding-simple/components/forms/dynamic-form-wizard.tsx" • 1 match</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `components/forms/dynamic-form-wizard.tsx` | `onSaveDraft=\{handleManualSave\}` | L416 |


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Checking interface consistency**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/sahilmehta/supplier-onboarding-simple/components/forms/dynamic-form-wizard.tsx</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Checking usage of organizationId prop**</details></think>

---

<tool-use data-tool-type="grep" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "organizationId" in "/Users/sahilmehta/supplier-onboarding-simple/components/forms/dynamic-form-wizard.tsx" • 4 matches</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `components/forms/dynamic-form-wizard.tsx` | `organizationId: string;` | L23 |
| `components/forms/dynamic-form-wizard.tsx` | `organizationId,` | L42 |
| `components/forms/dynamic-form-wizard.tsx` | `organizationId,` | L184 |
| `components/forms/dynamic-form-wizard.tsx` | `organizationId,` | L196 |


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Preparing to remove unused organizationId parameter**</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  &quot;relativeWorkspacePath&quot;: &quot;lib/forms/draft-manager.ts&quot;
}
```
Additional data:

```json
{
  &quot;codeblockId&quot;: &quot;fb94896c-1c09-46a0-b506-3fade63aa6ab&quot;,
  &quot;reviewData&quot;: {
    &quot;status&quot;: &quot;None&quot;,
    &quot;selectedOption&quot;: &quot;accept&quot;,
    &quot;isShowingInput&quot;: false,
    &quot;firstTimeReviewMode&quot;: false
  }
}
```
Result:

```json
{
  &quot;diff&quot;: {
    &quot;chunks&quot;: [
      {
        &quot;diffString&quot;: &quot;  export interface DraftSummary {\n    applicationId: string;\n-   updatedAt: string;\n+   formConfigId: string;\n+   title: string;\n+   lastSavedAt: string;\n    currentStep: number;\n+   totalSteps: number;\n  }\n  \n- export interface DraftRecord extends DraftSummary {\n+ export interface DraftRecord {\n+   applicationId: string;\n+   formConfigId: string;\n    formData: Record&lt;string, unknown&gt;;\n+   currentStep: number;\n+   lastSavedAt: string;\n  }\n  &quot;,
        &quot;oldStart&quot;: 15,
        &quot;newStart&quot;: 15,
        &quot;oldLines&quot;: 10,
        &quot;newLines&quot;: 17,
        &quot;linesRemoved&quot;: 2,
        &quot;linesAdded&quot;: 9
      },
      {
        &quot;diffString&quot;: &quot;  \n  function decodeDraftPayload(\n-   payload?: PersistedDraftPayload | null\n- ): DraftRecord {\n+   payload: PersistedDraftPayload | null | undefined,\n+   fallbackUpdatedAt: string\n+ ) {\n    const clonedPayload = { ...(payload ?? {}) };\n    const metaRaw = clonedPayload[DRAFT_META_KEY];&quot;,
        &quot;oldStart&quot;: 68,
        &quot;newStart&quot;: 75,
        &quot;oldLines&quot;: 6,
        &quot;newLines&quot;: 7,
        &quot;linesRemoved&quot;: 2,
        &quot;linesAdded&quot;: 3
      },
      {
        &quot;diffString&quot;: &quot;    const meta = (metaRaw as DraftMeta | undefined) ?? {\n      currentStep: 0,\n-     updatedAt: new Date(0).toISOString(),\n+     updatedAt: fallbackUpdatedAt,\n    };\n  \n    return {\n      formData: clonedPayload,\n      currentStep: Number.isFinite(meta.currentStep) ? meta.currentStep : 0,\n-     updatedAt: meta.updatedAt ?? new Date().toISOString(),\n-     applicationId: \&quot;\&quot;,\n-   } as DraftRecord;\n- }\n- \n- function attachApplicationId(\n-   record: DraftRecord,\n-   applicationId: string\n- ): DraftRecord {\n+     lastSavedAt: meta.updatedAt ?? fallbackUpdatedAt,\n+   };\n+ }\n+ \n+ function mapApplicationToRecord(application: {\n+   id: string;\n+   formConfigId: string | null;\n+   data: PersistedDraftPayload | null;\n+   updatedAt: Date;\n+ }): DraftRecord {\n+   const decoded = decodeDraftPayload(\n+     application.data,\n+     application.updatedAt.toISOString()\n+   );\n+ \n    return {\n-     ...record,\n-     applicationId,\n+     applicationId: application.id,\n+     formConfigId: application.formConfigId ?? \&quot;\&quot;,\n+     formData: decoded.formData,\n+     currentStep: decoded.currentStep,\n+     lastSavedAt: decoded.lastSavedAt ?? application.updatedAt.toISOString(),\n    };\n  }&quot;,
        &quot;oldStart&quot;: 76,
        &quot;newStart&quot;: 84,
        &quot;oldLines&quot;: 22,
        &quot;newLines&quot;: 31,
        &quot;linesRemoved&quot;: 12,
        &quot;linesAdded&quot;: 21
      },
      {
        &quot;diffString&quot;: &quot;          data: true,\n          updatedAt: true,\n+         formConfigId: true,\n        },\n      });\n  \n-     const record = decodeDraftPayload(updated.data as PersistedDraftPayload);\n-     record.updatedAt = updated.updatedAt.toISOString();\n-     return attachApplicationId(record, updated.id);\n+     return mapApplicationToRecord(updated);\n    }\n  &quot;,
        &quot;oldStart&quot;: 130,
        &quot;newStart&quot;: 147,
        &quot;oldLines&quot;: 10,
        &quot;newLines&quot;: 9,
        &quot;linesRemoved&quot;: 3,
        &quot;linesAdded&quot;: 2
      },
      {
        &quot;diffString&quot;: &quot;        data: true,\n        updatedAt: true,\n+       formConfigId: true,\n      },\n    });\n  \n-   const record = decodeDraftPayload(created.data as PersistedDraftPayload);\n-   record.updatedAt = created.updatedAt.toISOString();\n-   return attachApplicationId(record, created.id);\n+   return mapApplicationToRecord(created);\n  }\n  &quot;,
        &quot;oldStart&quot;: 153,
        &quot;newStart&quot;: 169,
        &quot;oldLines&quot;: 10,
        &quot;newLines&quot;: 9,
        &quot;linesRemoved&quot;: 3,
        &quot;linesAdded&quot;: 2
      },
      {
        &quot;diffString&quot;: &quot;        data: true,\n        updatedAt: true,\n+       formConfigId: true,\n      },\n    });&quot;,
        &quot;oldStart&quot;: 175,
        &quot;newStart&quot;: 190,
        &quot;oldLines&quot;: 4,
        &quot;newLines&quot;: 5,
        &quot;linesAdded&quot;: 1
      },
      {
        &quot;diffString&quot;: &quot;    }\n  \n-   const record = decodeDraftPayload(draft.data as PersistedDraftPayload);\n-   record.updatedAt = draft.updatedAt.toISOString();\n-   return attachApplicationId(record, draft.id);\n+   return mapApplicationToRecord(draft);\n  }\n  &quot;,
        &quot;oldStart&quot;: 182,
        &quot;newStart&quot;: 198,
        &quot;oldLines&quot;: 7,
        &quot;newLines&quot;: 5,
        &quot;linesRemoved&quot;: 3,
        &quot;linesAdded&quot;: 1
      },
      {
        &quot;diffString&quot;: &quot;        data: true,\n        updatedAt: true,\n+       formConfigId: true,\n+       formConfig: {\n+         select: {\n+           title: true,\n+           sections: {\n+             select: {\n+               id: true,\n+             },\n+           },\n+         },\n+       },\n      },\n    });\n  \n    return drafts.map((draft) =&gt; {\n-     const record = decodeDraftPayload(draft.data as PersistedDraftPayload);\n+     const decoded = decodeDraftPayload(\n+       draft.data as PersistedDraftPayload,\n+       draft.updatedAt.toISOString()\n+     );\n+ \n      return {\n        applicationId: draft.id,\n-       currentStep: record.currentStep,\n-       updatedAt: draft.updatedAt.toISOString(),\n+       formConfigId: draft.formConfigId ?? \&quot;\&quot;,\n+       title: draft.formConfig?.title ?? \&quot;Untitled Form\&quot;,\n+       currentStep: decoded.currentStep,\n+       lastSavedAt: draft.updatedAt.toISOString(),\n+       totalSteps: draft.formConfig?.sections.length ?? 0,\n      };\n    });&quot;,
        &quot;oldStart&quot;: 206,
        &quot;newStart&quot;: 220,
        &quot;oldLines&quot;: 13,
        &quot;newLines&quot;: 31,
        &quot;linesRemoved&quot;: 3,
        &quot;linesAdded&quot;: 21
      }
    ],
    &quot;editor&quot;: &quot;EDITOR_AI&quot;
  },
  &quot;shouldAutoFixLints&quot;: true,
  &quot;resultForModel&quot;: &quot;Success. Updated the following files:\nM lib/forms/draft-manager.ts&quot;,
  &quot;contentsAfterEdit&quot;: &quot;import { prisma } from \&quot;@/lib/prisma\&quot;;\n\nexport const DRAFT_META_KEY = \&quot;__draftMeta\&quot;;\n\ninterface DraftMeta {\n  currentStep: number;\n  updatedAt: string;\n}\n\ninterface PersistedDraftPayload {\n  [key: string]: unknown;\n  [DRAFT_META_KEY]?: DraftMeta;\n}\n\nexport interface DraftSummary {\n  applicationId: string;\n  formConfigId: string;\n  title: string;\n  lastSavedAt: string;\n  currentStep: number;\n  totalSteps: number;\n}\n\nexport interface DraftRecord {\n  applicationId: string;\n  formConfigId: string;\n  formData: Record&lt;string, unknown&gt;;\n  currentStep: number;\n  lastSavedAt: string;\n}\n\nexport interface SaveDraftOptions {\n  applicationId?: string | null;\n  formConfigId: string;\n  organizationId: string;\n  entityId: string;\n  geographyId: string;\n  userId: string;\n  formData: Record&lt;string, unknown&gt;;\n  currentStep: number;\n}\n\nexport interface LoadDraftOptions {\n  applicationId: string;\n  organizationId: string;\n  userId: string;\n}\n\nexport interface DraftQueryOptions {\n  formConfigId: string;\n  organizationId: string;\n  entityId: string;\n  geographyId: string;\n  userId: string;\n}\n\nexport interface DeleteDraftOptions {\n  applicationId: string;\n  organizationId: string;\n  userId: string;\n}\n\nfunction encodeDraftPayload(\n  formData: Record&lt;string, unknown&gt;,\n  currentStep: number\n): PersistedDraftPayload {\n  return {\n    ...formData,\n    [DRAFT_META_KEY]: {\n      currentStep,\n      updatedAt: new Date().toISOString(),\n    },\n  };\n}\n\nfunction decodeDraftPayload(\n  payload: PersistedDraftPayload | null | undefined,\n  fallbackUpdatedAt: string\n) {\n  const clonedPayload = { ...(payload ?? {}) };\n  const metaRaw = clonedPayload[DRAFT_META_KEY];\n  delete clonedPayload[DRAFT_META_KEY];\n\n  const meta = (metaRaw as DraftMeta | undefined) ?? {\n    currentStep: 0,\n    updatedAt: fallbackUpdatedAt,\n  };\n\n  return {\n    formData: clonedPayload,\n    currentStep: Number.isFinite(meta.currentStep) ? meta.currentStep : 0,\n    lastSavedAt: meta.updatedAt ?? fallbackUpdatedAt,\n  };\n}\n\nfunction mapApplicationToRecord(application: {\n  id: string;\n  formConfigId: string | null;\n  data: PersistedDraftPayload | null;\n  updatedAt: Date;\n}): DraftRecord {\n  const decoded = decodeDraftPayload(\n    application.data,\n    application.updatedAt.toISOString()\n  );\n\n  return {\n    applicationId: application.id,\n    formConfigId: application.formConfigId ?? \&quot;\&quot;,\n    formData: decoded.formData,\n    currentStep: decoded.currentStep,\n    lastSavedAt: decoded.lastSavedAt ?? application.updatedAt.toISOString(),\n  };\n}\n\nexport async function saveDraftRecord(\n  options: SaveDraftOptions\n): Promise&lt;DraftRecord&gt; {\n  const payload = encodeDraftPayload(options.formData, options.currentStep);\n\n  if (options.applicationId) {\n    const existing = await prisma.application.findFirst({\n      where: {\n        id: options.applicationId,\n        organizationId: options.organizationId,\n        createdById: options.userId,\n      },\n      select: { id: true },\n    });\n\n    if (!existing) {\n      throw new Error(\&quot;Draft not found or access denied\&quot;);\n    }\n\n    const updated = await prisma.application.update({\n      where: { id: options.applicationId },\n      data: {\n        data: payload,\n        formConfigId: options.formConfigId,\n        entityId: options.entityId,\n        geographyId: options.geographyId,\n        updatedById: options.userId,\n        status: \&quot;DRAFT\&quot;,\n      },\n      select: {\n        id: true,\n        data: true,\n        updatedAt: true,\n        formConfigId: true,\n      },\n    });\n\n    return mapApplicationToRecord(updated);\n  }\n\n  const created = await prisma.application.create({\n    data: {\n      organizationId: options.organizationId,\n      entityId: options.entityId,\n      geographyId: options.geographyId,\n      formConfigId: options.formConfigId,\n      status: \&quot;DRAFT\&quot;,\n      data: payload,\n      createdById: options.userId,\n      updatedById: options.userId,\n    },\n    select: {\n      id: true,\n      data: true,\n      updatedAt: true,\n      formConfigId: true,\n    },\n  });\n\n  return mapApplicationToRecord(created);\n}\n\nexport async function loadDraftRecord(\n  options: LoadDraftOptions\n): Promise&lt;DraftRecord | null&gt; {\n  const draft = await prisma.application.findFirst({\n    where: {\n      id: options.applicationId,\n      organizationId: options.organizationId,\n      createdById: options.userId,\n      status: \&quot;DRAFT\&quot;,\n    },\n    select: {\n      id: true,\n      data: true,\n      updatedAt: true,\n      formConfigId: true,\n    },\n  });\n\n  if (!draft) {\n    return null;\n  }\n\n  return mapApplicationToRecord(draft);\n}\n\nexport async function listDraftSummaries(\n  options: DraftQueryOptions\n): Promise&lt;DraftSummary[]&gt; {\n  const drafts = await prisma.application.findMany({\n    where: {\n      status: \&quot;DRAFT\&quot;,\n      organizationId: options.organizationId,\n      entityId: options.entityId,\n      geographyId: options.geographyId,\n      formConfigId: options.formConfigId,\n      createdById: options.userId,\n    },\n    orderBy: {\n      updatedAt: \&quot;desc\&quot;,\n    },\n    select: {\n      id: true,\n      data: true,\n      updatedAt: true,\n      formConfigId: true,\n      formConfig: {\n        select: {\n          title: true,\n          sections: {\n            select: {\n              id: true,\n            },\n          },\n        },\n      },\n    },\n  });\n\n  return drafts.map((draft) =&gt; {\n    const decoded = decodeDraftPayload(\n      draft.data as PersistedDraftPayload,\n      draft.updatedAt.toISOString()\n    );\n\n    return {\n      applicationId: draft.id,\n      formConfigId: draft.formConfigId ?? \&quot;\&quot;,\n      title: draft.formConfig?.title ?? \&quot;Untitled Form\&quot;,\n      currentStep: decoded.currentStep,\n      lastSavedAt: draft.updatedAt.toISOString(),\n      totalSteps: draft.formConfig?.sections.length ?? 0,\n    };\n  });\n}\n\nexport async function deleteDraftRecord(\n  options: DeleteDraftOptions\n): Promise&lt;void&gt; {\n  await prisma.application.deleteMany({\n    where: {\n      id: options.applicationId,\n      organizationId: options.organizationId,\n      createdById: options.userId,\n      status: \&quot;DRAFT\&quot;,\n    },\n  });\n}\n\n&quot;
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Ensuring consistent DraftRecord typing throughout**</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  &quot;relativeWorkspacePath&quot;: &quot;app/forms/actions.ts&quot;
}
```
Additional data:

```json
{
  &quot;codeblockId&quot;: &quot;02ace381-0fd9-4a57-8bc0-ddf1da63e2c0&quot;,
  &quot;reviewData&quot;: {
    &quot;status&quot;: &quot;None&quot;,
    &quot;selectedOption&quot;: &quot;accept&quot;,
    &quot;isShowingInput&quot;: false,
    &quot;firstTimeReviewMode&quot;: false
  }
}
```
Result:

```json
{
  &quot;diff&quot;: {
    &quot;chunks&quot;: [
      {
        &quot;diffString&quot;: &quot;  import {\n    deleteDraftRecord,\n+   listDraftSummaries,\n    loadDraftRecord,\n    saveDraftRecord,\n    type DraftRecord,\n+   type DraftSummary,\n  } from \&quot;@/lib/forms/draft-manager\&quot;;\n  &quot;,
        &quot;oldStart&quot;: 5,
        &quot;newStart&quot;: 5,
        &quot;oldLines&quot;: 7,
        &quot;newLines&quot;: 9,
        &quot;linesAdded&quot;: 2
      },
      {
        &quot;diffString&quot;: &quot;  \n  interface DeleteFormDraftInput extends LoadFormDraftInput {}\n+ \n+ interface ListDraftsInput {\n+   organizationId: string;\n+   formConfigId: string;\n+   entityId: string;\n+   geographyId: string;\n+ }\n  \n  async function ensureMembership(userId: string, organizationId: string) {&quot;,
        &quot;oldStart&quot;: 35,
        &quot;newStart&quot;: 37,
        &quot;oldLines&quot;: 4,
        &quot;newLines&quot;: 11,
        &quot;linesAdded&quot;: 7
      },
      {
        &quot;diffString&quot;: &quot;      applicationId: record.applicationId,\n      currentStep: record.currentStep,\n-     updatedAt: record.updatedAt,\n+     updatedAt: record.lastSavedAt,\n    };\n  }&quot;,
        &quot;oldStart&quot;: 72,
        &quot;newStart&quot;: 81,
        &quot;oldLines&quot;: 5,
        &quot;newLines&quot;: 5,
        &quot;linesRemoved&quot;: 1,
        &quot;linesAdded&quot;: 1
      },
      {
        &quot;diffString&quot;: &quot;    return { success: true };\n  }\n+ \n+ export async function getUserDrafts(\n+   input: ListDraftsInput\n+ ): Promise&lt;DraftSummary[]&gt; {\n+   const session = await auth();\n+   if (!session?.user?.id) {\n+     throw new Error(\&quot;Unauthorized\&quot;);\n+   }\n+ \n+   await ensureMembership(session.user.id, input.organizationId);\n+ \n+   return listDraftSummaries({\n+     formConfigId: input.formConfigId,\n+     organizationId: input.organizationId,\n+     entityId: input.entityId,\n+     geographyId: input.geographyId,\n+     userId: session.user.id,\n+   });\n+ }\n  \n  &quot;,
        &quot;oldStart&quot;: 110,
        &quot;newStart&quot;: 119,
        &quot;oldLines&quot;: 4,
        &quot;newLines&quot;: 23,
        &quot;linesAdded&quot;: 19
      }
    ],
    &quot;editor&quot;: &quot;EDITOR_AI&quot;
  },
  &quot;shouldAutoFixLints&quot;: true,
  &quot;resultForModel&quot;: &quot;Success. Updated the following files:\nM app/forms/actions.ts&quot;,
  &quot;contentsAfterEdit&quot;: &quot;\&quot;use server\&quot;;\n\nimport { auth } from \&quot;@/lib/auth\&quot;;\nimport { prisma } from \&quot;@/lib/prisma\&quot;;\nimport {\n  deleteDraftRecord,\n  listDraftSummaries,\n  loadDraftRecord,\n  saveDraftRecord,\n  type DraftRecord,\n  type DraftSummary,\n} from \&quot;@/lib/forms/draft-manager\&quot;;\n\ninterface SaveFormDraftInput {\n  formConfigId: string;\n  organizationId: string;\n  entityId: string;\n  geographyId: string;\n  applicationId?: string | null;\n  formData: Record&lt;string, unknown&gt;;\n  currentStep: number;\n}\n\nexport interface DraftSaveResult {\n  success: boolean;\n  applicationId: string;\n  currentStep: number;\n  updatedAt: string;\n}\n\nexport interface DraftLoadResult extends DraftRecord {}\n\ninterface LoadFormDraftInput {\n  organizationId: string;\n  applicationId: string;\n}\n\ninterface DeleteFormDraftInput extends LoadFormDraftInput {}\n\ninterface ListDraftsInput {\n  organizationId: string;\n  formConfigId: string;\n  entityId: string;\n  geographyId: string;\n}\n\nasync function ensureMembership(userId: string, organizationId: string) {\n  const membership = await prisma.membership.findFirst({\n    where: { userId, organizationId },\n    select: { id: true },\n  });\n\n  if (!membership) {\n    throw new Error(\&quot;Unauthorized\&quot;);\n  }\n}\n\nexport async function saveFormDraft(\n  input: SaveFormDraftInput\n): Promise&lt;DraftSaveResult&gt; {\n  const session = await auth();\n  if (!session?.user?.id) {\n    throw new Error(\&quot;Unauthorized\&quot;);\n  }\n\n  await ensureMembership(session.user.id, input.organizationId);\n\n  const record = await saveDraftRecord({\n    applicationId: input.applicationId,\n    formConfigId: input.formConfigId,\n    organizationId: input.organizationId,\n    entityId: input.entityId,\n    geographyId: input.geographyId,\n    formData: input.formData,\n    currentStep: input.currentStep,\n    userId: session.user.id,\n  });\n\n  return {\n    success: true,\n    applicationId: record.applicationId,\n    currentStep: record.currentStep,\n    updatedAt: record.lastSavedAt,\n  };\n}\n\nexport async function loadFormDraft(\n  input: LoadFormDraftInput\n): Promise&lt;DraftLoadResult | null&gt; {\n  const session = await auth();\n  if (!session?.user?.id) {\n    throw new Error(\&quot;Unauthorized\&quot;);\n  }\n\n  await ensureMembership(session.user.id, input.organizationId);\n\n  return loadDraftRecord({\n    applicationId: input.applicationId,\n    organizationId: input.organizationId,\n    userId: session.user.id,\n  });\n}\n\nexport async function deleteFormDraft(\n  input: DeleteFormDraftInput\n): Promise&lt;{ success: boolean }&gt; {\n  const session = await auth();\n  if (!session?.user?.id) {\n    throw new Error(\&quot;Unauthorized\&quot;);\n  }\n\n  await ensureMembership(session.user.id, input.organizationId);\n  await deleteDraftRecord({\n    applicationId: input.applicationId,\n    organizationId: input.organizationId,\n    userId: session.user.id,\n  });\n\n  return { success: true };\n}\n\nexport async function getUserDrafts(\n  input: ListDraftsInput\n): Promise&lt;DraftSummary[]&gt; {\n  const session = await auth();\n  if (!session?.user?.id) {\n    throw new Error(\&quot;Unauthorized\&quot;);\n  }\n\n  await ensureMembership(session.user.id, input.organizationId);\n\n  return listDraftSummaries({\n    formConfigId: input.formConfigId,\n    organizationId: input.organizationId,\n    entityId: input.entityId,\n    geographyId: input.geographyId,\n    userId: session.user.id,\n  });\n}\n\n&quot;
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Updating draft-resume-dialog component**</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  &quot;relativeWorkspacePath&quot;: &quot;components/forms/draft-resume-dialog.tsx&quot;
}
```
Additional data:

```json
{
  &quot;codeblockId&quot;: &quot;80057a6a-5c7f-4b1a-9481-95450214f426&quot;,
  &quot;reviewData&quot;: {
    &quot;status&quot;: &quot;None&quot;,
    &quot;selectedOption&quot;: &quot;accept&quot;,
    &quot;isShowingInput&quot;: false,
    &quot;firstTimeReviewMode&quot;: false
  }
}
```
Result:

```json
{
  &quot;diff&quot;: {
    &quot;chunks&quot;: [
      {
        &quot;diffString&quot;: &quot;                    &lt;div&gt;\n                      &lt;p className=\&quot;text-sm font-semibold\&quot;&gt;\n-                       Draft #{draft.applicationId.slice(0, 6).toUpperCase()}\n+                       {draft.title || \&quot;Untitled Form\&quot;}\n                      &lt;/p&gt;\n                      &lt;p className=\&quot;text-xs text-muted-foreground\&quot;&gt;\n-                       Step {draft.currentStep + 1} · Updated{\&quot; \&quot;}\n-                       {formatDistanceToNow(new Date(draft.updatedAt), {\n+                       Step {draft.currentStep + 1} of {draft.totalSteps} · Saved{\&quot; \&quot;}\n+                       {formatDistanceToNow(new Date(draft.lastSavedAt), {\n                          addSuffix: true,\n                        })}&quot;,
        &quot;oldStart&quot;: 118,
        &quot;newStart&quot;: 118,
        &quot;oldLines&quot;: 9,
        &quot;newLines&quot;: 9,
        &quot;linesRemoved&quot;: 3,
        &quot;linesAdded&quot;: 3
      }
    ],
    &quot;editor&quot;: &quot;EDITOR_AI&quot;
  },
  &quot;shouldAutoFixLints&quot;: true,
  &quot;resultForModel&quot;: &quot;Success. Updated the following files:\nM components/forms/draft-resume-dialog.tsx&quot;,
  &quot;contentsAfterEdit&quot;: &quot;\&quot;use client\&quot;;\n\nimport { useCallback, useState } from \&quot;react\&quot;;\nimport { formatDistanceToNow } from \&quot;date-fns\&quot;;\nimport { Loader2, Trash2 } from \&quot;lucide-react\&quot;;\nimport type { DraftSummary } from \&quot;@/lib/forms/draft-manager\&quot;;\nimport {\n  Dialog,\n  DialogContent,\n  DialogDescription,\n  DialogHeader,\n  DialogTitle,\n  DialogTrigger,\n} from \&quot;@/components/ui/dialog\&quot;;\nimport { Button } from \&quot;@/components/ui/button\&quot;;\n\ninterface DraftResumeDialogProps {\n  drafts: DraftSummary[];\n  open?: boolean;\n  onOpenChange?: (open: boolean) =&gt; void;\n  onSelectDraft: (applicationId: string | null) =&gt; Promise&lt;void&gt; | void;\n  onDeleteDraft: (applicationId: string) =&gt; Promise&lt;void&gt; | void;\n  triggerLabel?: string;\n}\n\nexport function DraftResumeDialog({\n  drafts,\n  open,\n  onOpenChange,\n  onSelectDraft,\n  onDeleteDraft,\n  triggerLabel = \&quot;Resume draft\&quot;,\n}: DraftResumeDialogProps) {\n  const [isOpen, setIsOpen] = useState(open ?? false);\n  const [resumingId, setResumingId] = useState&lt;string | null&gt;(null);\n  const [deletingId, setDeletingId] = useState&lt;string | null&gt;(null);\n  const [error, setError] = useState&lt;string | null&gt;(null);\n\n  const handleOpenChange = useCallback(\n    (nextOpen: boolean) =&gt; {\n      setIsOpen(nextOpen);\n      onOpenChange?.(nextOpen);\n      if (!nextOpen) {\n        setError(null);\n      }\n    },\n    [onOpenChange]\n  );\n\n  const handleSelect = useCallback(\n    async (applicationId: string | null) =&gt; {\n      setResumingId(applicationId ?? \&quot;new\&quot;);\n      setError(null);\n      try {\n        await onSelectDraft(applicationId);\n        handleOpenChange(false);\n      } catch (err) {\n        console.error(\&quot;Failed to select draft\&quot;, err);\n        setError(\n          err instanceof Error ? err.message : \&quot;Failed to resume draft. Try again.\&quot;\n        );\n      } finally {\n        setResumingId(null);\n      }\n    },\n    [handleOpenChange, onSelectDraft]\n  );\n\n  const handleDelete = useCallback(\n    async (applicationId: string) =&gt; {\n      setDeletingId(applicationId);\n      setError(null);\n      try {\n        await onDeleteDraft(applicationId);\n      } catch (err) {\n        console.error(\&quot;Failed to delete draft\&quot;, err);\n        setError(\n          err instanceof Error ? err.message : \&quot;Failed to delete draft. Try again.\&quot;\n        );\n      } finally {\n        setDeletingId(null);\n      }\n    },\n    [onDeleteDraft]\n  );\n\n  if (drafts.length === 0) {\n    return null;\n  }\n\n  return (\n    &lt;Dialog open={isOpen} onOpenChange={handleOpenChange}&gt;\n      &lt;DialogTrigger asChild&gt;\n        &lt;Button variant=\&quot;outline\&quot; size=\&quot;sm\&quot;&gt;\n          {triggerLabel}\n        &lt;/Button&gt;\n      &lt;/DialogTrigger&gt;\n      &lt;DialogContent className=\&quot;sm:max-w-lg\&quot;&gt;\n        &lt;DialogHeader&gt;\n          &lt;DialogTitle&gt;Resume a saved draft&lt;/DialogTitle&gt;\n          &lt;DialogDescription&gt;\n            Choose an existing draft to continue or start a new submission.\n          &lt;/DialogDescription&gt;\n        &lt;/DialogHeader&gt;\n        &lt;div className=\&quot;max-h-80 space-y-3 overflow-y-auto py-2 pr-2\&quot;&gt;\n          {drafts.map((draft) =&gt; {\n            const isResuming =\n              resumingId !== null &amp;&amp;\n              (resumingId === draft.applicationId || resumingId === \&quot;new\&quot;);\n            const isDeleting = deletingId === draft.applicationId;\n\n            return (\n              &lt;div\n                key={draft.applicationId}\n                className=\&quot;rounded-lg border border-border/60 p-4\&quot;\n              &gt;\n                &lt;div className=\&quot;flex items-center justify-between gap-4\&quot;&gt;\n                  &lt;div&gt;\n                    &lt;p className=\&quot;text-sm font-semibold\&quot;&gt;\n                      {draft.title || \&quot;Untitled Form\&quot;}\n                    &lt;/p&gt;\n                    &lt;p className=\&quot;text-xs text-muted-foreground\&quot;&gt;\n                      Step {draft.currentStep + 1} of {draft.totalSteps} · Saved{\&quot; \&quot;}\n                      {formatDistanceToNow(new Date(draft.lastSavedAt), {\n                        addSuffix: true,\n                      })}\n                    &lt;/p&gt;\n                  &lt;/div&gt;\n                  &lt;div className=\&quot;flex items-center gap-2\&quot;&gt;\n                    &lt;Button\n                      type=\&quot;button\&quot;\n                      size=\&quot;sm\&quot;\n                      onClick={() =&gt; void handleSelect(draft.applicationId)}\n                      disabled={isDeleting || resumingId !== null}\n                    &gt;\n                      {isResuming &amp;&amp; (\n                        &lt;Loader2 className=\&quot;mr-2 size-3 animate-spin\&quot; /&gt;\n                      )}\n                      Resume\n                    &lt;/Button&gt;\n                    &lt;Button\n                      type=\&quot;button\&quot;\n                      variant=\&quot;ghost\&quot;\n                      size=\&quot;icon\&quot;\n                      onClick={() =&gt; void handleDelete(draft.applicationId)}\n                      disabled={isDeleting || resumingId !== null}\n                      aria-label=\&quot;Delete draft\&quot;\n                    &gt;\n                      {isDeleting ? (\n                        &lt;Loader2 className=\&quot;size-4 animate-spin\&quot; /&gt;\n                      ) : (\n                        &lt;Trash2 className=\&quot;size-4 text-muted-foreground\&quot; /&gt;\n                      )}\n                    &lt;/Button&gt;\n                  &lt;/div&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            );\n          })}\n        &lt;/div&gt;\n        &lt;div className=\&quot;flex flex-col gap-3 border-t border-border/60 pt-4\&quot;&gt;\n          {error &amp;&amp; &lt;p className=\&quot;text-sm text-red-600\&quot;&gt;{error}&lt;/p&gt;}\n          &lt;Button\n            type=\&quot;button\&quot;\n            variant=\&quot;secondary\&quot;\n            onClick={() =&gt; void handleSelect(null)}\n            disabled={resumingId !== null}\n          &gt;\n            {resumingId === \&quot;new\&quot; &amp;&amp; (\n              &lt;Loader2 className=\&quot;mr-2 size-3 animate-spin\&quot; /&gt;\n            )}\n            Start new submission\n          &lt;/Button&gt;\n        &lt;/div&gt;\n      &lt;/DialogContent&gt;\n    &lt;/Dialog&gt;\n  );\n}\n\n&quot;
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Rewriting FormWizardClient with draft management**

I'm rewriting the entire FormWizardClient to handle draft loading, saving, and deletion with proper state management and server actions, using startTransition carefully for async updates and ensuring the dialog shows only when drafts exist.</details></think>

---

<tool-use data-tool-type="bash" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **command** • Run command: cd /Users/sahilmehta/supplier-onboarding-simple && cat <<'EOF' > components/forms/form-wizard-client.tsx
"use client";

import { useCallback, useMemo, useState, useTransition } from "react";
import { loadFormDraft, deleteFormDraft, type DraftSaveResult } from "@/app/forms/actions";
import type { DraftSummary } from "@/lib/forms/draft-manager";
import type { FormConfigWithFields } from "@/lib/forms/types";
import { useToast } from "@/components/ui/use-toast";
import { DraftResumeDialog } from "./draft-resume-dialog";
import { DynamicFormWizard } from "./dynamic-form-wizard";

interface FormWizardClientProps {
  formConfig: FormConfigWithFields;
  organizationId: string;
  initialData?: Record<string, unknown>;
  initialStep?: number;
  initialApplicationId?: string | null;
  drafts?: DraftSummary[];
}

export function FormWizardClient({
  formConfig,
  organizationId,
  initialData = {},
  initialStep = 0,
  initialApplicationId = null,
  drafts: initialDrafts = [],
}: FormWizardClientProps) {
  const { toast } = useToast();
  const [applicationId, setApplicationId] = useState<string | null>(
    initialApplicationId
  );
  const [seedData, setSeedData] = useState<Record<string, unknown>>(initialData);
  const [seedStep, setSeedStep] = useState<number>(initialStep);
  const [drafts, setDrafts] = useState<DraftSummary[]>(initialDrafts);
  const [isPending, startTransition] = useTransition();

  const totalSteps = useMemo(() => formConfig.sections.length, [formConfig.sections.length]);

  const handleApplicationIdChange = useCallback((nextId: string) => {
    setApplicationId(nextId);
  }, []);

  const handleDraftSaved = useCallback(
    (result: DraftSaveResult) => {
      const summary: DraftSummary = {
        applicationId: result.applicationId,
        formConfigId: formConfig.id,
        title: formConfig.title ?? "Untitled Form",
        currentStep: result.currentStep ?? 0,
        lastSavedAt: result.updatedAt,
        totalSteps,
      };

      setDrafts((prev) => {
        const filtered = prev.filter(
          (draft) => draft.applicationId !== summary.applicationId
        );
        return [summary, ...filtered];
      });
    },
    [formConfig.id, formConfig.title, totalSteps]
  );

  const resetToBlank = useCallback(() => {
    setSeedData({});
    setSeedStep(0);
    setApplicationId(null);
  }, []);

  const handleSelectDraft = useCallback(
    async (selectedId: string | null) => {
      if (!selectedId) {
        resetToBlank();
        return;
      }

      await new Promise<void>((resolve, reject) => {
        startTransition(() => {
          loadFormDraft({
            applicationId: selectedId,
            organizationId,
          })
            .then((draft) => {
              if (!draft) {
                throw new Error("Draft could not be loaded.");
              }
              setApplicationId(draft.applicationId);
              setSeedData(draft.formData ?? {});
              setSeedStep(draft.currentStep ?? 0);
              resolve();
            })
            .catch((error) => {
              toast({
                variant: "destructive",
                title: "Unable to resume draft",
                description:
                  error instanceof Error ? error.message : "Unknown error.",
              });
              reject(error);
            });
        });
      });
    },
    [organizationId, resetToBlank, startTransition, toast]
  );

  const handleDeleteDraft = useCallback(
    async (draftId: string) => {
      await new Promise<void>((resolve, reject) => {
        startTransition(() => {
          deleteFormDraft({
            applicationId: draftId,
            organizationId,
          })
            .then(() => {
              setDrafts((prev) =>
                prev.filter((draft) => draft.applicationId !== draftId)
              );
              if (applicationId === draftId) {
                resetToBlank();
              }
              resolve();
            })
            .catch((error) => {
              toast({
                variant: "destructive",
                title: "Unable to delete draft",
                description:
                  error instanceof Error ? error.message : "Unknown error.",
              });
              reject(error);
            });
        });
      });
    },
    [applicationId, organizationId, resetToBlank, startTransition, toast]
  );

  const handleComplete = useCallback(async (formData: Record<string, unknown>) => {
    console.log("Form completed with data:", formData);
  }, []);

  return (
    <div className="space-y-4">
      {drafts.length > 0 && (
        <div className="flex justify-end">
          <DraftResumeDialog
            drafts={drafts}
            onSelectDraft={handleSelectDraft}
            onDeleteDraft={handleDeleteDraft}
            triggerLabel={isPending ? "Working…" : "Resume draft"}
          />
        </div>
      )}

      <DynamicFormWizard
        key={applicationId ?? "new"}
        formConfig={formConfig}
        organizationId={organizationId}
        initialData={seedData}
        initialStep={seedStep}
        applicationId={applicationId}
        onApplicationIdChange={handleApplicationIdChange}
        onDraftSaved={handleDraftSaved}
        onComplete={handleComplete}
      />
    </div>
  );
}
EOF</summary>

```bash
cd /Users/sahilmehta/supplier-onboarding-simple && cat <<'EOF' > components/forms/form-wizard-client.tsx
"use client";

import { useCallback, useMemo, useState, useTransition } from "react";
import { loadFormDraft, deleteFormDraft, type DraftSaveResult } from "@/app/forms/actions";
import type { DraftSummary } from "@/lib/forms/draft-manager";
import type { FormConfigWithFields } from "@/lib/forms/types";
import { useToast } from "@/components/ui/use-toast";
import { DraftResumeDialog } from "./draft-resume-dialog";
import { DynamicFormWizard } from "./dynamic-form-wizard";

interface FormWizardClientProps {
  formConfig: FormConfigWithFields;
  organizationId: string;
  initialData?: Record<string, unknown>;
  initialStep?: number;
  initialApplicationId?: string | null;
  drafts?: DraftSummary[];
}

export function FormWizardClient({
  formConfig,
  organizationId,
  initialData = {},
  initialStep = 0,
  initialApplicationId = null,
  drafts: initialDrafts = [],
}: FormWizardClientProps) {
  const { toast } = useToast();
  const [applicationId, setApplicationId] = useState<string | null>(
    initialApplicationId
  );
  const [seedData, setSeedData] = useState<Record<string, unknown>>(initialData);
  const [seedStep, setSeedStep] = useState<number>(initialStep);
  const [drafts, setDrafts] = useState<DraftSummary[]>(initialDrafts);
  const [isPending, startTransition] = useTransition();

  const totalSteps = useMemo(() => formConfig.sections.length, [formConfig.sections.length]);

  const handleApplicationIdChange = useCallback((nextId: string) => {
    setApplicationId(nextId);
  }, []);

  const handleDraftSaved = useCallback(
    (result: DraftSaveResult) => {
      const summary: DraftSummary = {
        applicationId: result.applicationId,
        formConfigId: formConfig.id,
        title: formConfig.title ?? "Untitled Form",
        currentStep: result.currentStep ?? 0,
        lastSavedAt: result.updatedAt,
        totalSteps,
      };

      setDrafts((prev) => {
        const filtered = prev.filter(
          (draft) => draft.applicationId !== summary.applicationId
        );
        return [summary, ...filtered];
      });
    },
    [formConfig.id, formConfig.title, totalSteps]
  );

  const resetToBlank = useCallback(() => {
    setSeedData({});
    setSeedStep(0);
    setApplicationId(null);
  }, []);

  const handleSelectDraft = useCallback(
    async (selectedId: string | null) => {
      if (!selectedId) {
        resetToBlank();
        return;
      }

      await new Promise<void>((resolve, reject) => {
        startTransition(() => {
          loadFormDraft({
            applicationId: selectedId,
            organizationId,
          })
            .then((draft) => {
              if (!draft) {
                throw new Error("Draft could not be loaded.");
              }
              setApplicationId(draft.applicationId);
              setSeedData(draft.formData ?? {});
              setSeedStep(draft.currentStep ?? 0);
              resolve();
            })
            .catch((error) => {
              toast({
                variant: "destructive",
                title: "Unable to resume draft",
                description:
                  error instanceof Error ? error.message : "Unknown error.",
              });
              reject(error);
            });
        });
      });
    },
    [organizationId, resetToBlank, startTransition, toast]
  );

  const handleDeleteDraft = useCallback(
    async (draftId: string) => {
      await new Promise<void>((resolve, reject) => {
        startTransition(() => {
          deleteFormDraft({
            applicationId: draftId,
            organizationId,
          })
            .then(() => {
              setDrafts((prev) =>
                prev.filter((draft) => draft.applicationId !== draftId)
              );
              if (applicationId === draftId) {
                resetToBlank();
              }
              resolve();
            })
            .catch((error) => {
              toast({
                variant: "destructive",
                title: "Unable to delete draft",
                description:
                  error instanceof Error ? error.message : "Unknown error.",
              });
              reject(error);
            });
        });
      });
    },
    [applicationId, organizationId, resetToBlank, startTransition, toast]
  );

  const handleComplete = useCallback(async (formData: Record<string, unknown>) => {
    console.log("Form completed with data:", formData);
  }, []);

  return (
    <div className="space-y-4">
      {drafts.length > 0 && (
        <div className="flex justify-end">
          <DraftResumeDialog
            drafts={drafts}
            onSelectDraft={handleSelectDraft}
            onDeleteDraft={handleDeleteDraft}
            triggerLabel={isPending ? "Working…" : "Resume draft"}
          />
        </div>
      )}

      <DynamicFormWizard
        key={applicationId ?? "new"}
        formConfig={formConfig}
        organizationId={organizationId}
        initialData={seedData}
        initialStep={seedStep}
        applicationId={applicationId}
        onApplicationIdChange={handleApplicationIdChange}
        onDraftSaved={handleDraftSaved}
        onComplete={handleComplete}
      />
    </div>
  );
}
EOF
```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Clarifying React hooks and component keys**

I’m untangling how `useMemo` dependencies work with properties like `formConfig.sections.length` and deciding to simplify by computing the length directly since sections are stable. I’m also reconsidering removing the `key` prop tied to `applicationId` to avoid unwanted remounts that could wipe user input, relying instead on a reset effect. Additionally, I’m wrapping server actions with `startTransition` and promises properly while handling pending states thoughtfully, all while cleaning up TypeScript and imports.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  &quot;relativeWorkspacePath&quot;: &quot;components/forms/form-wizard-client.tsx&quot;
}
```
Additional data:

```json
{
  &quot;codeblockId&quot;: &quot;1b8006fb-9b27-4cf9-b9ae-8eb2917b37e4&quot;,
  &quot;reviewData&quot;: {
    &quot;status&quot;: &quot;None&quot;,
    &quot;selectedOption&quot;: &quot;accept&quot;,
    &quot;isShowingInput&quot;: false,
    &quot;firstTimeReviewMode&quot;: false
  }
}
```
Result:

```json
{
  &quot;diff&quot;: {
    &quot;chunks&quot;: [
      {
        &quot;diffString&quot;: &quot;  \&quot;use client\&quot;;\n  \n- import { useCallback, useMemo, useState, useTransition } from \&quot;react\&quot;;\n+ import { useCallback, useState, useTransition } from \&quot;react\&quot;;\n  import { loadFormDraft, deleteFormDraft, type DraftSaveResult } from \&quot;@/app/forms/actions\&quot;;\n  import type { DraftSummary } from \&quot;@/lib/forms/draft-manager\&quot;;&quot;,
        &quot;oldStart&quot;: 1,
        &quot;newStart&quot;: 1,
        &quot;oldLines&quot;: 5,
        &quot;newLines&quot;: 5,
        &quot;linesRemoved&quot;: 1,
        &quot;linesAdded&quot;: 1
      },
      {
        &quot;diffString&quot;: &quot;    const [isPending, startTransition] = useTransition();\n  \n-   const totalSteps = useMemo(() =&gt; formConfig.sections.length, [formConfig.sections.length]);\n+   const totalSteps = formConfig.sections.length;\n  \n    const handleApplicationIdChange = useCallback((nextId: string) =&gt; {&quot;,
        &quot;oldStart&quot;: 35,
        &quot;newStart&quot;: 35,
        &quot;oldLines&quot;: 5,
        &quot;newLines&quot;: 5,
        &quot;linesRemoved&quot;: 1,
        &quot;linesAdded&quot;: 1
      },
      {
        &quot;diffString&quot;: &quot;  \n        &lt;DynamicFormWizard\n-         key={applicationId ?? \&quot;new\&quot;}\n          formConfig={formConfig}\n          organizationId={organizationId}&quot;,
        &quot;oldStart&quot;: 155,
        &quot;newStart&quot;: 155,
        &quot;oldLines&quot;: 5,
        &quot;newLines&quot;: 4,
        &quot;linesRemoved&quot;: 1
      }
    ],
    &quot;editor&quot;: &quot;EDITOR_AI&quot;
  },
  &quot;shouldAutoFixLints&quot;: true,
  &quot;resultForModel&quot;: &quot;Success. Updated the following files:\nM components/forms/form-wizard-client.tsx&quot;,
  &quot;contentsAfterEdit&quot;: &quot;\&quot;use client\&quot;;\n\nimport { useCallback, useState, useTransition } from \&quot;react\&quot;;\nimport { loadFormDraft, deleteFormDraft, type DraftSaveResult } from \&quot;@/app/forms/actions\&quot;;\nimport type { DraftSummary } from \&quot;@/lib/forms/draft-manager\&quot;;\nimport type { FormConfigWithFields } from \&quot;@/lib/forms/types\&quot;;\nimport { useToast } from \&quot;@/components/ui/use-toast\&quot;;\nimport { DraftResumeDialog } from \&quot;./draft-resume-dialog\&quot;;\nimport { DynamicFormWizard } from \&quot;./dynamic-form-wizard\&quot;;\n\ninterface FormWizardClientProps {\n  formConfig: FormConfigWithFields;\n  organizationId: string;\n  initialData?: Record&lt;string, unknown&gt;;\n  initialStep?: number;\n  initialApplicationId?: string | null;\n  drafts?: DraftSummary[];\n}\n\nexport function FormWizardClient({\n  formConfig,\n  organizationId,\n  initialData = {},\n  initialStep = 0,\n  initialApplicationId = null,\n  drafts: initialDrafts = [],\n}: FormWizardClientProps) {\n  const { toast } = useToast();\n  const [applicationId, setApplicationId] = useState&lt;string | null&gt;(\n    initialApplicationId\n  );\n  const [seedData, setSeedData] = useState&lt;Record&lt;string, unknown&gt;&gt;(initialData);\n  const [seedStep, setSeedStep] = useState&lt;number&gt;(initialStep);\n  const [drafts, setDrafts] = useState&lt;DraftSummary[]&gt;(initialDrafts);\n  const [isPending, startTransition] = useTransition();\n\n  const totalSteps = formConfig.sections.length;\n\n  const handleApplicationIdChange = useCallback((nextId: string) =&gt; {\n    setApplicationId(nextId);\n  }, []);\n\n  const handleDraftSaved = useCallback(\n    (result: DraftSaveResult) =&gt; {\n      const summary: DraftSummary = {\n        applicationId: result.applicationId,\n        formConfigId: formConfig.id,\n        title: formConfig.title ?? \&quot;Untitled Form\&quot;,\n        currentStep: result.currentStep ?? 0,\n        lastSavedAt: result.updatedAt,\n        totalSteps,\n      };\n\n      setDrafts((prev) =&gt; {\n        const filtered = prev.filter(\n          (draft) =&gt; draft.applicationId !== summary.applicationId\n        );\n        return [summary, ...filtered];\n      });\n    },\n    [formConfig.id, formConfig.title, totalSteps]\n  );\n\n  const resetToBlank = useCallback(() =&gt; {\n    setSeedData({});\n    setSeedStep(0);\n    setApplicationId(null);\n  }, []);\n\n  const handleSelectDraft = useCallback(\n    async (selectedId: string | null) =&gt; {\n      if (!selectedId) {\n        resetToBlank();\n        return;\n      }\n\n      await new Promise&lt;void&gt;((resolve, reject) =&gt; {\n        startTransition(() =&gt; {\n          loadFormDraft({\n            applicationId: selectedId,\n            organizationId,\n          })\n            .then((draft) =&gt; {\n              if (!draft) {\n                throw new Error(\&quot;Draft could not be loaded.\&quot;);\n              }\n              setApplicationId(draft.applicationId);\n              setSeedData(draft.formData ?? {});\n              setSeedStep(draft.currentStep ?? 0);\n              resolve();\n            })\n            .catch((error) =&gt; {\n              toast({\n                variant: \&quot;destructive\&quot;,\n                title: \&quot;Unable to resume draft\&quot;,\n                description:\n                  error instanceof Error ? error.message : \&quot;Unknown error.\&quot;,\n              });\n              reject(error);\n            });\n        });\n      });\n    },\n    [organizationId, resetToBlank, startTransition, toast]\n  );\n\n  const handleDeleteDraft = useCallback(\n    async (draftId: string) =&gt; {\n      await new Promise&lt;void&gt;((resolve, reject) =&gt; {\n        startTransition(() =&gt; {\n          deleteFormDraft({\n            applicationId: draftId,\n            organizationId,\n          })\n            .then(() =&gt; {\n              setDrafts((prev) =&gt;\n                prev.filter((draft) =&gt; draft.applicationId !== draftId)\n              );\n              if (applicationId === draftId) {\n                resetToBlank();\n              }\n              resolve();\n            })\n            .catch((error) =&gt; {\n              toast({\n                variant: \&quot;destructive\&quot;,\n                title: \&quot;Unable to delete draft\&quot;,\n                description:\n                  error instanceof Error ? error.message : \&quot;Unknown error.\&quot;,\n              });\n              reject(error);\n            });\n        });\n      });\n    },\n    [applicationId, organizationId, resetToBlank, startTransition, toast]\n  );\n\n  const handleComplete = useCallback(async (formData: Record&lt;string, unknown&gt;) =&gt; {\n    console.log(\&quot;Form completed with data:\&quot;, formData);\n  }, []);\n\n  return (\n    &lt;div className=\&quot;space-y-4\&quot;&gt;\n      {drafts.length &gt; 0 &amp;&amp; (\n        &lt;div className=\&quot;flex justify-end\&quot;&gt;\n          &lt;DraftResumeDialog\n            drafts={drafts}\n            onSelectDraft={handleSelectDraft}\n            onDeleteDraft={handleDeleteDraft}\n            triggerLabel={isPending ? \&quot;Working…\&quot; : \&quot;Resume draft\&quot;}\n          /&gt;\n        &lt;/div&gt;\n      )}\n\n      &lt;DynamicFormWizard\n        formConfig={formConfig}\n        organizationId={organizationId}\n        initialData={seedData}\n        initialStep={seedStep}\n        applicationId={applicationId}\n        onApplicationIdChange={handleApplicationIdChange}\n        onDraftSaved={handleDraftSaved}\n        onComplete={handleComplete}\n      /&gt;\n    &lt;/div&gt;\n  );\n}\n&quot;
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Refactoring draft management and server components**

I'm setting up proper Promise returns for draft-related handlers and ensuring `useTransition` manages async state updates smoothly. Then, I’m updating two route pages to import necessary server helpers and carefully load user, membership, form config, and draft data on the server side to render `FormWizardClient` with the right props, handling redirects or 404s as needed. This will tighten the flow between session, membership, and draft loading with clear fallbacks.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  &quot;relativeWorkspacePath&quot;: &quot;app/forms/[formConfigId]/page.tsx&quot;
}
```
Additional data:

```json
{
  &quot;codeblockId&quot;: &quot;d904504b-3f0f-4e9d-a201-29a222a4397f&quot;,
  &quot;reviewData&quot;: {
    &quot;status&quot;: &quot;None&quot;,
    &quot;selectedOption&quot;: &quot;accept&quot;,
    &quot;isShowingInput&quot;: false,
    &quot;firstTimeReviewMode&quot;: false
  }
}
```
Result:

```json
{
  &quot;diff&quot;: {
    &quot;chunks&quot;: [
      {
        &quot;diffString&quot;: &quot;  import { getFormConfigById } from \&quot;@/lib/forms/form-config-fetcher\&quot;;\n  import { FormWizardClient } from \&quot;@/components/forms/form-wizard-client\&quot;;\n+ import { getCurrentUserMembership } from \&quot;@/lib/permissions\&quot;;\n+ import {\n+   listDraftSummaries,\n+   loadDraftRecord,\n+ } from \&quot;@/lib/forms/draft-manager\&quot;;\n  \n  interface Params {&quot;,
        &quot;oldStart&quot;: 4,
        &quot;newStart&quot;: 4,
        &quot;oldLines&quot;: 4,
        &quot;newLines&quot;: 9,
        &quot;linesAdded&quot;: 5
      },
      {
        &quot;diffString&quot;: &quot;      redirect(\&quot;/signin\&quot;);\n    }\n+ \n+   const membership = await getCurrentUserMembership();\n+   if (!membership) {\n+     redirect(\&quot;/signin\&quot;);\n+   }\n  \n    // Fetch form config&quot;,
        &quot;oldStart&quot;: 21,
        &quot;newStart&quot;: 26,
        &quot;oldLines&quot;: 4,
        &quot;newLines&quot;: 9,
        &quot;linesAdded&quot;: 5
      },
      {
        &quot;diffString&quot;: &quot;    }\n  \n+   const drafts = await listDraftSummaries({\n+     formConfigId: formConfig.id,\n+     organizationId: membership.organizationId,\n+     entityId: formConfig.entityId,\n+     geographyId: formConfig.geographyId,\n+     userId: session.user.id,\n+   });\n+ \n+   const initialDraft =\n+     drafts.length &gt; 0\n+       ? await loadDraftRecord({\n+           applicationId: drafts[0].applicationId,\n+           organizationId: membership.organizationId,\n+           userId: session.user.id,\n+         })\n+       : null;\n+ \n    return (\n      &lt;div className=\&quot;container mx-auto w-full max-w-5xl px-4 py-10\&quot;&gt;&quot;,
        &quot;oldStart&quot;: 29,
        &quot;newStart&quot;: 39,
        &quot;oldLines&quot;: 4,
        &quot;newLines&quot;: 21,
        &quot;linesAdded&quot;: 17
      },
      {
        &quot;diffString&quot;: &quot;            )}\n          &lt;/header&gt;\n-         &lt;FormWizardClient formConfig={formConfig} /&gt;\n+         &lt;FormWizardClient\n+           formConfig={formConfig}\n+           organizationId={membership.organizationId}\n+           initialData={initialDraft?.formData ?? {}}\n+           initialStep={initialDraft?.currentStep ?? 0}\n+           initialApplicationId={initialDraft?.applicationId ?? null}\n+           drafts={drafts}\n+         /&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;&quot;,
        &quot;oldStart&quot;: 50,
        &quot;newStart&quot;: 77,
        &quot;oldLines&quot;: 5,
        &quot;newLines&quot;: 12,
        &quot;linesRemoved&quot;: 1,
        &quot;linesAdded&quot;: 8
      }
    ],
    &quot;editor&quot;: &quot;EDITOR_AI&quot;
  },
  &quot;shouldAutoFixLints&quot;: true,
  &quot;resultForModel&quot;: &quot;Success. Updated the following files:\nM app/forms/[formConfigId]/page.tsx&quot;,
  &quot;contentsAfterEdit&quot;: &quot;import { redirect } from \&quot;next/navigation\&quot;;\nimport { notFound } from \&quot;next/navigation\&quot;;\nimport { auth } from \&quot;@/lib/auth\&quot;;\nimport { getFormConfigById } from \&quot;@/lib/forms/form-config-fetcher\&quot;;\nimport { FormWizardClient } from \&quot;@/components/forms/form-wizard-client\&quot;;\nimport { getCurrentUserMembership } from \&quot;@/lib/permissions\&quot;;\nimport {\n  listDraftSummaries,\n  loadDraftRecord,\n} from \&quot;@/lib/forms/draft-manager\&quot;;\n\ninterface Params {\n  formConfigId: string;\n}\n\nexport default async function FormByConfigIdPage({\n  params,\n}: {\n  params: Promise&lt;Params&gt;;\n}) {\n  const { formConfigId } = await params;\n  const session = await auth();\n\n  // Authentication check\n  if (!session?.user?.id) {\n    redirect(\&quot;/signin\&quot;);\n  }\n\n  const membership = await getCurrentUserMembership();\n  if (!membership) {\n    redirect(\&quot;/signin\&quot;);\n  }\n\n  // Fetch form config\n  const formConfig = await getFormConfigById(formConfigId);\n\n  if (!formConfig) {\n    notFound();\n  }\n\n  const drafts = await listDraftSummaries({\n    formConfigId: formConfig.id,\n    organizationId: membership.organizationId,\n    entityId: formConfig.entityId,\n    geographyId: formConfig.geographyId,\n    userId: session.user.id,\n  });\n\n  const initialDraft =\n    drafts.length &gt; 0\n      ? await loadDraftRecord({\n          applicationId: drafts[0].applicationId,\n          organizationId: membership.organizationId,\n          userId: session.user.id,\n        })\n      : null;\n\n  return (\n    &lt;div className=\&quot;container mx-auto w-full max-w-5xl px-4 py-10\&quot;&gt;\n      &lt;div className=\&quot;space-y-6\&quot;&gt;\n        &lt;header&gt;\n          &lt;p className=\&quot;text-sm font-semibold uppercase tracking-wide text-muted-foreground\&quot;&gt;\n            Responsive Wizard\n          &lt;/p&gt;\n          &lt;h1 className=\&quot;mt-1 text-3xl font-semibold\&quot;&gt;\n            {formConfig.title || \&quot;Form Configuration\&quot;}\n          &lt;/h1&gt;\n          {formConfig.description &amp;&amp; (\n            &lt;p className=\&quot;mt-2 text-base text-muted-foreground\&quot;&gt;\n              {formConfig.description}\n            &lt;/p&gt;\n          )}\n          {!formConfig.isActive &amp;&amp; (\n            &lt;p className=\&quot;mt-2 text-sm text-amber-600\&quot;&gt;\n              (This form configuration is inactive)\n            &lt;/p&gt;\n          )}\n        &lt;/header&gt;\n        &lt;FormWizardClient\n          formConfig={formConfig}\n          organizationId={membership.organizationId}\n          initialData={initialDraft?.formData ?? {}}\n          initialStep={initialDraft?.currentStep ?? 0}\n          initialApplicationId={initialDraft?.applicationId ?? null}\n          drafts={drafts}\n        /&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n}\n\n&quot;
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Verifying import path and type usage**</details></think>

---

The model made no changes to the file.

---

<think><details><summary>Thought Process</summary>
**Reviewing file for accurate patching**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/sahilmehta/supplier-onboarding-simple/app/forms/[entityCode]/[geographyCode]/page.tsx</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Preparing to rewrite route file**</details></think>

---

<tool-use data-tool-type="bash" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **command** • Run command: cd /Users/sahilmehta/supplier-onboarding-simple && cat <<'EOF' > app/forms/[entityCode]/[geographyCode]/page.tsx
import { redirect, notFound } from "next/navigation";
import { auth } from "@/lib/auth";
import { getFormConfigByEntityAndGeography } from "@/lib/forms/form-config-fetcher";
import { FormWizardClient } from "@/components/forms/form-wizard-client";
import { getCurrentUserMembership } from "@/lib/permissions";
import {
  listDraftSummaries,
  loadDraftRecord,
} from "@/lib/forms/draft-manager";

interface Params {
  entityCode: string;
  geographyCode: string;
}

export default async function FormByEntityGeographyPage({
  params,
}: {
  params: Promise<Params>;
}) {
  const { entityCode, geographyCode } = await params;
  const session = await auth();

  if (!session?.user?.id) {
    redirect("/signin");
  }

  const membership = await getCurrentUserMembership();
  if (!membership) {
    redirect("/signin");
  }

  const formConfig = await getFormConfigByEntityAndGeography(
    entityCode,
    geographyCode
  );

  if (!formConfig) {
    notFound();
  }

  const drafts = await listDraftSummaries({
    formConfigId: formConfig.id,
    organizationId: membership.organizationId,
    entityId: formConfig.entityId,
    geographyId: formConfig.geographyId,
    userId: session.user.id,
  });

  const initialDraft =
    drafts.length > 0
      ? await loadDraftRecord({
          applicationId: drafts[0].applicationId,
          organizationId: membership.organizationId,
          userId: session.user.id,
        })
      : null;

  return (
    <div className="container mx-auto w-full max-w-5xl px-4 py-10">
      <div className="space-y-6">
        <header>
          <p className="text-sm font-semibold uppercase tracking-wide text-muted-foreground">
            Responsive Wizard
          </p>
          <h1 className="mt-1 text-3xl font-semibold">
            {formConfig.title || "Form Configuration"}
          </h1>
          {formConfig.description && (
            <p className="mt-2 text-base text-muted-foreground">
              {formConfig.description}
            </p>
          )}
        </header>
        <FormWizardClient
          formConfig={formConfig}
          organizationId={membership.organizationId}
          initialData={initialDraft?.formData ?? {}}
          initialStep={initialDraft?.currentStep ?? 0}
          initialApplicationId={initialDraft?.applicationId ?? null}
          drafts={drafts}
        />
      </div>
    </div>
  );
}
EOF</summary>

```bash
cd /Users/sahilmehta/supplier-onboarding-simple && cat <<'EOF' > app/forms/[entityCode]/[geographyCode]/page.tsx
import { redirect, notFound } from "next/navigation";
import { auth } from "@/lib/auth";
import { getFormConfigByEntityAndGeography } from "@/lib/forms/form-config-fetcher";
import { FormWizardClient } from "@/components/forms/form-wizard-client";
import { getCurrentUserMembership } from "@/lib/permissions";
import {
  listDraftSummaries,
  loadDraftRecord,
} from "@/lib/forms/draft-manager";

interface Params {
  entityCode: string;
  geographyCode: string;
}

export default async function FormByEntityGeographyPage({
  params,
}: {
  params: Promise<Params>;
}) {
  const { entityCode, geographyCode } = await params;
  const session = await auth();

  if (!session?.user?.id) {
    redirect("/signin");
  }

  const membership = await getCurrentUserMembership();
  if (!membership) {
    redirect("/signin");
  }

  const formConfig = await getFormConfigByEntityAndGeography(
    entityCode,
    geographyCode
  );

  if (!formConfig) {
    notFound();
  }

  const drafts = await listDraftSummaries({
    formConfigId: formConfig.id,
    organizationId: membership.organizationId,
    entityId: formConfig.entityId,
    geographyId: formConfig.geographyId,
    userId: session.user.id,
  });

  const initialDraft =
    drafts.length > 0
      ? await loadDraftRecord({
          applicationId: drafts[0].applicationId,
          organizationId: membership.organizationId,
          userId: session.user.id,
        })
      : null;

  return (
    <div className="container mx-auto w-full max-w-5xl px-4 py-10">
      <div className="space-y-6">
        <header>
          <p className="text-sm font-semibold uppercase tracking-wide text-muted-foreground">
            Responsive Wizard
          </p>
          <h1 className="mt-1 text-3xl font-semibold">
            {formConfig.title || "Form Configuration"}
          </h1>
          {formConfig.description && (
            <p className="mt-2 text-base text-muted-foreground">
              {formConfig.description}
            </p>
          )}
        </header>
        <FormWizardClient
          formConfig={formConfig}
          organizationId={membership.organizationId}
          initialData={initialDraft?.formData ?? {}}
          initialStep={initialDraft?.currentStep ?? 0}
          initialApplicationId={initialDraft?.applicationId ?? null}
          drafts={drafts}
        />
      </div>
    </div>
  );
}
EOF
```

```
zsh: no matches found: app/forms/[entityCode]/[geographyCode]/page.tsx
```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Preparing file path with special characters**</details></think>

---

<tool-use data-tool-type="bash" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **command** • Run command: cd /Users/sahilmehta/supplier-onboarding-simple && cat <<'EOF' > 'app/forms/[entityCode]/[geographyCode]/page.tsx'
import { redirect, notFound } from "next/navigation";
import { auth } from "@/lib/auth";
import { getFormConfigByEntityAndGeography } from "@/lib/forms/form-config-fetcher";
import { FormWizardClient } from "@/components/forms/form-wizard-client";
import { getCurrentUserMembership } from "@/lib/permissions";
import {
  listDraftSummaries,
  loadDraftRecord,
} from "@/lib/forms/draft-manager";

interface Params {
  entityCode: string;
  geographyCode: string;
}

export default async function FormByEntityGeographyPage({
  params,
}: {
  params: Promise<Params>;
}) {
  const { entityCode, geographyCode } = await params;
  const session = await auth();

  if (!session?.user?.id) {
    redirect("/signin");
  }

  const membership = await getCurrentUserMembership();
  if (!membership) {
    redirect("/signin");
  }

  const formConfig = await getFormConfigByEntityAndGeography(
    entityCode,
    geographyCode
  );

  if (!formConfig) {
    notFound();
  }

  const drafts = await listDraftSummaries({
    formConfigId: formConfig.id,
    organizationId: membership.organizationId,
    entityId: formConfig.entityId,
    geographyId: formConfig.geographyId,
    userId: session.user.id,
  });

  const initialDraft =
    drafts.length > 0
      ? await loadDraftRecord({
          applicationId: drafts[0].applicationId,
          organizationId: membership.organizationId,
          userId: session.user.id,
        })
      : null;

  return (
    <div className="container mx-auto w-full max-w-5xl px-4 py-10">
      <div className="space-y-6">
        <header>
          <p className="text-sm font-semibold uppercase tracking-wide text-muted-foreground">
            Responsive Wizard
          </p>
          <h1 className="mt-1 text-3xl font-semibold">
            {formConfig.title || "Form Configuration"}
          </h1>
          {formConfig.description && (
            <p className="mt-2 text-base text-muted-foreground">
              {formConfig.description}
            </p>
          )}
        </header>
        <FormWizardClient
          formConfig={formConfig}
          organizationId={membership.organizationId}
          initialData={initialDraft?.formData ?? {}}
          initialStep={initialDraft?.currentStep ?? 0}
          initialApplicationId={initialDraft?.applicationId ?? null}
          drafts={drafts}
        />
      </div>
    </div>
  );
}
EOF</summary>

```bash
cd /Users/sahilmehta/supplier-onboarding-simple && cat <<'EOF' > 'app/forms/[entityCode]/[geographyCode]/page.tsx'
import { redirect, notFound } from "next/navigation";
import { auth } from "@/lib/auth";
import { getFormConfigByEntityAndGeography } from "@/lib/forms/form-config-fetcher";
import { FormWizardClient } from "@/components/forms/form-wizard-client";
import { getCurrentUserMembership } from "@/lib/permissions";
import {
  listDraftSummaries,
  loadDraftRecord,
} from "@/lib/forms/draft-manager";

interface Params {
  entityCode: string;
  geographyCode: string;
}

export default async function FormByEntityGeographyPage({
  params,
}: {
  params: Promise<Params>;
}) {
  const { entityCode, geographyCode } = await params;
  const session = await auth();

  if (!session?.user?.id) {
    redirect("/signin");
  }

  const membership = await getCurrentUserMembership();
  if (!membership) {
    redirect("/signin");
  }

  const formConfig = await getFormConfigByEntityAndGeography(
    entityCode,
    geographyCode
  );

  if (!formConfig) {
    notFound();
  }

  const drafts = await listDraftSummaries({
    formConfigId: formConfig.id,
    organizationId: membership.organizationId,
    entityId: formConfig.entityId,
    geographyId: formConfig.geographyId,
    userId: session.user.id,
  });

  const initialDraft =
    drafts.length > 0
      ? await loadDraftRecord({
          applicationId: drafts[0].applicationId,
          organizationId: membership.organizationId,
          userId: session.user.id,
        })
      : null;

  return (
    <div className="container mx-auto w-full max-w-5xl px-4 py-10">
      <div className="space-y-6">
        <header>
          <p className="text-sm font-semibold uppercase tracking-wide text-muted-foreground">
            Responsive Wizard
          </p>
          <h1 className="mt-1 text-3xl font-semibold">
            {formConfig.title || "Form Configuration"}
          </h1>
          {formConfig.description && (
            <p className="mt-2 text-base text-muted-foreground">
              {formConfig.description}
            </p>
          )}
        </header>
        <FormWizardClient
          formConfig={formConfig}
          organizationId={membership.organizationId}
          initialData={initialDraft?.formData ?? {}}
          initialStep={initialDraft?.currentStep ?? 0}
          initialApplicationId={initialDraft?.applicationId ?? null}
          drafts={drafts}
        />
      </div>
    </div>
  );
}
EOF
```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Updating documentation statuses**

I'm making sure to consolidate imports and verify new props on `FormWizardClient` while updating TypeScript usage. Now, I'll focus on marking tasks 5.1-5.6 as completed in `agent-stream-5-state-draft.md` by changing the overall status to "Complete" and checking off all related progress boxes to reflect finished work.</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  &quot;relativeWorkspacePath&quot;: &quot;docs/agent-stream-5-state-draft.md&quot;
}
```
Additional data:

```json
{
  &quot;codeblockId&quot;: &quot;9b6b1886-b142-45e0-aabe-8581d6ac3625&quot;,
  &quot;reviewData&quot;: {
    &quot;status&quot;: &quot;None&quot;,
    &quot;selectedOption&quot;: &quot;accept&quot;,
    &quot;isShowingInput&quot;: false,
    &quot;firstTimeReviewMode&quot;: false
  }
}
```
Result:

```json
{
  &quot;diff&quot;: {
    &quot;chunks&quot;: [
      {
        &quot;diffString&quot;: &quot;  \n  **Agent ID**: STREAM-5  \n- **Status**: Active  \n+ **Status**: Complete  \n  **Owner**: [Assign Developer]  \n  **Start Date**: [Date]  &quot;,
        &quot;oldStart&quot;: 2,
        &quot;newStart&quot;: 2,
        &quot;oldLines&quot;: 5,
        &quot;newLines&quot;: 5,
        &quot;linesRemoved&quot;: 1,
        &quot;linesAdded&quot;: 1
      },
      {
        &quot;diffString&quot;: &quot;  \n  ### Active Task\n- - [ ] **Task 5.1**: Implement form state management\n+ - [x] **Task 5.1**: Implement form state management\n  \n  ### Next Tasks\n- - [ ] **Task 5.2**: Implement autosave logic (debounced)\n- - [ ] **Task 5.3**: Build draft save server action\n- - [ ] **Task 5.4**: Implement draft load on form mount\n- - [ ] **Task 5.5**: Add \&quot;Save Draft\&quot; explicit button\n- - [ ] **Task 5.6**: Handle resume flow (existing drafts)\n+ - [x] **Task 5.2**: Implement autosave logic (debounced)\n+ - [x] **Task 5.3**: Build draft save server action\n+ - [x] **Task 5.4**: Implement draft load on form mount\n+ - [x] **Task 5.5**: Add \&quot;Save Draft\&quot; explicit button\n+ - [x] **Task 5.6**: Handle resume flow (existing drafts)\n  \n  ## Files to Create&quot;,
        &quot;oldStart&quot;: 14,
        &quot;newStart&quot;: 14,
        &quot;oldLines&quot;: 12,
        &quot;newLines&quot;: 12,
        &quot;linesRemoved&quot;: 6,
        &quot;linesAdded&quot;: 6
      },
      {
        &quot;diffString&quot;: &quot;  ## Progress Tracking\n  \n- - [ ] Form state management implemented\n- - [ ] Autosave logic working\n- - [ ] Draft save server action created\n- - [ ] Draft load on mount working\n- - [ ] Save Draft button working\n- - [ ] Resume flow implemented\n- - [ ] Multiple drafts handled\n- - [ ] Error handling complete\n- - [ ] Integration with wizard complete\n+ - [x] Form state management implemented\n+ - [x] Autosave logic working\n+ - [x] Draft save server action created\n+ - [x] Draft load on mount working\n+ - [x] Save Draft button working\n+ - [x] Resume flow implemented\n+ - [x] Multiple drafts handled\n+ - [x] Error handling complete\n+ - [x] Integration with wizard complete\n  \n  ## Testing Checklist&quot;,
        &quot;oldStart&quot;: 200,
        &quot;newStart&quot;: 200,
        &quot;oldLines&quot;: 13,
        &quot;newLines&quot;: 13,
        &quot;linesRemoved&quot;: 9,
        &quot;linesAdded&quot;: 9
      }
    ],
    &quot;editor&quot;: &quot;EDITOR_AI&quot;
  },
  &quot;shouldAutoFixLints&quot;: true,
  &quot;resultForModel&quot;: &quot;Success. Updated the following files:\nM docs/agent-stream-5-state-draft.md&quot;,
  &quot;contentsAfterEdit&quot;: &quot;# Agent: Stream 5 - State Management &amp; Draft Persistence\n\n**Agent ID**: STREAM-5  \n**Status**: Complete  \n**Owner**: [Assign Developer]  \n**Start Date**: [Date]  \n**Target Completion**: [Date + 5-6 days]\n\n## Mission\n\nImplement form state management, autosave functionality, draft persistence, and resume flow. This enables users to save their progress and resume forms later.\n\n## Current Tasks\n\n### Active Task\n- [x] **Task 5.1**: Implement form state management\n\n### Next Tasks\n- [x] **Task 5.2**: Implement autosave logic (debounced)\n- [x] **Task 5.3**: Build draft save server action\n- [x] **Task 5.4**: Implement draft load on form mount\n- [x] **Task 5.5**: Add \&quot;Save Draft\&quot; explicit button\n- [x] **Task 5.6**: Handle resume flow (existing drafts)\n\n## Files to Create\n\n&#96;&#96;&#96;\nlib/\n  forms/\n    form-state.ts                # State management utilities\n    draft-manager.ts              # Draft save/load logic\n\nhooks/\n  use-form-state.ts              # Form state management hook\n  use-autosave.ts                 # Autosave hook with debouncing\n\napp/\n  forms/\n    actions.ts                    # Server actions for draft save/load\n\ncomponents/\n  forms/\n    draft-resume-dialog.tsx      # Dialog for multiple drafts\n    draft-save-indicator.tsx     # \&quot;Draft saved\&quot; feedback component\n&#96;&#96;&#96;\n\n## Files to Update\n\n&#96;&#96;&#96;\ncomponents/\n  forms/\n    dynamic-form-wizard.tsx      # Integrate state management and autosave\n    form-navigation.tsx           # Add Save Draft button\n\napp/\n  forms/\n    [entityCode]/\n      [geographyCode]/\n        page.tsx                  # Load draft on mount\n    [formConfigId]/\n      page.tsx                    # Load draft on mount\n&#96;&#96;&#96;\n\n## Key Dependencies\n\n**Depends on:**\n- ✅ Stream 1 (Routes) - Complete - Need routes for server actions\n- ✅ Stream 3 (Wizard UI) - Complete - Need wizard framework\n\n**Provides to:**\n- Stream 6 (Conditional Fields) - Needs form state for visibility evaluation\n- Stream 8 (Testing) - Needs draft functionality for testing\n\n**Can work in parallel with:**\n- Stream 7 (Responsive &amp; A11y) - No conflicts\n\n## Integration Points\n\n1. **With Stream 3**: Integrate state management into &#96;DynamicFormWizard&#96;\n2. **With Stream 1**: Use routes for server actions\n3. **With Stream 6**: Provide form state for conditional field evaluation\n\n## Implementation Details\n\n### Task 5.1: Form State Management\n\n**Create &#96;lib/forms/form-state.ts&#96;:**\n&#96;&#96;&#96;typescript\nexport interface FormState {\n  formData: Record&lt;string, unknown&gt;;\n  touched: Set&lt;string&gt;;\n  errors: Record&lt;string, string&gt;;\n  currentStep: number;\n  completedSteps: Set&lt;number&gt;;\n  isDirty: boolean;\n  isSubmitting: boolean;\n}\n\nexport function createInitialFormState(\n  initialData?: Record&lt;string, unknown&gt;\n): FormState {\n  // Implementation\n}\n&#96;&#96;&#96;\n\n**Create &#96;hooks/use-form-state.ts&#96;:**\n- Manage form state\n- Track touched fields\n- Track errors\n- Track completion status\n- Track dirty state\n\n### Task 5.2: Autosave Logic\n\n**Create &#96;hooks/use-autosave.ts&#96;:**\n- Debounced autosave (2 seconds of inactivity)\n- Save on step completion\n- Save before unload (warn user)\n- Optimistic UI updates\n- Error handling and retry\n\n**Integration:**\n- Add to &#96;DynamicFormWizard&#96;\n- Show \&quot;Draft saved\&quot; indicator\n- Handle errors gracefully\n\n### Task 5.3: Draft Save Server Action\n\n**Create &#96;app/forms/actions.ts&#96;:**\n&#96;&#96;&#96;typescript\nexport async function saveFormDraft(\n  formConfigId: string,\n  applicationId: string | null,\n  formData: Record&lt;string, unknown&gt;,\n  currentStep: number\n): Promise&lt;{ success: boolean; applicationId: string }&gt;\n\nexport async function loadFormDraft(\n  applicationId: string\n): Promise&lt;{ formData: Record&lt;string, unknown&gt;; currentStep: number } | null&gt;\n&#96;&#96;&#96;\n\n**Features:**\n- Validate session\n- Create or update &#96;Application&#96; record\n- Save form data to &#96;Application.data&#96; JSON\n- Store current step\n- Update &#96;Application.updatedAt&#96;\n- Return application ID\n\n### Task 5.4: Draft Load on Mount\n\n**Update route pages:**\n- Check for existing draft on form load\n- Query for &#96;Application&#96; in &#96;DRAFT&#96; status\n- Match by &#96;formConfigId&#96;, &#96;entityId&#96;, &#96;geographyId&#96;, &#96;userId&#96;\n- Load &#96;Application.data&#96; and restore form state\n- Restore step position\n\n**Update &#96;DynamicFormWizard&#96;:**\n- Accept &#96;initialData&#96; prop\n- Accept &#96;initialStep&#96; prop\n- Pre-populate form with saved data\n\n### Task 5.5: Save Draft Button\n\n**Update &#96;FormNavigation&#96;:**\n- Add \&quot;Save Draft\&quot; button\n- Always enabled, secondary style\n- Calls save draft action\n- Shows loading state\n- Shows success feedback\n- Doesn&#39;t validate (saves even with errors)\n\n### Task 5.6: Resume Flow\n\n**Create &#96;DraftResumeDialog&#96;:**\n- Show dialog if multiple drafts exist\n- List drafts with last updated time\n- Allow user to select draft or start new\n- Load selected draft\n- Delete draft option\n\n## Mock Data for Development\n\n&#96;&#96;&#96;typescript\nconst mockDraftData = {\n  formConfigId: \&quot;clx123abc456\&quot;,\n  applicationId: \&quot;app123\&quot;,\n  formData: {\n    supplier_name: \&quot;Acme Corporation\&quot;,\n    email: \&quot;contact@acme.com\&quot;,\n    payment_terms: \&quot;Net 30\&quot;,\n  },\n  currentStep: 2,\n  updatedAt: new Date(),\n};\n&#96;&#96;&#96;\n\n## Progress Tracking\n\n- [x] Form state management implemented\n- [x] Autosave logic working\n- [x] Draft save server action created\n- [x] Draft load on mount working\n- [x] Save Draft button working\n- [x] Resume flow implemented\n- [x] Multiple drafts handled\n- [x] Error handling complete\n- [x] Integration with wizard complete\n\n## Testing Checklist\n\n- [ ] Test form state updates on field changes\n- [ ] Test autosave triggers after 2s\n- [ ] Test autosave on step completion\n- [ ] Test warning before unload\n- [ ] Test draft saves to database\n- [ ] Test draft loads on mount\n- [ ] Test form pre-populated with draft\n- [ ] Test step position restored\n- [ ] Test multiple drafts handled\n- [ ] Test Save Draft button works\n- [ ] Test resume flow works\n- [ ] Test error handling\n- [ ] Test performance (no lag from autosave)\n\n## Notes\n\n- Use existing &#96;Application&#96; model in database\n- Store draft data in &#96;Application.data&#96; JSON field\n- Use &#96;Application.status = &#39;DRAFT&#39;&#96; for drafts\n- Handle session validation in server actions\n- Optimize autosave to not block UI\n- Consider localStorage as backup (optional)\n\n## Daily Updates\n\n### [Date]\n- Status: [In Progress/Blocked/Complete]\n- Completed: [Tasks]\n- Blockers: [Issues]\n- Next: [Planned tasks]\n\n&quot;
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Updating TODO list statuses**</details></think>

---

<tool-use data-tool-type="generic" data-tool-name="todo_write">
<details><summary>Tool use: **todo_write** • Todo List</summary>

- [x] Review Stream 5 requirements and inspect current form wizard/state logic
- [x] Implement shared form state + draft persistence libs/hooks
- [x] Integrate autosave and draft UI into form components/routes
- [x] Add server actions + route draft loading, update docs status

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Verifying FormWizardClient and linting**</details></think>

---

<tool-use data-tool-type="bash" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **command** • Run command: cd /Users/sahilmehta/supplier-onboarding-simple && npm run lint</summary>

```bash
cd /Users/sahilmehta/supplier-onboarding-simple && npm run lint
```

```
&gt; supplier-onboarding-simple@0.1.0 lint
&gt; eslint


/Users/sahilmehta/supplier-onboarding-simple/components/forms/dynamic-form-wizard.tsx                                                                           
  344:41  warning  The ref value &#39;validationTimersRef.current&#39; will likely have changed by the time this effect cleanup function runs. If this ref points to a node rendered by React, copy &#39;validationTimersRef.current&#39; to a variable inside the effect, and use that variable in the cleanup function  react-hooks/exhaustive-deps                                                                           

✖ 1 problem (0 errors, 1 warning)
```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Fixing useEffect cleanup lint warning**</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: /Users/sahilmehta/supplier-onboarding-simple/components/forms/dynamic-form-wizard.tsx</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Updating cleanup effect to clear timers**</details></think>

---

<tool-use data-tool-type="unknown" data-tool-name="apply_patch">
<details>
<summary>Tool use: **apply_patch**</summary>


Parameters:

```json
{
  &quot;relativeWorkspacePath&quot;: &quot;components/forms/dynamic-form-wizard.tsx&quot;
}
```
Additional data:

```json
{
  &quot;codeblockId&quot;: &quot;dda09e8a-46a6-475b-b9e8-a952e165c864&quot;,
  &quot;reviewData&quot;: {
    &quot;status&quot;: &quot;None&quot;,
    &quot;selectedOption&quot;: &quot;accept&quot;,
    &quot;isShowingInput&quot;: false,
    &quot;firstTimeReviewMode&quot;: false
  }
}
```
Result:

```json
{
  &quot;diff&quot;: {
    &quot;chunks&quot;: [
      {
        &quot;diffString&quot;: &quot;  \n    useEffect(() =&gt; {\n+     const timers = validationTimersRef.current;\n      return () =&gt; {\n-       Object.values(validationTimersRef.current).forEach((timer) =&gt; {\n+       Object.values(timers).forEach((timer) =&gt; {\n          clearTimeout(timer);\n        });&quot;,
        &quot;oldStart&quot;: 341,
        &quot;newStart&quot;: 341,
        &quot;oldLines&quot;: 6,
        &quot;newLines&quot;: 7,
        &quot;linesRemoved&quot;: 1,
        &quot;linesAdded&quot;: 2
      }
    ],
    &quot;editor&quot;: &quot;EDITOR_AI&quot;
  },
  &quot;shouldAutoFixLints&quot;: true,
  &quot;resultForModel&quot;: &quot;Success. Updated the following files:\nM components/forms/dynamic-form-wizard.tsx&quot;,
  &quot;contentsAfterEdit&quot;: &quot;\&quot;use client\&quot;;\n\nimport { useCallback, useEffect, useMemo, useRef, useState } from \&quot;react\&quot;;\nimport type { FormConfigWithFields } from \&quot;@/lib/forms/types\&quot;;\nimport { getStepFieldKeys } from \&quot;@/lib/forms/form-validator\&quot;;\nimport { buildFormSchema } from \&quot;@/lib/form-schema\&quot;;\nimport { saveFormDraft, type DraftSaveResult } from \&quot;@/app/forms/actions\&quot;;\nimport { StepIndicator } from \&quot;./step-indicator\&quot;;\nimport { FormStep } from \&quot;./form-step\&quot;;\nimport { FormNavigation } from \&quot;./form-navigation\&quot;;\nimport { FormErrorSummary } from \&quot;./form-error-summary\&quot;;\nimport { useFormState } from \&quot;@/hooks/use-form-state\&quot;;\nimport { useAutosave } from \&quot;@/hooks/use-autosave\&quot;;\nimport { useToast } from \&quot;@/components/ui/use-toast\&quot;;\nimport { usePrefersReducedMotion } from \&quot;@/hooks/use-prefers-reduced-motion\&quot;;\nimport { cn } from \&quot;@/lib/utils\&quot;;\n\ninterface DynamicFormWizardProps {\n  formConfig: FormConfigWithFields;\n  initialData?: Record&lt;string, unknown&gt;;\n  initialStep?: number;\n  applicationId: string | null;\n  organizationId: string;\n  onApplicationIdChange?: (applicationId: string) =&gt; void;\n  onDraftSaved?: (result: DraftSaveResult) =&gt; void;\n  onStepChange?: (stepIndex: number) =&gt; void;\n  onComplete?: (formData: Record&lt;string, unknown&gt;) =&gt; Promise&lt;void&gt; | void;\n}\n\nconst clampStep = (step: number, totalSteps: number) =&gt; {\n  if (totalSteps &lt;= 0) {\n    return 0;\n  }\n  return Math.max(0, Math.min(step, totalSteps - 1));\n};\n\nexport function DynamicFormWizard({\n  formConfig,\n  initialData = {},\n  initialStep = 0,\n  applicationId,\n  organizationId,\n  onApplicationIdChange,\n  onDraftSaved,\n  onStepChange,\n  onComplete,\n}: DynamicFormWizardProps) {\n  const sortedSections = useMemo(\n    () =&gt; [...formConfig.sections].sort((a, b) =&gt; a.order - b.order),\n    [formConfig.sections]\n  );\n\n  const totalSteps = sortedSections.length;\n  const safeInitialStep = clampStep(initialStep ?? 0, totalSteps);\n\n  const {\n    state,\n    touchedMap,\n    setFieldValue,\n    markFieldTouched,\n    markFieldsTouched,\n    setFieldError,\n    setStepErrors,\n    goToStep,\n    markStepComplete,\n    setIsSubmitting,\n    markClean,\n    resetForm,\n    validateAndCommitStep,\n  } = useFormState({\n    formConfig,\n    initialData,\n    initialStep: safeInitialStep,\n  });\n\n  const [liveMessage, setLiveMessage] = useState(\&quot;\&quot;);\n  const validationTimersRef = useRef&lt;Record&lt;string, NodeJS.Timeout&gt;&gt;({});\n  const formSchemaRef = useRef(buildFormSchema(formConfig));\n  const prefersReducedMotion = usePrefersReducedMotion();\n  const { toast } = useToast();\n  const initialSnapshotRef = useRef(\n    JSON.stringify({ data: initialData, step: safeInitialStep, applicationId })\n  );\n\n  const isFirstStep = state.currentStep === 0;\n  const isLastStep = state.currentStep === totalSteps - 1;\n  const currentSection = sortedSections[state.currentStep];\n\n  useEffect(() =&gt; {\n    formSchemaRef.current = buildFormSchema(formConfig);\n  }, [formConfig]);\n\n  useEffect(() =&gt; {\n    const nextSnapshot = JSON.stringify({\n      data: initialData,\n      step: safeInitialStep,\n      applicationId,\n    });\n\n    if (nextSnapshot !== initialSnapshotRef.current) {\n      resetForm(initialData, safeInitialStep);\n      initialSnapshotRef.current = nextSnapshot;\n    }\n  }, [initialData, resetForm, safeInitialStep, applicationId]);\n\n  const focusFirstError = useCallback(\n    (fieldKey?: string) =&gt; {\n      if (!fieldKey || !currentSection) {\n        return;\n      }\n      const errorField = currentSection.fields.find((field) =&gt; field.key === fieldKey);\n      const fieldElement = errorField\n        ? document.getElementById(&#96;field-${errorField.id}&#96;)\n        : null;\n      fieldElement?.focus();\n      fieldElement?.scrollIntoView({ behavior: \&quot;smooth\&quot;, block: \&quot;center\&quot; });\n    },\n    [currentSection]\n  );\n\n  const validateField = useCallback(\n    (fieldKey: string, value: unknown, immediate = false) =&gt; {\n      if (validationTimersRef.current[fieldKey]) {\n        clearTimeout(validationTimersRef.current[fieldKey]);\n      }\n\n      const performValidation = () =&gt; {\n        const fieldSchema = formSchemaRef.current.shape[fieldKey];\n        if (!fieldSchema) {\n          return;\n        }\n\n        try {\n          fieldSchema.parse(value);\n          setFieldError(fieldKey);\n        } catch (error) {\n          if (error &amp;&amp; typeof error === \&quot;object\&quot; &amp;&amp; \&quot;issues\&quot; in error) {\n            const zodError = error as { issues: Array&lt;{ message: string }&gt; };\n            const firstIssue = zodError.issues[0];\n            if (firstIssue) {\n              setFieldError(fieldKey, firstIssue.message);\n            }\n          } else if (error instanceof Error) {\n            setFieldError(fieldKey, error.message);\n          }\n        }\n      };\n\n      if (immediate) {\n        performValidation();\n      } else {\n        validationTimersRef.current[fieldKey] = setTimeout(performValidation, 300);\n      }\n    },\n    [setFieldError]\n  );\n\n  const handleFieldChange = useCallback(\n    (fieldKey: string, value: unknown) =&gt; {\n      setFieldValue(fieldKey, value);\n      if (state.touched.has(fieldKey)) {\n        validateField(fieldKey, value, false);\n      }\n    },\n    [setFieldValue, state.touched, validateField]\n  );\n\n  const handleFieldBlur = useCallback(\n    (fieldKey: string) =&gt; {\n      markFieldTouched(fieldKey);\n      validateField(fieldKey, state.formData[fieldKey], true);\n    },\n    [markFieldTouched, state.formData, validateField]\n  );\n\n  const autosaveFingerprint = useMemo(\n    () =&gt; JSON.stringify({ data: state.formData, step: state.currentStep }),\n    [state.formData, state.currentStep]\n  );\n\n  const runDraftSave = useCallback(() =&gt; {\n    return saveFormDraft({\n      formConfigId: formConfig.id,\n      organizationId,\n      entityId: formConfig.entityId,\n      geographyId: formConfig.geographyId,\n      applicationId,\n      formData: state.formData,\n      currentStep: state.currentStep,\n    });\n  }, [\n    applicationId,\n    formConfig.entityId,\n    formConfig.geographyId,\n    formConfig.id,\n    organizationId,\n    state.currentStep,\n    state.formData,\n  ]);\n\n  const {\n    status: draftStatus,\n    isSaving: isSavingDraft,\n    lastSavedAt,\n    error: draftError,\n    triggerSave,\n  } = useAutosave&lt;DraftSaveResult&gt;({\n    shouldAutosave: state.isDirty,\n    dataFingerprint: autosaveFingerprint,\n    save: runDraftSave,\n    onSuccess: (result) =&gt; {\n      markClean();\n      if (result.applicationId &amp;&amp; result.applicationId !== applicationId) {\n        onApplicationIdChange?.(result.applicationId);\n      }\n      onDraftSaved?.(result);\n    },\n    onError: (error) =&gt; {\n      toast({\n        variant: \&quot;destructive\&quot;,\n        title: \&quot;Draft save failed\&quot;,\n        description: error.message,\n      });\n    },\n  });\n\n  const handleNext = useCallback(async () =&gt; {\n    if (state.isSubmitting) {\n      return;\n    }\n\n    const validation = validateAndCommitStep(state.currentStep);\n    if (!validation.isValid) {\n      toast({\n        variant: \&quot;destructive\&quot;,\n        title: \&quot;Please fix validation errors\&quot;,\n        description: \&quot;Resolve highlighted fields before continuing.\&quot;,\n      });\n      focusFirstError(validation.firstErrorField);\n      return;\n    }\n\n    markStepComplete(state.currentStep);\n\n    if (isLastStep &amp;&amp; onComplete) {\n      try {\n        setIsSubmitting(true);\n        await onComplete(state.formData);\n        toast({\n          title: \&quot;Form submitted\&quot;,\n          description: \&quot;Thank you! We received your information.\&quot;,\n        });\n      } catch (error) {\n        toast({\n          variant: \&quot;destructive\&quot;,\n          title: \&quot;Submission failed\&quot;,\n          description:\n            error instanceof Error\n              ? error.message\n              : \&quot;Something went wrong while submitting. Please try again.\&quot;,\n        });\n      } finally {\n        setIsSubmitting(false);\n      }\n      return;\n    }\n\n    const nextStep = clampStep(state.currentStep + 1, totalSteps);\n    goToStep(nextStep);\n    onStepChange?.(nextStep);\n    void triggerSave(\&quot;step-change\&quot;);\n  }, [\n    focusFirstError,\n    goToStep,\n    isLastStep,\n    markStepComplete,\n    onComplete,\n    onStepChange,\n    setIsSubmitting,\n    state.currentStep,\n    state.formData,\n    state.isSubmitting,\n    toast,\n    totalSteps,\n    triggerSave,\n    validateAndCommitStep,\n  ]);\n\n  const handlePrevious = useCallback(() =&gt; {\n    if (isFirstStep) {\n      return;\n    }\n    const prevStep = clampStep(state.currentStep - 1, totalSteps);\n    goToStep(prevStep);\n    onStepChange?.(prevStep);\n  }, [goToStep, isFirstStep, onStepChange, state.currentStep, totalSteps]);\n\n  const handleStepClick = useCallback(\n    (stepIndex: number) =&gt; {\n      if (stepIndex === state.currentStep) {\n        return;\n      }\n\n      const validation = validateAndCommitStep(state.currentStep);\n      if (!validation.isValid) {\n        toast({\n          variant: \&quot;destructive\&quot;,\n          title: \&quot;Cannot leave step yet\&quot;,\n          description: \&quot;Fix validation errors before moving on.\&quot;,\n        });\n        focusFirstError(validation.firstErrorField);\n        return;\n      }\n\n      if (\n        state.completedSteps.has(stepIndex) ||\n        stepIndex === clampStep(state.currentStep + 1, totalSteps)\n      ) {\n        const nextStep = clampStep(stepIndex, totalSteps);\n        goToStep(nextStep);\n        onStepChange?.(nextStep);\n        void triggerSave(\&quot;step-change\&quot;);\n      }\n    },\n    [\n      focusFirstError,\n      goToStep,\n      onStepChange,\n      state.completedSteps,\n      state.currentStep,\n      toast,\n      totalSteps,\n      triggerSave,\n      validateAndCommitStep,\n    ]\n  );\n\n  const handleManualSave = useCallback(() =&gt; {\n    void triggerSave(\&quot;manual\&quot;);\n  }, [triggerSave]);\n\n  useEffect(() =&gt; {\n    const timers = validationTimersRef.current;\n    return () =&gt; {\n      Object.values(timers).forEach((timer) =&gt; {\n        clearTimeout(timer);\n      });\n    };\n  }, []);\n\n  useEffect(() =&gt; {\n    const sectionLabel = currentSection?.label ?? &#96;Step ${state.currentStep + 1}&#96;;\n    setLiveMessage(\n      &#96;Now viewing ${sectionLabel} (${state.currentStep + 1} of ${totalSteps})&#96;\n    );\n  }, [currentSection, state.currentStep, totalSteps]);\n\n  const progress =\n    totalSteps &gt; 0 ? ((state.currentStep + 1) / totalSteps) * 100 : 0;\n\n  return (\n    &lt;div className=\&quot;flex flex-col gap-6 pb-32 sm:pb-12\&quot;&gt;\n      &lt;StepIndicator\n        steps={sortedSections.map((section) =&gt; ({\n          id: section.id,\n          label: section.label,\n          order: section.order,\n        }))}\n        currentStep={state.currentStep}\n        completedSteps={state.completedSteps}\n        onStepClick={handleStepClick}\n      /&gt;\n\n      &lt;div\n        className={cn(\n          \&quot;min-h-[400px] space-y-6 rounded-3xl border border-border/60 bg-background/70 p-4 shadow-lg sm:p-8\&quot;,\n          !prefersReducedMotion &amp;&amp; \&quot;transition-shadow duration-300\&quot;\n        )}\n      &gt;\n        {(() =&gt; {\n          const stepFieldKeys = getStepFieldKeys(state.currentStep, formConfig);\n          const stepErrors: Record&lt;string, string&gt; = {};\n          stepFieldKeys.forEach((key) =&gt; {\n            if (state.errors[key] &amp;&amp; touchedMap[key]) {\n              stepErrors[key] = state.errors[key];\n            }\n          });\n\n          if (Object.keys(stepErrors).length &gt; 0) {\n            return (\n              &lt;FormErrorSummary\n                errors={stepErrors}\n                onErrorClick={(fieldKey) =&gt; focusFirstError(fieldKey)}\n              /&gt;\n            );\n          }\n          return null;\n        })()}\n\n        {currentSection &amp;&amp; (\n          &lt;FormStep\n            section={currentSection}\n            formData={state.formData}\n            errors={state.errors}\n            touched={touchedMap}\n            onFieldChange={handleFieldChange}\n            onFieldBlur={handleFieldBlur}\n          /&gt;\n        )}\n      &lt;/div&gt;\n\n      &lt;FormNavigation\n        isFirstStep={isFirstStep}\n        isLastStep={isLastStep}\n        onNext={handleNext}\n        onPrevious={handlePrevious}\n        onSaveDraft={handleManualSave}\n        progress={progress}\n        isSubmitting={state.isSubmitting}\n        isSavingDraft={isSavingDraft}\n        draftStatus={draftStatus}\n        draftError={draftError}\n        lastSavedAt={lastSavedAt}\n      /&gt;\n      &lt;p role=\&quot;status\&quot; aria-live=\&quot;polite\&quot; className=\&quot;sr-only\&quot;&gt;\n        {liveMessage}\n      &lt;/p&gt;\n    &lt;/div&gt;\n  );\n}\n&quot;
}
```
User decision: **accepted**

Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Rerunning lint checks**</details></think>

---

<tool-use data-tool-type="bash" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **command** • Run command: cd /Users/sahilmehta/supplier-onboarding-simple && npm run lint</summary>

```bash
cd /Users/sahilmehta/supplier-onboarding-simple && npm run lint
```

```
&gt; supplier-onboarding-simple@0.1.0 lint
&gt; eslint
```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Checking git status**</details></think>

---

<tool-use data-tool-type="bash" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **command** • Run command: cd /Users/sahilmehta/supplier-onboarding-simple && git status -sb</summary>

```bash
cd /Users/sahilmehta/supplier-onboarding-simple && git status -sb
```

```
## main
 M .specstory/history/2025-11-11_07-30Z-setup-next-js-project-with-postgres-and-authentication.md                                                               
 M README.md
 M app/layout.tsx
 M app/page.tsx
 M app/signin/page.tsx
 M eslint.config.mjs
 M lib/auth.ts
 M package-lock.json
 M package.json
 M prisma/schema.prisma
 M prisma/seed.ts
 M tsconfig.json
 M types/next-auth.d.ts
?? .specstory/history/2025-11-17_06-13Z-critical-security-vulnerabilities-in-dependencies.md                                                                    
?? .specstory/history/2025-11-17_08-56Z-unable-to-login-due-to-infinite-loop.md
?? .specstory/history/2025-11-17_09-59Z-fix-missing-database-column-error.md
?? .specstory/history/2025-11-17_11-11Z-create-script-for-unimacts-entity.md
?? .specstory/history/2025-11-17_11-23Z-improve-configuration-menu-structure.md
?? .specstory/history/2025-11-17_11-55Z-addressing-critical-vulnerability-in-next-package.md                                                                    
?? .specstory/history/2025-11-17_12-01Z-how-to-view-unx-entity-form.md
?? .specstory/history/2025-11-18_05-22Z-have-we-built-the-ui-and-routes.md
?? .specstory/history/2025-11-18_06-18Z-execute-agent-stream-field-rendering.md
?? .specstory/history/2025-11-18_06-18Z-execute-authentication-routes-plan.md
?? .specstory/history/2025-11-18_06-19Z-execute-command-in-agent-stream.md
?? .specstory/history/2025-11-18_06-19Z-execute-validation-task.md
?? .specstory/history/2025-11-18_06-25Z-integrate-completed-workstreams-together.md                                                                             
?? .specstory/history/2025-11-18_06-57Z-implement-conditional-fields-and-update-status.md                                                                       
?? .specstory/history/2025-11-18_06-57Z-implement-draft-and-update-status.md
?? .specstory/history/2025-11-18_06-59Z-execute-plan-and-update-status.md
?? app/(marketing)/
?? app/api/configuration/
?? app/api/documents/
?? app/api/users/
?? app/dashboard/
?? app/forms/
?? app/settings/
?? app/supplier/
?? app/users/
?? components/admin/
?? components/forms/
?? components/navigation/admin-config-nav.tsx
?? components/navigation/app-sidebar.tsx
?? components/procurement/
?? components/providers/sidebar-provider.tsx
?? components/supplier/
?? components/ui/accordion.tsx
?? components/ui/dialog.tsx
?? components/ui/input.tsx
?? components/ui/label.tsx
?? components/ui/progress.tsx
?? components/ui/select.tsx
?? components/ui/sheet.tsx
?? components/ui/sidebar.tsx
?? components/ui/table.tsx
?? components/ui/toast.tsx
?? components/ui/toaster.tsx
?? components/ui/tooltip.tsx
?? components/ui/use-toast.ts
?? components/users/
?? docs/
?? hooks/
?? lib/admin-api.ts
?? lib/application-state.ts
?? lib/form-schema.ts
?? lib/forms/
?? lib/organizations.ts
?? lib/permissions.ts
?? lib/supplierWizardSchema.ts
?? prisma/migrations/20251117090000_align_membership_role_values/
?? prisma/migrations/20251117120000_add_org_freshdesk_columns/
?? prisma/migrations/20251117125500_sync_schema_core_tables/
?? scripts/
?? supplier_capabilities/
?? tests/
?? vitest.config.ts
```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Preparing summary with code references**

I’m gathering key changes like new features, tests, and docs to highlight in the final response, and I’ll include precise code snippets with line ranges to illustrate important additions such as FormWizardClient and related files. I’ll estimate line numbers using tools to properly format these references per instructions.</details></think>

---

<tool-use data-tool-type="bash" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **command** • Run command: cd /Users/sahilmehta/supplier-onboarding-simple && nl -ba components/forms/form-wizard-client.tsx | sed -n '1,200p'</summary>

```bash
cd /Users/sahilmehta/supplier-onboarding-simple && nl -ba components/forms/form-wizard-client.tsx | sed -n '1,200p'
```

```
     1  &quot;use client&quot;;
     2
     3  import { useCallback, useState, useTransition } from &quot;react&quot;;
     4  import { loadFormDraft, deleteFormDraft, type DraftSaveResult } from &quot;@/app/forms/actions&quot;;                                                             
     5  import type { DraftSummary } from &quot;@/lib/forms/draft-manager&quot;;
     6  import type { FormConfigWithFields } from &quot;@/lib/forms/types&quot;;
     7  import { useToast } from &quot;@/components/ui/use-toast&quot;;
     8  import { DraftResumeDialog } from &quot;./draft-resume-dialog&quot;;
     9  import { DynamicFormWizard } from &quot;./dynamic-form-wizard&quot;;
    10
    11  interface FormWizardClientProps {
    12    formConfig: FormConfigWithFields;
    13    organizationId: string;
    14    initialData?: Record&lt;string, unknown&gt;;
    15    initialStep?: number;
    16    initialApplicationId?: string | null;
    17    drafts?: DraftSummary[];
    18  }
    19
    20  export function FormWizardClient({
    21    formConfig,
    22    organizationId,
    23    initialData = {},
    24    initialStep = 0,
    25    initialApplicationId = null,
    26    drafts: initialDrafts = [],
    27  }: FormWizardClientProps) {
    28    const { toast } = useToast();
    29    const [applicationId, setApplicationId] = useState&lt;string | null&gt;(
    30      initialApplicationId
    31    );
    32    const [seedData, setSeedData] = useState&lt;Record&lt;string, unknown&gt;&gt;(initialData);                                                                       
    33    const [seedStep, setSeedStep] = useState&lt;number&gt;(initialStep);
    34    const [drafts, setDrafts] = useState&lt;DraftSummary[]&gt;(initialDrafts);
    35    const [isPending, startTransition] = useTransition();
    36
    37    const totalSteps = formConfig.sections.length;
    38
    39    const handleApplicationIdChange = useCallback((nextId: string) =&gt; {
    40      setApplicationId(nextId);
    41    }, []);
    42
    43    const handleDraftSaved = useCallback(
    44      (result: DraftSaveResult) =&gt; {
    45        const summary: DraftSummary = {
    46          applicationId: result.applicationId,
    47          formConfigId: formConfig.id,
    48          title: formConfig.title ?? &quot;Untitled Form&quot;,
    49          currentStep: result.currentStep ?? 0,
    50          lastSavedAt: result.updatedAt,
    51          totalSteps,
    52        };
    53
    54        setDrafts((prev) =&gt; {
    55          const filtered = prev.filter(
    56            (draft) =&gt; draft.applicationId !== summary.applicationId
    57          );
    58          return [summary, ...filtered];
    59        });
    60      },
    61      [formConfig.id, formConfig.title, totalSteps]
    62    );
    63
    64    const resetToBlank = useCallback(() =&gt; {
    65      setSeedData({});
    66      setSeedStep(0);
    67      setApplicationId(null);
    68    }, []);
    69
    70    const handleSelectDraft = useCallback(
    71      async (selectedId: string | null) =&gt; {
    72        if (!selectedId) {
    73          resetToBlank();
    74          return;
    75        }
    76
    77        await new Promise&lt;void&gt;((resolve, reject) =&gt; {
    78          startTransition(() =&gt; {
    79            loadFormDraft({
    80              applicationId: selectedId,
    81              organizationId,
    82            })
    83              .then((draft) =&gt; {
    84                if (!draft) {
    85                  throw new Error(&quot;Draft could not be loaded.&quot;);
    86                }
    87                setApplicationId(draft.applicationId);
    88                setSeedData(draft.formData ?? {});
    89                setSeedStep(draft.currentStep ?? 0);
    90                resolve();
    91              })
    92              .catch((error) =&gt; {
    93                toast({
    94                  variant: &quot;destructive&quot;,
    95                  title: &quot;Unable to resume draft&quot;,
    96                  description:
    97                    error instanceof Error ? error.message : &quot;Unknown error.&quot;,                                                                            
    98                });
    99                reject(error);
   100              });
   101          });
   102        });
   103      },
   104      [organizationId, resetToBlank, startTransition, toast]
   105    );
   106
   107    const handleDeleteDraft = useCallback(
   108      async (draftId: string) =&gt; {
   109        await new Promise&lt;void&gt;((resolve, reject) =&gt; {
   110          startTransition(() =&gt; {
   111            deleteFormDraft({
   112              applicationId: draftId,
   113              organizationId,
   114            })
   115              .then(() =&gt; {
   116                setDrafts((prev) =&gt;
   117                  prev.filter((draft) =&gt; draft.applicationId !== draftId)
   118                );
   119                if (applicationId === draftId) {
   120                  resetToBlank();
   121                }
   122                resolve();
   123              })
   124              .catch((error) =&gt; {
   125                toast({
   126                  variant: &quot;destructive&quot;,
   127                  title: &quot;Unable to delete draft&quot;,
   128                  description:
   129                    error instanceof Error ? error.message : &quot;Unknown error.&quot;,                                                                            
   130                });
   131                reject(error);
   132              });
   133          });
   134        });
   135      },
   136      [applicationId, organizationId, resetToBlank, startTransition, toast]                                                                               
   137    );
   138
   139    const handleComplete = useCallback(async (formData: Record&lt;string, unknown&gt;) =&gt; {                                                                     
   140      console.log(&quot;Form completed with data:&quot;, formData);
   141    }, []);
   142
   143    return (
   144      &lt;div className=&quot;space-y-4&quot;&gt;
   145        {drafts.length &gt; 0 &amp;&amp; (
   146          &lt;div className=&quot;flex justify-end&quot;&gt;
   147            &lt;DraftResumeDialog
   148              drafts={drafts}
   149              onSelectDraft={handleSelectDraft}
   150              onDeleteDraft={handleDeleteDraft}
   151              triggerLabel={isPending ? &quot;Working…&quot; : &quot;Resume draft&quot;}
   152            /&gt;
   153          &lt;/div&gt;
   154        )}
   155
   156        &lt;DynamicFormWizard
   157          formConfig={formConfig}
   158          organizationId={organizationId}
   159          initialData={seedData}
   160          initialStep={seedStep}
   161          applicationId={applicationId}
   162          onApplicationIdChange={handleApplicationIdChange}
   163          onDraftSaved={handleDraftSaved}
   164          onComplete={handleComplete}
   165        /&gt;
   166      &lt;/div&gt;
   167    );
   168  }
```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Preparing code snippet extraction**</details></think>

---

<tool-use data-tool-type="bash" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **command** • Run command: cd /Users/sahilmehta/supplier-onboarding-simple && nl -ba lib/forms/draft-manager.ts | sed -n '1,200p'</summary>

```bash
cd /Users/sahilmehta/supplier-onboarding-simple && nl -ba lib/forms/draft-manager.ts | sed -n '1,200p'
```

```
     1  import { prisma } from &quot;@/lib/prisma&quot;;
     2
     3  export const DRAFT_META_KEY = &quot;__draftMeta&quot;;
     4
     5  interface DraftMeta {
     6    currentStep: number;
     7    updatedAt: string;
     8  }
     9
    10  interface PersistedDraftPayload {
    11    [key: string]: unknown;
    12    [DRAFT_META_KEY]?: DraftMeta;
    13  }
    14
    15  export interface DraftSummary {
    16    applicationId: string;
    17    formConfigId: string;
    18    title: string;
    19    lastSavedAt: string;
    20    currentStep: number;
    21    totalSteps: number;
    22  }
    23
    24  export interface DraftRecord {
    25    applicationId: string;
    26    formConfigId: string;
    27    formData: Record&lt;string, unknown&gt;;
    28    currentStep: number;
    29    lastSavedAt: string;
    30  }
    31
    32  export interface SaveDraftOptions {
    33    applicationId?: string | null;
    34    formConfigId: string;
    35    organizationId: string;
    36    entityId: string;
    37    geographyId: string;
    38    userId: string;
    39    formData: Record&lt;string, unknown&gt;;
    40    currentStep: number;
    41  }
    42
    43  export interface LoadDraftOptions {
    44    applicationId: string;
    45    organizationId: string;
    46    userId: string;
    47  }
    48
    49  export interface DraftQueryOptions {
    50    formConfigId: string;
    51    organizationId: string;
    52    entityId: string;
    53    geographyId: string;
    54    userId: string;
    55  }
    56
    57  export interface DeleteDraftOptions {
    58    applicationId: string;
    59    organizationId: string;
    60    userId: string;
    61  }
    62
    63  function encodeDraftPayload(
    64    formData: Record&lt;string, unknown&gt;,
    65    currentStep: number
    66  ): PersistedDraftPayload {
    67    return {
    68      ...formData,
    69      [DRAFT_META_KEY]: {
    70        currentStep,
    71        updatedAt: new Date().toISOString(),
    72      },
    73    };
    74  }
    75
    76  function decodeDraftPayload(
    77    payload: PersistedDraftPayload | null | undefined,
    78    fallbackUpdatedAt: string
    79  ) {
    80    const clonedPayload = { ...(payload ?? {}) };
    81    const metaRaw = clonedPayload[DRAFT_META_KEY];
    82    delete clonedPayload[DRAFT_META_KEY];
    83
    84    const meta = (metaRaw as DraftMeta | undefined) ?? {
    85      currentStep: 0,
    86      updatedAt: fallbackUpdatedAt,
    87    };
    88
    89    return {
    90      formData: clonedPayload,
    91      currentStep: Number.isFinite(meta.currentStep) ? meta.currentStep : 0,                                                                              
    92      lastSavedAt: meta.updatedAt ?? fallbackUpdatedAt,
    93    };
    94  }
    95
    96  function mapApplicationToRecord(application: {
    97    id: string;
    98    formConfigId: string | null;
    99    data: PersistedDraftPayload | null;
   100    updatedAt: Date;
   101  }): DraftRecord {
   102    const decoded = decodeDraftPayload(
   103      application.data,
   104      application.updatedAt.toISOString()
   105    );
   106
   107    return {
   108      applicationId: application.id,
   109      formConfigId: application.formConfigId ?? &quot;&quot;,
   110      formData: decoded.formData,
   111      currentStep: decoded.currentStep,
   112      lastSavedAt: decoded.lastSavedAt ?? application.updatedAt.toISOString(),                                                                            
   113    };
   114  }
   115
   116  export async function saveDraftRecord(
   117    options: SaveDraftOptions
   118  ): Promise&lt;DraftRecord&gt; {
   119    const payload = encodeDraftPayload(options.formData, options.currentStep);                                                                            
   120
   121    if (options.applicationId) {
   122      const existing = await prisma.application.findFirst({
   123        where: {
   124          id: options.applicationId,
   125          organizationId: options.organizationId,
   126          createdById: options.userId,
   127        },
   128        select: { id: true },
   129      });
   130
   131      if (!existing) {
   132        throw new Error(&quot;Draft not found or access denied&quot;);
   133      }
   134
   135      const updated = await prisma.application.update({
   136        where: { id: options.applicationId },
   137        data: {
   138          data: payload,
   139          formConfigId: options.formConfigId,
   140          entityId: options.entityId,
   141          geographyId: options.geographyId,
   142          updatedById: options.userId,
   143          status: &quot;DRAFT&quot;,
   144        },
   145        select: {
   146          id: true,
   147          data: true,
   148          updatedAt: true,
   149          formConfigId: true,
   150        },
   151      });
   152
   153      return mapApplicationToRecord(updated);
   154    }
   155
   156    const created = await prisma.application.create({
   157      data: {
   158        organizationId: options.organizationId,
   159        entityId: options.entityId,
   160        geographyId: options.geographyId,
   161        formConfigId: options.formConfigId,
   162        status: &quot;DRAFT&quot;,
   163        data: payload,
   164        createdById: options.userId,
   165        updatedById: options.userId,
   166      },
   167      select: {
   168        id: true,
   169        data: true,
   170        updatedAt: true,
   171        formConfigId: true,
   172      },
   173    });
   174
   175    return mapApplicationToRecord(created);
   176  }
   177
   178  export async function loadDraftRecord(
   179    options: LoadDraftOptions
   180  ): Promise&lt;DraftRecord | null&gt; {
   181    const draft = await prisma.application.findFirst({
   182      where: {
   183        id: options.applicationId,
   184        organizationId: options.organizationId,
   185        createdById: options.userId,
   186        status: &quot;DRAFT&quot;,
   187      },
   188      select: {
   189        id: true,
   190        data: true,
   191        updatedAt: true,
   192        formConfigId: true,
   193      },
   194    });
   195
   196    if (!draft) {
   197      return null;
   198    }
   199
   200    return mapApplicationToRecord(draft);
```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Checking route page snippet**</details></think>

---

<tool-use data-tool-type="bash" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **command** • Run command: cd /Users/sahilmehta/supplier-onboarding-simple && nl -ba app/forms/[formConfigId]/page.tsx | sed -n '1,200p'</summary>

```bash
cd /Users/sahilmehta/supplier-onboarding-simple && nl -ba app/forms/[formConfigId]/page.tsx | sed -n '1,200p'
```

```
zsh: no matches found: app/forms/[formConfigId]/page.tsx
```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Adding quotes to escape path**</details></think>

---

<tool-use data-tool-type="bash" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **command** • Run command: cd /Users/sahilmehta/supplier-onboarding-simple && nl -ba 'app/forms/[formConfigId]/page.tsx' | sed -n '1,200p'</summary>

```bash
cd /Users/sahilmehta/supplier-onboarding-simple && nl -ba 'app/forms/[formConfigId]/page.tsx' | sed -n '1,200p'
```

```
     1  import { redirect } from &quot;next/navigation&quot;;
     2  import { notFound } from &quot;next/navigation&quot;;
     3  import { auth } from &quot;@/lib/auth&quot;;
     4  import { getFormConfigById } from &quot;@/lib/forms/form-config-fetcher&quot;;
     5  import { FormWizardClient } from &quot;@/components/forms/form-wizard-client&quot;;                                                                               
     6  import { getCurrentUserMembership } from &quot;@/lib/permissions&quot;;
     7  import {
     8    listDraftSummaries,
     9    loadDraftRecord,
    10  } from &quot;@/lib/forms/draft-manager&quot;;
    11
    12  interface Params {
    13    formConfigId: string;
    14  }
    15
    16  export default async function FormByConfigIdPage({
    17    params,
    18  }: {
    19    params: Promise&lt;Params&gt;;
    20  }) {
    21    const { formConfigId } = await params;
    22    const session = await auth();
    23
    24    // Authentication check
    25    if (!session?.user?.id) {
    26      redirect(&quot;/signin&quot;);
    27    }
    28
    29    const membership = await getCurrentUserMembership();
    30    if (!membership) {
    31      redirect(&quot;/signin&quot;);
    32    }
    33
    34    // Fetch form config
    35    const formConfig = await getFormConfigById(formConfigId);
    36
    37    if (!formConfig) {
    38      notFound();
    39    }
    40
    41    const drafts = await listDraftSummaries({
    42      formConfigId: formConfig.id,
    43      organizationId: membership.organizationId,
    44      entityId: formConfig.entityId,
    45      geographyId: formConfig.geographyId,
    46      userId: session.user.id,
    47    });
    48
    49    const initialDraft =
    50      drafts.length &gt; 0
    51        ? await loadDraftRecord({
    52            applicationId: drafts[0].applicationId,
    53            organizationId: membership.organizationId,
    54            userId: session.user.id,
    55          })
    56        : null;
    57
    58    return (
    59      &lt;div className=&quot;container mx-auto w-full max-w-5xl px-4 py-10&quot;&gt;
    60        &lt;div className=&quot;space-y-6&quot;&gt;
    61          &lt;header&gt;
    62            &lt;p className=&quot;text-sm font-semibold uppercase tracking-wide text-muted-foreground&quot;&gt;                                                           
    63              Responsive Wizard
    64            &lt;/p&gt;
    65            &lt;h1 className=&quot;mt-1 text-3xl font-semibold&quot;&gt;
    66              {formConfig.title || &quot;Form Configuration&quot;}
    67            &lt;/h1&gt;
    68            {formConfig.description &amp;&amp; (
    69              &lt;p className=&quot;mt-2 text-base text-muted-foreground&quot;&gt;
    70                {formConfig.description}
    71              &lt;/p&gt;
    72            )}
    73            {!formConfig.isActive &amp;&amp; (
    74              &lt;p className=&quot;mt-2 text-sm text-amber-600&quot;&gt;
    75                (This form configuration is inactive)
    76              &lt;/p&gt;
    77            )}
    78          &lt;/header&gt;
    79          &lt;FormWizardClient
    80            formConfig={formConfig}
    81            organizationId={membership.organizationId}
    82            initialData={initialDraft?.formData ?? {}}
    83            initialStep={initialDraft?.currentStep ?? 0}
    84            initialApplicationId={initialDraft?.applicationId ?? null}
    85            drafts={drafts}
    86          /&gt;
    87        &lt;/div&gt;
    88      &lt;/div&gt;
    89    );
    90  }
    91
```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Listing top lines of doc file**</details></think>

---

<tool-use data-tool-type="bash" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **command** • Run command: cd /Users/sahilmehta/supplier-onboarding-simple && nl -ba docs/agent-stream-5-state-draft.md | sed -n '1,80p'</summary>

```bash
cd /Users/sahilmehta/supplier-onboarding-simple && nl -ba docs/agent-stream-5-state-draft.md | sed -n '1,80p'
```

```
     1  # Agent: Stream 5 - State Management &amp; Draft Persistence
     2
     3  **Agent ID**: STREAM-5  
     4  **Status**: Complete  
     5  **Owner**: [Assign Developer]  
     6  **Start Date**: [Date]  
     7  **Target Completion**: [Date + 5-6 days]
     8
     9  ## Mission
    10
    11  Implement form state management, autosave functionality, draft persistence, and resume flow. This enables users to save their progress and resume forms later.                                                                          
    12
    13  ## Current Tasks
    14
    15  ### Active Task
    16  - [x] **Task 5.1**: Implement form state management
    17
    18  ### Next Tasks
    19  - [x] **Task 5.2**: Implement autosave logic (debounced)
    20  - [x] **Task 5.3**: Build draft save server action
    21  - [x] **Task 5.4**: Implement draft load on form mount
    22  - [x] **Task 5.5**: Add &quot;Save Draft&quot; explicit button
    23  - [x] **Task 5.6**: Handle resume flow (existing drafts)
    24
    25  ## Files to Create
    26
    27  &#96;&#96;&#96;
    28  lib/
    29    forms/
    30      form-state.ts                # State management utilities
    31      draft-manager.ts              # Draft save/load logic
    32
    33  hooks/
    34    use-form-state.ts              # Form state management hook
    35    use-autosave.ts                 # Autosave hook with debouncing
    36
    37  app/
    38    forms/
    39      actions.ts                    # Server actions for draft save/load
    40
    41  components/
    42    forms/
    43      draft-resume-dialog.tsx      # Dialog for multiple drafts
    44      draft-save-indicator.tsx     # &quot;Draft saved&quot; feedback component
    45  &#96;&#96;&#96;
    46
    47  ## Files to Update
    48
    49  &#96;&#96;&#96;
    50  components/
    51    forms/
    52      dynamic-form-wizard.tsx      # Integrate state management and autosave                                                                              
    53      form-navigation.tsx           # Add Save Draft button
    54
    55  app/
    56    forms/
    57      [entityCode]/
    58        [geographyCode]/
    59          page.tsx                  # Load draft on mount
    60      [formConfigId]/
    61        page.tsx                    # Load draft on mount
    62  &#96;&#96;&#96;
    63
    64  ## Key Dependencies
    65
    66  **Depends on:**
    67  - ✅ Stream 1 (Routes) - Complete - Need routes for server actions
    68  - ✅ Stream 3 (Wizard UI) - Complete - Need wizard framework
    69
    70  **Provides to:**
    71  - Stream 6 (Conditional Fields) - Needs form state for visibility evaluation                                                                            
    72  - Stream 8 (Testing) - Needs draft functionality for testing
    73
    74  **Can work in parallel with:**
    75  - Stream 7 (Responsive &amp; A11y) - No conflicts
    76
    77  ## Integration Points
    78
    79  1. **With Stream 3**: Integrate state management into &#96;DynamicFormWizard&#96;                                                                               
    80  2. **With Stream 1**: Use routes for server actions
```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Preparing summary details for code changes**</details></think>

---

<tool-use data-tool-type="bash" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **command** • Run command: cd /Users/sahilmehta/supplier-onboarding-simple && nl -ba app/forms/actions.ts | sed -n '1,200p'</summary>

```bash
cd /Users/sahilmehta/supplier-onboarding-simple && nl -ba app/forms/actions.ts | sed -n '1,200p'
```

```
     1  &quot;use server&quot;;
     2
     3  import { auth } from &quot;@/lib/auth&quot;;
     4  import { prisma } from &quot;@/lib/prisma&quot;;
     5  import {
     6    deleteDraftRecord,
     7    listDraftSummaries,
     8    loadDraftRecord,
     9    saveDraftRecord,
    10    type DraftRecord,
    11    type DraftSummary,
    12  } from &quot;@/lib/forms/draft-manager&quot;;
    13
    14  interface SaveFormDraftInput {
    15    formConfigId: string;
    16    organizationId: string;
    17    entityId: string;
    18    geographyId: string;
    19    applicationId?: string | null;
    20    formData: Record&lt;string, unknown&gt;;
    21    currentStep: number;
    22  }
    23
    24  export interface DraftSaveResult {
    25    success: boolean;
    26    applicationId: string;
    27    currentStep: number;
    28    updatedAt: string;
    29  }
    30
    31  export interface DraftLoadResult extends DraftRecord {}
    32
    33  interface LoadFormDraftInput {
    34    organizationId: string;
    35    applicationId: string;
    36  }
    37
    38  interface DeleteFormDraftInput extends LoadFormDraftInput {}
    39
    40  interface ListDraftsInput {
    41    organizationId: string;
    42    formConfigId: string;
    43    entityId: string;
    44    geographyId: string;
    45  }
    46
    47  async function ensureMembership(userId: string, organizationId: string) {                                                                               
    48    const membership = await prisma.membership.findFirst({
    49      where: { userId, organizationId },
    50      select: { id: true },
    51    });
    52
    53    if (!membership) {
    54      throw new Error(&quot;Unauthorized&quot;);
    55    }
    56  }
    57
    58  export async function saveFormDraft(
    59    input: SaveFormDraftInput
    60  ): Promise&lt;DraftSaveResult&gt; {
    61    const session = await auth();
    62    if (!session?.user?.id) {
    63      throw new Error(&quot;Unauthorized&quot;);
    64    }
    65
    66    await ensureMembership(session.user.id, input.organizationId);
    67
    68    const record = await saveDraftRecord({
    69      applicationId: input.applicationId,
    70      formConfigId: input.formConfigId,
    71      organizationId: input.organizationId,
    72      entityId: input.entityId,
    73      geographyId: input.geographyId,
    74      formData: input.formData,
    75      currentStep: input.currentStep,
    76      userId: session.user.id,
    77    });
    78
    79    return {
    80      success: true,
    81      applicationId: record.applicationId,
    82      currentStep: record.currentStep,
    83      updatedAt: record.lastSavedAt,
    84    };
    85  }
    86
    87  export async function loadFormDraft(
    88    input: LoadFormDraftInput
    89  ): Promise&lt;DraftLoadResult | null&gt; {
    90    const session = await auth();
    91    if (!session?.user?.id) {
    92      throw new Error(&quot;Unauthorized&quot;);
    93    }
    94
    95    await ensureMembership(session.user.id, input.organizationId);
    96
    97    return loadDraftRecord({
    98      applicationId: input.applicationId,
    99      organizationId: input.organizationId,
   100      userId: session.user.id,
   101    });
   102  }
   103
   104  export async function deleteFormDraft(
   105    input: DeleteFormDraftInput
   106  ): Promise&lt;{ success: boolean }&gt; {
   107    const session = await auth();
   108    if (!session?.user?.id) {
   109      throw new Error(&quot;Unauthorized&quot;);
   110    }
   111
   112    await ensureMembership(session.user.id, input.organizationId);
   113    await deleteDraftRecord({
   114      applicationId: input.applicationId,
   115      organizationId: input.organizationId,
   116      userId: session.user.id,
   117    });
   118
   119    return { success: true };
   120  }
   121
   122  export async function getUserDrafts(
   123    input: ListDraftsInput
   124  ): Promise&lt;DraftSummary[]&gt; {
   125    const session = await auth();
   126    if (!session?.user?.id) {
   127      throw new Error(&quot;Unauthorized&quot;);
   128    }
   129
   130    await ensureMembership(session.user.id, input.organizationId);
   131
   132    return listDraftSummaries({
   133      formConfigId: input.formConfigId,
   134      organizationId: input.organizationId,
   135      entityId: input.entityId,
   136      geographyId: input.geographyId,
   137      userId: session.user.id,
   138    });
   139  }
   140
```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Selecting code snippet for DynamicFormWizard documentation**</details></think>

---

<tool-use data-tool-type="bash" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **command** • Run command: cd /Users/sahilmehta/supplier-onboarding-simple && nl -ba components/forms/dynamic-form-wizard.tsx | sed -n '1,200p'</summary>

```bash
cd /Users/sahilmehta/supplier-onboarding-simple && nl -ba components/forms/dynamic-form-wizard.tsx | sed -n '1,200p'
```

```
     1  &quot;use client&quot;;
     2
     3  import { useCallback, useEffect, useMemo, useRef, useState } from &quot;react&quot;;                                                                              
     4  import type { FormConfigWithFields } from &quot;@/lib/forms/types&quot;;
     5  import { getStepFieldKeys } from &quot;@/lib/forms/form-validator&quot;;
     6  import { buildFormSchema } from &quot;@/lib/form-schema&quot;;
     7  import { saveFormDraft, type DraftSaveResult } from &quot;@/app/forms/actions&quot;;                                                                              
     8  import { StepIndicator } from &quot;./step-indicator&quot;;
     9  import { FormStep } from &quot;./form-step&quot;;
    10  import { FormNavigation } from &quot;./form-navigation&quot;;
    11  import { FormErrorSummary } from &quot;./form-error-summary&quot;;
    12  import { useFormState } from &quot;@/hooks/use-form-state&quot;;
    13  import { useAutosave } from &quot;@/hooks/use-autosave&quot;;
    14  import { useToast } from &quot;@/components/ui/use-toast&quot;;
    15  import { usePrefersReducedMotion } from &quot;@/hooks/use-prefers-reduced-motion&quot;;                                                                           
    16  import { cn } from &quot;@/lib/utils&quot;;
    17
    18  interface DynamicFormWizardProps {
    19    formConfig: FormConfigWithFields;
    20    initialData?: Record&lt;string, unknown&gt;;
    21    initialStep?: number;
    22    applicationId: string | null;
    23    organizationId: string;
    24    onApplicationIdChange?: (applicationId: string) =&gt; void;
    25    onDraftSaved?: (result: DraftSaveResult) =&gt; void;
    26    onStepChange?: (stepIndex: number) =&gt; void;
    27    onComplete?: (formData: Record&lt;string, unknown&gt;) =&gt; Promise&lt;void&gt; | void;                                                                             
    28  }
    29
    30  const clampStep = (step: number, totalSteps: number) =&gt; {
    31    if (totalSteps &lt;= 0) {
    32      return 0;
    33    }
    34    return Math.max(0, Math.min(step, totalSteps - 1));
    35  };
    36
    37  export function DynamicFormWizard({
    38    formConfig,
    39    initialData = {},
    40    initialStep = 0,
    41    applicationId,
    42    organizationId,
    43    onApplicationIdChange,
    44    onDraftSaved,
    45    onStepChange,
    46    onComplete,
    47  }: DynamicFormWizardProps) {
    48    const sortedSections = useMemo(
    49      () =&gt; [...formConfig.sections].sort((a, b) =&gt; a.order - b.order),
    50      [formConfig.sections]
    51    );
    52
    53    const totalSteps = sortedSections.length;
    54    const safeInitialStep = clampStep(initialStep ?? 0, totalSteps);
    55
    56    const {
    57      state,
    58      touchedMap,
    59      setFieldValue,
    60      markFieldTouched,
    61      markFieldsTouched,
    62      setFieldError,
    63      setStepErrors,
    64      goToStep,
    65      markStepComplete,
    66      setIsSubmitting,
    67      markClean,
    68      resetForm,
    69      validateAndCommitStep,
    70    } = useFormState({
    71      formConfig,
    72      initialData,
    73      initialStep: safeInitialStep,
    74    });
    75
    76    const [liveMessage, setLiveMessage] = useState(&quot;&quot;);
    77    const validationTimersRef = useRef&lt;Record&lt;string, NodeJS.Timeout&gt;&gt;({});                                                                               
    78    const formSchemaRef = useRef(buildFormSchema(formConfig));
    79    const prefersReducedMotion = usePrefersReducedMotion();
    80    const { toast } = useToast();
    81    const initialSnapshotRef = useRef(
    82      JSON.stringify({ data: initialData, step: safeInitialStep, applicationId })                                                                         
    83    );
    84
    85    const isFirstStep = state.currentStep === 0;
    86    const isLastStep = state.currentStep === totalSteps - 1;
    87    const currentSection = sortedSections[state.currentStep];
    88
    89    useEffect(() =&gt; {
    90      formSchemaRef.current = buildFormSchema(formConfig);
    91    }, [formConfig]);
    92
    93    useEffect(() =&gt; {
    94      const nextSnapshot = JSON.stringify({
    95        data: initialData,
    96        step: safeInitialStep,
    97        applicationId,
    98      });
    99
   100      if (nextSnapshot !== initialSnapshotRef.current) {
   101        resetForm(initialData, safeInitialStep);
   102        initialSnapshotRef.current = nextSnapshot;
   103      }
   104    }, [initialData, resetForm, safeInitialStep, applicationId]);
   105
   106    const focusFirstError = useCallback(
   107      (fieldKey?: string) =&gt; {
   108        if (!fieldKey || !currentSection) {
   109          return;
   110        }
   111        const errorField = currentSection.fields.find((field) =&gt; field.key === fieldKey);                                                                 
   112        const fieldElement = errorField
   113          ? document.getElementById(&#96;field-${errorField.id}&#96;)
   114          : null;
   115        fieldElement?.focus();
   116        fieldElement?.scrollIntoView({ behavior: &quot;smooth&quot;, block: &quot;center&quot; });                                                                            
   117      },
   118      [currentSection]
   119    );
   120
   121    const validateField = useCallback(
   122      (fieldKey: string, value: unknown, immediate = false) =&gt; {
   123        if (validationTimersRef.current[fieldKey]) {
   124          clearTimeout(validationTimersRef.current[fieldKey]);
   125        }
   126
   127        const performValidation = () =&gt; {
   128          const fieldSchema = formSchemaRef.current.shape[fieldKey];
   129          if (!fieldSchema) {
   130            return;
   131          }
   132
   133          try {
   134            fieldSchema.parse(value);
   135            setFieldError(fieldKey);
   136          } catch (error) {
   137            if (error &amp;&amp; typeof error === &quot;object&quot; &amp;&amp; &quot;issues&quot; in error) {
   138              const zodError = error as { issues: Array&lt;{ message: string }&gt; };                                                                           
   139              const firstIssue = zodError.issues[0];
   140              if (firstIssue) {
   141                setFieldError(fieldKey, firstIssue.message);
   142              }
   143            } else if (error instanceof Error) {
   144              setFieldError(fieldKey, error.message);
   145            }
   146          }
   147        };
   148
   149        if (immediate) {
   150          performValidation();
   151        } else {
   152          validationTimersRef.current[fieldKey] = setTimeout(performValidation, 300);                                                                     
   153        }
   154      },
   155      [setFieldError]
   156    );
   157
   158    const handleFieldChange = useCallback(
   159      (fieldKey: string, value: unknown) =&gt; {
   160        setFieldValue(fieldKey, value);
   161        if (state.touched.has(fieldKey)) {
   162          validateField(fieldKey, value, false);
   163        }
   164      },
   165      [setFieldValue, state.touched, validateField]
   166    );
   167
   168    const handleFieldBlur = useCallback(
   169      (fieldKey: string) =&gt; {
   170        markFieldTouched(fieldKey);
   171        validateField(fieldKey, state.formData[fieldKey], true);
   172      },
   173      [markFieldTouched, state.formData, validateField]
   174    );
   175
   176    const autosaveFingerprint = useMemo(
   177      () =&gt; JSON.stringify({ data: state.formData, step: state.currentStep }),                                                                            
   178      [state.formData, state.currentStep]
   179    );
   180
   181    const runDraftSave = useCallback(() =&gt; {
   182      return saveFormDraft({
   183        formConfigId: formConfig.id,
   184        organizationId,
   185        entityId: formConfig.entityId,
   186        geographyId: formConfig.geographyId,
   187        applicationId,
   188        formData: state.formData,
   189        currentStep: state.currentStep,
   190      });
   191    }, [
   192      applicationId,
   193      formConfig.entityId,
   194      formConfig.geographyId,
   195      formConfig.id,
   196      organizationId,
   197      state.currentStep,
   198      state.formData,
   199    ]);
   200
```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Preparing detailed summary with code citations**</details></think>

---

<tool-use data-tool-type="bash" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **command** • Run command: cd /Users/sahilmehta/supplier-onboarding-simple && sed -n '37,120p' components/forms/dynamic-form-wizard.tsx</summary>

```bash
cd /Users/sahilmehta/supplier-onboarding-simple && sed -n '37,120p' components/forms/dynamic-form-wizard.tsx
```

```
export function DynamicFormWizard({
  formConfig,
  initialData = {},
  initialStep = 0,
  applicationId,
  organizationId,
  onApplicationIdChange,
  onDraftSaved,
  onStepChange,
  onComplete,
}: DynamicFormWizardProps) {
  const sortedSections = useMemo(
    () =&gt; [...formConfig.sections].sort((a, b) =&gt; a.order - b.order),
    [formConfig.sections]
  );

  const totalSteps = sortedSections.length;
  const safeInitialStep = clampStep(initialStep ?? 0, totalSteps);

  const {
    state,
    touchedMap,
    setFieldValue,
    markFieldTouched,
    markFieldsTouched,
    setFieldError,
    setStepErrors,
    goToStep,
    markStepComplete,
    setIsSubmitting,
    markClean,
    resetForm,
    validateAndCommitStep,
  } = useFormState({
    formConfig,
    initialData,
    initialStep: safeInitialStep,
  });

  const [liveMessage, setLiveMessage] = useState(&quot;&quot;);
  const validationTimersRef = useRef&lt;Record&lt;string, NodeJS.Timeout&gt;&gt;({});
  const formSchemaRef = useRef(buildFormSchema(formConfig));
  const prefersReducedMotion = usePrefersReducedMotion();
  const { toast } = useToast();
  const initialSnapshotRef = useRef(
    JSON.stringify({ data: initialData, step: safeInitialStep, applicationId })
  );

  const isFirstStep = state.currentStep === 0;
  const isLastStep = state.currentStep === totalSteps - 1;
  const currentSection = sortedSections[state.currentStep];

  useEffect(() =&gt; {
    formSchemaRef.current = buildFormSchema(formConfig);
  }, [formConfig]);

  useEffect(() =&gt; {
    const nextSnapshot = JSON.stringify({
      data: initialData,
      step: safeInitialStep,
      applicationId,
    });

    if (nextSnapshot !== initialSnapshotRef.current) {
      resetForm(initialData, safeInitialStep);
      initialSnapshotRef.current = nextSnapshot;
    }
  }, [initialData, resetForm, safeInitialStep, applicationId]);

  const focusFirstError = useCallback(
    (fieldKey?: string) =&gt; {
      if (!fieldKey || !currentSection) {
        return;
      }
      const errorField = currentSection.fields.find((field) =&gt; field.key === fieldKey);                                                                         
      const fieldElement = errorField
        ? document.getElementById(&#96;field-${errorField.id}&#96;)
        : null;
      fieldElement?.focus();
      fieldElement?.scrollIntoView({ behavior: &quot;smooth&quot;, block: &quot;center&quot; });
    },
    [currentSection]
  );
```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Preparing code snippet embedding**</details></think>

---

<tool-use data-tool-type="bash" data-tool-name="run_terminal_cmd">
<details><summary>Tool use: **command** • Run command: cd /Users/sahilmehta/supplier-onboarding-simple && sed -n '37,155p' components/forms/form-wizard-client.tsx</summary>

```bash
cd /Users/sahilmehta/supplier-onboarding-simple && sed -n '37,155p' components/forms/form-wizard-client.tsx
```

```
  const totalSteps = formConfig.sections.length;

  const handleApplicationIdChange = useCallback((nextId: string) =&gt; {
    setApplicationId(nextId);
  }, []);

  const handleDraftSaved = useCallback(
    (result: DraftSaveResult) =&gt; {
      const summary: DraftSummary = {
        applicationId: result.applicationId,
        formConfigId: formConfig.id,
        title: formConfig.title ?? &quot;Untitled Form&quot;,
        currentStep: result.currentStep ?? 0,
        lastSavedAt: result.updatedAt,
        totalSteps,
      };

      setDrafts((prev) =&gt; {
        const filtered = prev.filter(
          (draft) =&gt; draft.applicationId !== summary.applicationId
        );
        return [summary, ...filtered];
      });
    },
    [formConfig.id, formConfig.title, totalSteps]
  );

  const resetToBlank = useCallback(() =&gt; {
    setSeedData({});
    setSeedStep(0);
    setApplicationId(null);
  }, []);

  const handleSelectDraft = useCallback(
    async (selectedId: string | null) =&gt; {
      if (!selectedId) {
        resetToBlank();
        return;
      }

      await new Promise&lt;void&gt;((resolve, reject) =&gt; {
        startTransition(() =&gt; {
          loadFormDraft({
            applicationId: selectedId,
            organizationId,
          })
            .then((draft) =&gt; {
              if (!draft) {
                throw new Error(&quot;Draft could not be loaded.&quot;);
              }
              setApplicationId(draft.applicationId);
              setSeedData(draft.formData ?? {});
              setSeedStep(draft.currentStep ?? 0);
              resolve();
            })
            .catch((error) =&gt; {
              toast({
                variant: &quot;destructive&quot;,
                title: &quot;Unable to resume draft&quot;,
                description:
                  error instanceof Error ? error.message : &quot;Unknown error.&quot;,
              });
              reject(error);
            });
        });
      });
    },
    [organizationId, resetToBlank, startTransition, toast]
  );

  const handleDeleteDraft = useCallback(
    async (draftId: string) =&gt; {
      await new Promise&lt;void&gt;((resolve, reject) =&gt; {
        startTransition(() =&gt; {
          deleteFormDraft({
            applicationId: draftId,
            organizationId,
          })
            .then(() =&gt; {
              setDrafts((prev) =&gt;
                prev.filter((draft) =&gt; draft.applicationId !== draftId)
              );
              if (applicationId === draftId) {
                resetToBlank();
              }
              resolve();
            })
            .catch((error) =&gt; {
              toast({
                variant: &quot;destructive&quot;,
                title: &quot;Unable to delete draft&quot;,
                description:
                  error instanceof Error ? error.message : &quot;Unknown error.&quot;,
              });
              reject(error);
            });
        });
      });
    },
    [applicationId, organizationId, resetToBlank, startTransition, toast]
  );

  const handleComplete = useCallback(async (formData: Record&lt;string, unknown&gt;) =&gt; {                                                                             
    console.log(&quot;Form completed with data:&quot;, formData);
  }, []);

  return (
    &lt;div className=&quot;space-y-4&quot;&gt;
      {drafts.length &gt; 0 &amp;&amp; (
        &lt;div className=&quot;flex justify-end&quot;&gt;
          &lt;DraftResumeDialog
            drafts={drafts}
            onSelectDraft={handleSelectDraft}
            onDeleteDraft={handleDeleteDraft}
            triggerLabel={isPending ? &quot;Working…&quot; : &quot;Resume draft&quot;}
          /&gt;
        &lt;/div&gt;
      )}
```
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Preparing detailed summary with code snippets**</details></think>

---

## Summary
- `DynamicFormWizard` now clamps steps, rebuilds field schemas when configs change, and resets the reducer any time a different draft/data set arrives so autosave and validation stay in sync. This keeps autosave + manual resume flows stable across draft switches and still drives the debounced validation timers and focus management you added earlier.
```37:93:components/forms/dynamic-form-wizard.tsx
export function DynamicFormWizard({
  formConfig,
  initialData = {},
  initialStep = 0,
  applicationId,
  organizationId,
  onApplicationIdChange,
  onDraftSaved,
  onStepChange,
  onComplete,
}: DynamicFormWizardProps) {
  ...
  const initialSnapshotRef = useRef(
    JSON.stringify({ data: initialData, step: safeInitialStep, applicationId })
  );
  ...
  useEffect(() => {
    const nextSnapshot = JSON.stringify({
      data: initialData,
      step: safeInitialStep,
      applicationId,
    });

    if (nextSnapshot !== initialSnapshotRef.current) {
      resetForm(initialData, safeInitialStep);
      initialSnapshotRef.current = nextSnapshot;
    }
  }, [initialData, resetForm, safeInitialStep, applicationId]);
```

- `FormWizardClient` now orchestrates the full draft lifecycle on the client: it tracks the current draft/applicationId, injects the `DraftResumeDialog`, loads or deletes drafts through server actions, and keeps the drawer list in sync whenever autosave creates/updates a draft.
```37:149:components/forms/form-wizard-client.tsx
const handleDraftSaved = useCallback(
  (result: DraftSaveResult) => {
    const summary: DraftSummary = {
      applicationId: result.applicationId,
      formConfigId: formConfig.id,
      title: formConfig.title ?? "Untitled Form",
      currentStep: result.currentStep ?? 0,
      lastSavedAt: result.updatedAt,
      totalSteps,
    };

    setDrafts((prev) => {
      const filtered = prev.filter(
        (draft) => draft.applicationId !== summary.applicationId
      );
      return [summary, ...filtered];
    });
  },
  [formConfig.id, formConfig.title, totalSteps]
);

const handleSelectDraft = useCallback(
  async (selectedId: string | null) => {
    if (!selectedId) {
      resetToBlank();
      return;
    }

    await new Promise<void>((resolve, reject) => {
      startTransition(() => {
        loadFormDraft({
          applicationId: selectedId,
          organizationId,
        })
          .then((draft) => {
            if (!draft) {
              throw new Error("Draft could not be loaded.");
            }
            setApplicationId(draft.applicationId);
            setSeedData(draft.formData ?? {});
            setSeedStep(draft.currentStep ?? 0);
            resolve();
          })
          .catch((error) => {
            toast({
              variant: "destructive",
              title: "Unable to resume draft",
              description:
                error instanceof Error ? error.message : "Unknown error.",
            });
            reject(error);
          });
      });
    });
  },
  [organizationId, resetToBlank, startTransition, toast]
);
```

- Draft persistence now records metadata in JSON, surfaces rich summaries (title, totals, last-saved) and exposes a `getUserDrafts` action so routes and clients share the same source of truth.
```15:138:lib/forms/draft-manager.ts
export interface DraftSummary {
  applicationId: string;
  formConfigId: string;
  title: string;
  lastSavedAt: string;
  currentStep: number;
  totalSteps: number;
}
...
export async function saveDraftRecord(
  options: SaveDraftOptions
): Promise<DraftRecord> {
  const payload = encodeDraftPayload(options.formData, options.currentStep);
  ...
  return mapApplicationToRecord(created);
}
```

```5:139:app/forms/actions.ts
import {
  deleteDraftRecord,
  listDraftSummaries,
  loadDraftRecord,
  saveDraftRecord,
  type DraftRecord,
  type DraftSummary,
} from "@/lib/forms/draft-manager";
...
export async function getUserDrafts(
  input: ListDraftsInput
): Promise<DraftSummary[]> {
  const session = await auth();
  ...
  return listDraftSummaries({
    formConfigId: input.formConfigId,
    organizationId: input.organizationId,
    entityId: input.entityId,
    geographyId: input.geographyId,
    userId: session.user.id,
  });
}
```

- The form routes now fetch the user’s membership, pre-load any existing drafts, and pass both the initial payload and the summaries down to the client so the resume dialog shows up immediately.
```1:88:app/forms/[formConfigId]/page.tsx
const drafts = await listDraftSummaries({
  formConfigId: formConfig.id,
  organizationId: membership.organizationId,
  entityId: formConfig.entityId,
  geographyId: formConfig.geographyId,
  userId: session.user.id,
});

const initialDraft =
  drafts.length > 0
    ? await loadDraftRecord({
        applicationId: drafts[0].applicationId,
        organizationId: membership.organizationId,
        userId: session.user.id,
      })
    : null;

<FormWizardClient
  formConfig={formConfig}
  organizationId={membership.organizationId}
  initialData={initialDraft?.formData ?? {}}
  initialStep={initialDraft?.currentStep ?? 0}
  initialApplicationId={initialDraft?.applicationId ?? null}
  drafts={drafts}
/>
```

- Stream 5’s spec is now marked complete with every sub-task checked off.
```1:23:docs/agent-stream-5-state-draft.md
**Status**: Complete  
...
- [x] **Task 5.6**: Handle resume flow (existing drafts)
```

## Testing
- `npm run lint`

## Notes
- Route loaders currently pick the first available membership as the “active” organization; if users can belong to multiple orgs we may want a picker or query param to disambiguate before we surface drafts from the wrong tenant.
- `FormWizardClient` still logs submissions to the console; once the downstream submission endpoint is ready we should replace `handleComplete` with the actual submit action.

---

